<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<title>2016 講義資料</title>
<!-- 2016-10-03 月 17:54 -->
<meta  http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta  name="generator" content="Org-mode" />
<meta  name="author" content="suzuki@cis.iwate-u.ac.jp" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center; }
  .todo   { font-family: monospace; color: red; }
  .done   { color: green; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  pre.src-sh:before    { content: 'sh'; }
  pre.src-bash:before  { content: 'sh'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-R:before     { content: 'R'; }
  pre.src-perl:before  { content: 'Perl'; }
  pre.src-java:before  { content: 'Java'; }
  pre.src-sql:before   { content: 'SQL'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.right  { text-align: center;  }
  th.left   { text-align: center;   }
  th.center { text-align: center; }
  td.right  { text-align: right;  }
  td.left   { text-align: left;   }
  td.center { text-align: center; }
  dt { font-weight: bold; }
  .footpara:nth-child(2) { display: inline; }
  .footpara { display: block; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  /*]]>*/-->
</style>
<link rel="stylesheet" type="text/css" href="styles/readtheorg/css/htmlize.css"/>
<link rel="stylesheet" type="text/css" href="http://wiki.cis.iwate-u.ac.jp/~suzuki/org-html-theme/styles/sos/css/sos.css">
<link rel="stylesheet" type="text/css" href="http://www.pirilampo.org/styles/bigblow/css/hideshow.css"/>
<script type="text/javascript" src="http://www.pirilampo.org/styles/bigblow/js/jquery-1.11.0.min.js"></script>
<script type="text/javascript" src="http://www.pirilampo.org/styles/bigblow/js/jquery-ui-1.10.2.min.js"></script>
<script type="text/javascript" src="http://www.pirilampo.org/styles/bigblow/js/jquery.localscroll-min.js"></script>
<script type="text/javascript" src="http://www.pirilampo.org/styles/bigblow/js/jquery.scrollTo-1.4.3.1-min.js"></script>
<script type="text/javascript" src="http://www.pirilampo.org/styles/bigblow/js/jquery.zclip.min.js"></script>
<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.4/js/bootstrap.min.js"></script>
<script type="text/javascript" src="styles/lib/js/jquery.stickytableheaders.min.js"></script>
<script type="text/javascript" src="http://www.pirilampo.org/styles/bigblow/js/hideshow.js"></script>
<script type="text/javascript" src="http://www.pirilampo.org/styles/lib/js/jquery.stickytableheaders.min.js"></script>
<script type="text/javascript" src="http://wiki.cis.iwate-u.ac.jp/~suzuki/org-html-theme/styles/sos/js/hideshow.js"></script>
<script type="text/javascript" src="http://wiki.cis.iwate-u.ac.jp/~suzuki/org-html-theme/styles/sos/js/sos.js"></script>
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2013 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
<script type="text/javascript" src="http://orgmode.org/mathjax/MathJax.js"></script>
<script type="text/javascript">
<!--/*--><![CDATA[/*><!--*/
    MathJax.Hub.Config({
        // Only one of the two following lines, depending on user settings
        // First allows browser-native MathML display, second forces HTML/CSS
        //  config: ["MMLorHTML.js"], jax: ["input/TeX"],
            jax: ["input/TeX", "output/HTML-CSS"],
        extensions: ["tex2jax.js","TeX/AMSmath.js","TeX/AMSsymbols.js",
                     "TeX/noUndefined.js"],
        tex2jax: {
            inlineMath: [ ["\\(","\\)"] ],
            displayMath: [ ['$$','$$'], ["\\[","\\]"], ["\\begin{displaymath}","\\end{displaymath}"] ],
            skipTags: ["script","noscript","style","textarea","pre","code"],
            ignoreClass: "tex2jax_ignore",
            processEscapes: false,
            processEnvironments: true,
            preview: "TeX"
        },
        showProcessingMessages: true,
        displayAlign: "center",
        displayIndent: "2em",

        "HTML-CSS": {
             scale: 100,
             availableFonts: ["STIX","TeX"],
             preferredFont: "TeX",
             webFont: "TeX",
             imageFont: "TeX",
             showMathMenu: true,
        },
        MMLorHTML: {
             prefer: {
                 MSIE:    "MML",
                 Firefox: "MML",
                 Opera:   "HTML",
                 other:   "HTML"
             }
        }
    });
/*]]>*///-->
</script>
</head>
<body>
<div id="content">
<h1 class="title">2016 講義資料</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">1. プログラム関連講義</a>
<ul>
<li><a href="#sec-1-1">1.1. プログラミング関連のサイト</a></li>
</ul>
</li>
<li><a href="#sec-2">2. プログラム言語入門の資料</a></li>
<li><a href="#sec-3">3. プログラミング演習I 実施順</a></li>
<li><a href="#sec-4">4. プログラミング演習I 内容のまとめ</a>
<ul>
<li><a href="#sec-4-1">4.1. プログラミングのはじまり</a></li>
<li><a href="#sec-4-2">4.2. コンピュータとプログラム</a></li>
<li><a href="#sec-4-3">4.3. 名前(変数と関数)</a></li>
<li><a href="#sec-4-4">4.4. 値と式(計算)と型</a></li>
<li><a href="#sec-4-5">4.5. 文と流れの制御 ー 実行順序の制御</a></li>
<li><a href="#sec-4-6">4.6. 関数</a></li>
<li><a href="#sec-4-7">4.7. ポインタ</a></li>
</ul>
</li>
<li><a href="#sec-5">5. プログラムの構成要素</a></li>
<li><a href="#sec-6">6. プログラム言語及び演習II 実施順</a></li>
<li><a href="#sec-7">7. プログラム言語及び演習II 項目順</a>
<ul>
<li><a href="#sec-7-1">7.1. 配列</a></li>
<li><a href="#sec-7-2">7.2. 構造体</a></li>
<li><a href="#sec-7-3">7.3. ポインタ</a></li>
<li><a href="#sec-7-4">7.4. 型の定義</a></li>
<li><a href="#sec-7-5">7.5. ファイル入出力</a></li>
<li><a href="#sec-7-6">7.6. 動的メモリ確保</a></li>
<li><a href="#sec-7-7">7.7. 分割コンパイル</a></li>
<li><a href="#sec-7-8">7.8. make</a></li>
<li><a href="#sec-7-9">7.9. 実践的なデータ処理プログラム</a></li>
</ul>
</li>
<li><a href="#sec-8">8. テストと開発</a></li>
<li><a href="#sec-9">9. テスト駆動開発について</a>
<ul>
<li><a href="#sec-9-1">9.1. 入門サイト</a></li>
<li><a href="#sec-9-2">9.2. やりたいこと</a></li>
</ul>
</li>
<li><a href="#sec-10">10. 開発と機能とテスト</a>
<ul>
<li><a href="#sec-10-1">10.1. 開発と機能</a></li>
<li><a href="#sec-10-2">10.2. 開発とテスト</a></li>
</ul>
</li>
<li><a href="#sec-11">11. 機能とヘッダファイル/ライブラリ</a>
<ul>
<li><a href="#sec-11-1">11.1. 機能を要求する</a></li>
<li><a href="#sec-11-2">11.2. 提供されている機能</a></li>
<li><a href="#sec-11-3">11.3. 機能の説明</a></li>
<li><a href="#sec-11-4">11.4. 機能を使うきまり</a></li>
<li><a href="#sec-11-5">11.5. 機能を利用する側と機能を提供する側とヘッダファイル</a></li>
</ul>
</li>
<li><a href="#sec-12">12. プログラムの機能</a>
<ul>
<li><a href="#sec-12-1">12.1. 基本は関数</a>
<ul>
<li><a href="#sec-12-1-1">関数を呼び出すこと</a></li>
<li><a href="#sec-12-1-2">関数を定めること</a></li>
<li><a href="#sec-12-1-3">関数を呼び出すことと定めることの間にある決まりごと</a></li>
</ul>
</li>
<li><a href="#sec-12-2">12.2. 機能とは</a></li>
<li><a href="#sec-12-3">12.3. 機能を要求する</a></li>
<li><a href="#sec-12-4">12.4. 機能を実現する</a></li>
<li><a href="#sec-12-5">12.5. 機能を提供する</a></li>
<li><a href="#sec-12-6">12.6. 機能を利用する</a></li>
<li><a href="#sec-12-7">12.7. 機能の要求と実現と提供と利用</a></li>
</ul>
</li>
<li><a href="#sec-13">13. ソフトウェアテストを行う目的</a></li>
<li><a href="#sec-14">14. ソフトウェア開発におけるテスト</a>
<ul>
<li><a href="#sec-14-1">14.1. テストとテストケース</a></li>
<li><a href="#sec-14-2">14.2. テストされていないプログラム</a></li>
<li><a href="#sec-14-3">14.3. テストの複雑さ</a></li>
</ul>
</li>
<li><a href="#sec-15">15. ソフトウェアテストの技法や手法</a>
<ul>
<li><a href="#sec-15-1">15.1. ソフトウェアテストの主な分類</a>
<ul>
<li><a href="#sec-15-1-1">テストレベル（開発フェイズ）による分類</a></li>
<li><a href="#sec-15-1-2">テスト設計技法による分類</a>
<ul>
<li><a href="#sec-15-1-2-1">テスト対象となる品質特性による分類</a></li>
<li><a href="#sec-15-1-2-2">テスト実施者、テスト目的による分類</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#sec-15-2">15.2. テストの一般原則</a></li>
</ul>
</li>
<li><a href="#sec-16">16. バイザーのテスト成熟度</a></li>
<li><a href="#sec-17">17. cutter</a></li>
<li><a href="#sec-18">18. テスト・ファイルの作成</a></li>
<li><a href="#sec-19">19. テストのビルド</a>
<ul>
<li><a href="#sec-19-1">19.1. Makefile</a></li>
</ul>
</li>
<li><a href="#sec-20">20. テストのビルドへの補足説明</a>
<ul>
<li><a href="#sec-20-1">20.1. コンパイラへの指示</a>
<ul>
<li><a href="#sec-20-1-1">include パス</a></li>
<li><a href="#sec-20-1-2">ライブラリとライブラリ・パス</a></li>
</ul>
</li>
<li><a href="#sec-20-2">20.2. ヘッダファイルやライブラリファイルの場所</a></li>
<li><a href="#sec-20-3">20.3. オブジェクト・ファイルのこと</a></li>
<li><a href="#sec-20-4">20.4. ライブラリ・ファイルのこと</a></li>
</ul>
</li>
<li><a href="#sec-21">21. テストの実行</a>
<ul>
<li><a href="#sec-21-1">21.1. テスト結果 (成功)</a></li>
<li><a href="#sec-21-2">21.2. テスト結果 (失敗)</a></li>
</ul>
</li>
<li><a href="#sec-22">22. カード表示問題</a>
<ul>
<li><a href="#sec-22-1">22.1. CardDisplay問題</a>
<ul>
<li><a href="#sec-22-1-1">目的</a></li>
<li><a href="#sec-22-1-2">トランプ・カード表示問題</a>
<ul>
<li><a href="#sec-22-1-2-1">card_display_simple 問題</a></li>
<li><a href="#sec-22-1-2-2">card_display_multi 問題</a></li>
<li><a href="#sec-22-1-2-3">card_display_sort 問題</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#sec-22-2">22.2. card_display_simple 問題への解法</a>
<ul>
<li><a href="#sec-22-2-1">card_display_simple 問題</a></li>
<li><a href="#sec-22-2-2">プログラムの設計</a>
<ul>
<li><a href="#sec-22-2-2-1">設計方針</a></li>
<li><a href="#sec-22-2-2-2">card_display_simple の設計</a></li>
<li><a href="#sec-22-2-2-3">入力と出力例と内部トランプ表現</a></li>
<li><a href="#sec-22-2-2-4">スーツ入力文字列からスーツ内部表現へ</a></li>
<li><a href="#sec-22-2-2-5">カードの数から内部表現へ</a></li>
<li><a href="#sec-22-2-2-6">カードを作る</a></li>
<li><a href="#sec-22-2-2-7">カードの内部表現を文字列へ</a></li>
<li><a href="#sec-22-2-2-8">関数の名前</a>
<ul>
<li><a href="#sec-22-2-2-8-1">スーツ入力文字列からスーツ内部表現へ</a></li>
<li><a href="#sec-22-2-2-8-2">カードの数から内部表現へ</a></li>
<li><a href="#sec-22-2-2-8-3">カードを作る</a></li>
<li><a href="#sec-22-2-2-8-4">カードの内部表現を文字列へ</a></li>
</ul>
</li>
<li><a href="#sec-22-2-2-9">関数の引数と戻り値の型 (APIの設計)</a></li>
</ul>
</li>
<li><a href="#sec-22-2-3">card_display_simple 問題のテストによる開発</a>
<ul>
<li><a href="#sec-22-2-3-1">テストによる開発から設計へのフィードバック</a></li>
<li><a href="#sec-22-2-3-2">card_display_simple の解</a></li>
</ul>
</li>
<li><a href="#sec-22-2-4">card_display_sort (準備中@<span class="timestamp-wrapper"><span class="timestamp">&lt;2015-12-01 火&gt;</span></span>)</a>
<ul>
<li><a href="#sec-22-2-4-1">複数のカードをソートする機能</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#sec-22-3">22.3. card_display_multi 問題への解法</a>
<ul>
<li><a href="#sec-22-3-1">card_display_multi</a></li>
</ul>
</li>
<li><a href="#sec-22-4">22.4. card_display_sort 問題への解法</a>
<ul>
<li><a href="#sec-22-4-1">card_display_sort (準備中@<span class="timestamp-wrapper"><span class="timestamp">&lt;2015-12-01 火&gt;</span></span>)</a>
<ul>
<li><a href="#sec-22-4-1-1">複数のカードをソートする機能</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#sec-23">23. カード表示問題_simpleのテストによる開発</a></li>
<li><a href="#sec-24">24. はじめに</a></li>
<li><a href="#sec-25">25. ディレクトリ構成</a></li>
<li><a href="#sec-26">26. Makefileを作る</a></li>
<li><a href="#sec-27">27. 開発を機能に分ける</a></li>
<li><a href="#sec-28">28. 機能のテスト駆動開発 (概論)</a></li>
<li><a href="#sec-29">29. スーツを数値にする機能のテストと実装</a>
<ul>
<li><a href="#sec-29-1">29.1. テスト作成</a></li>
<li><a href="#sec-29-2">29.2. test/Makefileの作成</a></li>
<li><a href="#sec-29-3">29.3. 最初の make</a></li>
<li><a href="#sec-29-4">29.4. cutterによるテスト</a></li>
<li><a href="#sec-29-5">29.5. テストのビルド</a></li>
<li><a href="#sec-29-6">29.6. card_suit_new_from_string の実装</a>
<ul>
<li><a href="#sec-29-6-1">src/card.h の作成 <code>card/card.h</code></a></li>
<li><a href="#sec-29-6-2">test/test_card.cの変更</a></li>
<li><a href="#sec-29-6-3">test/Makefileの変更</a></li>
<li><a href="#sec-29-6-4">src/card.c の作成</a></li>
<li><a href="#sec-29-6-5">src/Makefile</a></li>
<li><a href="#sec-29-6-6">テスト test/test_card.so のビルド</a></li>
</ul>
</li>
<li><a href="#sec-29-7">29.7. テスト</a></li>
<li><a href="#sec-29-8">29.8. テストと再設計</a></li>
</ul>
</li>
<li><a href="#sec-30">30. トランプ番号を数値に</a>
<ul>
<li><a href="#sec-30-1">30.1. トランプ番号を数値に</a>
<ul>
<li><a href="#sec-30-1-1">機能とテストの追加</a>
<ul>
<li><a href="#sec-30-1-1-1">test/Makefileの更新</a></li>
<li><a href="#sec-30-1-1-2">test/test_card.o の更新</a></li>
<li><a href="#sec-30-1-1-3">テスト (test/test_card.so) のビルド</a></li>
</ul>
</li>
<li><a href="#sec-30-1-2">card_no_new_from_string の実装</a>
<ul>
<li><a href="#sec-30-1-2-1">src/card.h の更新</a></li>
<li><a href="#sec-30-1-2-2">test/test_card.cの変更</a></li>
<li><a href="#sec-30-1-2-3">card_no_new_from_string の実装 (src/card.c の更新)</a></li>
<li><a href="#sec-30-1-2-4">src/Makefile</a></li>
<li><a href="#sec-30-1-2-5">テスト test/test_card.so の再ビルド</a></li>
</ul>
</li>
<li><a href="#sec-30-1-3">テスト</a>
<ul>
<li><a href="#sec-30-1-3-1">テストと再設計</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#sec-31">31. トランプ・カードを作成</a>
<ul>
<li><a href="#sec-31-1">31.1. 機能の追加とテストの作成</a>
<ul>
<li><a href="#sec-31-1-1">card_new のテストを書く</a></li>
<li><a href="#sec-31-1-2">card_new, card_suit, card_no のインタフェースを決める</a></li>
<li><a href="#sec-31-1-3">Card型を定義する</a></li>
<li><a href="#sec-31-1-4">テスト全体プログラムの確認</a></li>
<li><a href="#sec-31-1-5">test/Makefile の確認</a></li>
<li><a href="#sec-31-1-6">test/test_card.o の作成</a></li>
</ul>
</li>
<li><a href="#sec-31-2">31.2. card_new の実装</a>
<ul>
<li><a href="#sec-31-2-1">card/card.h の更新</a></li>
<li><a href="#sec-31-2-2">card_new の実装 (src/card.cの更新)</a></li>
<li><a href="#sec-31-2-3">card_suit の実装 (src/card.cの更新)</a></li>
<li><a href="#sec-31-2-4">card_no の実装 (src/card.cの更新)</a></li>
<li><a href="#sec-31-2-5">src/card.c 全体</a></li>
<li><a href="#sec-31-2-6">src/Makefile</a></li>
<li><a href="#sec-31-2-7">src/card.o の作成</a></li>
<li><a href="#sec-31-2-8">src/libcard.a の作成</a></li>
</ul>
</li>
<li><a href="#sec-31-3">31.3. テスト</a>
<ul>
<li><a href="#sec-31-3-1">test/test_card.so のビルド</a></li>
<li><a href="#sec-31-3-2">テストの実行</a></li>
<li><a href="#sec-31-3-3">テストと再設計</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#sec-32">32. トランプ・カードを文字列に</a>
<ul>
<li><a href="#sec-32-1">32.1. 設計</a>
<ul>
<li><a href="#sec-32-1-1">機能の名前と構造</a></li>
<li><a href="#sec-32-1-2">関数の引数と戻り値の型 (APIの設計)</a></li>
</ul>
</li>
<li><a href="#sec-32-2">32.2. テストによる開発</a></li>
</ul>
</li>
<li><a href="#sec-33">33. トランプ・カードを文字列に</a>
<ul>
<li><a href="#sec-33-1">33.1. 機能の追加とテストの作成</a>
<ul>
<li><a href="#sec-33-1-1">card_to_string のテストを書く</a></li>
<li><a href="#sec-33-1-2">card_to_string のインタフェースを決める</a></li>
<li><a href="#sec-33-1-3">テスト全体プログラムの確認</a></li>
<li><a href="#sec-33-1-4">test/Makefile の確認</a></li>
<li><a href="#sec-33-1-5">test/test_card.o の作成</a></li>
</ul>
</li>
<li><a href="#sec-33-2">33.2. card_to_string の実装</a>
<ul>
<li><a href="#sec-33-2-1">card/card.h の更新</a></li>
<li><a href="#sec-33-2-2">card_to_string の実装 (src/card.cの更新)</a></li>
<li><a href="#sec-33-2-3">src/card.c 全体</a></li>
<li><a href="#sec-33-2-4">src/Makefile</a></li>
<li><a href="#sec-33-2-5">src/card.o の作成</a></li>
<li><a href="#sec-33-2-6">src/libcard.a の作成</a></li>
</ul>
</li>
<li><a href="#sec-33-3">33.3. テスト</a>
<ul>
<li><a href="#sec-33-3-1">test/test_card.so のビルド</a></li>
<li><a href="#sec-33-3-2">テストの実行</a></li>
<li><a href="#sec-33-3-3">テストと再設計</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#sec-34">34. card_display_simple 問題の解の作成</a></li>
<li><a href="#sec-35">35. card_display_multi</a></li>
<li><a href="#sec-36">36. card_display_sort</a>
<ul>
<li><a href="#sec-36-1">36.1. Doing checks <code>[1/3]</code></a></li>
<li><a href="#sec-36-2">36.2. 複数のカードをソートする機能</a></li>
<li><a href="#sec-36-3">36.3. 機能の追加とテストの作成</a>
<ul>
<li><a href="#sec-36-3-1">cards_sort のテストを書く</a></li>
<li><a href="#sec-36-3-2">テスト全体プログラムの確認</a></li>
<li><a href="#sec-36-3-3">test/Makefile の確認</a></li>
<li><a href="#sec-36-3-4">test/test_sort.o の作成</a></li>
</ul>
</li>
<li><a href="#sec-36-4">36.4. cards_sort，card_compare の実装</a>
<ul>
<li><a href="#sec-36-4-1">card/card.h の更新</a></li>
<li><a href="#sec-36-4-2">cards_sort の実装 (src/cards.cの作成)</a></li>
<li><a href="#sec-36-4-3">card_compare の実装</a></li>
<li><a href="#sec-36-4-4">cards.c の確認</a></li>
<li><a href="#sec-36-4-5">src/Makefile</a></li>
<li><a href="#sec-36-4-6">src/cards.o の作成</a></li>
<li><a href="#sec-36-4-7">src/libcard.a の作成</a></li>
</ul>
</li>
<li><a href="#sec-36-5">36.5. テスト</a>
<ul>
<li><a href="#sec-36-5-1">test/test_sort.so のビルド</a></li>
<li><a href="#sec-36-5-2">テストの実行</a></li>
<li><a href="#sec-36-5-3">テストと再設計</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#sec-37">37. モジュール開発によるポーカーゲームの作成</a>
<ul>
<li><a href="#sec-37-1">37.1. Pokerゲーム開発の始まり</a>
<ul>
<li><a href="#sec-37-1-1">はじまり</a>
<ul>
<li><a href="#sec-37-1-1-1">Done ポーカーゲーム作りの始まり</a>
<ul>
<li><a href="#sec-37-1-1-1-1">カードモジュールつくってよ (@カードモジュールつくってよ)</a></li>
<li><a href="#sec-37-1-1-1-2">講義で考えているポーカーゲーム</a></li>
<li><a href="#sec-37-1-1-1-3">ゲーム説明とモジュールわけ</a></li>
<li><a href="#sec-37-1-1-1-4">ゲーム説明の分析 (課題)</a></li>
<li><a href="#sec-37-1-1-1-5">モジュール分け</a></li>
</ul>
</li>
<li><a href="#sec-37-1-1-2">テストの意味</a>
<ul>
<li><a href="#sec-37-1-1-2-1">「まずテストを書く」こと</a></li>
<li><a href="#sec-37-1-1-2-2">フィードバック</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#sec-37-2">37.2. Card モジュールの開発</a>
<ul>
<li><a href="#sec-37-2-1">Cardモジュール</a></li>
</ul>
</li>
<li><a href="#sec-37-3">37.3. Deck モジュールの開発</a>
<ul>
<li><a href="#sec-37-3-1">山について考える</a>
<ul>
<li><a href="#sec-37-3-1-1">山の機能</a>
<ul>
<li><a href="#sec-37-3-1-1-1">ゲームの説明から山に関する部分を取り出す</a></li>
<li><a href="#sec-37-3-1-1-2">山モジュールの機能</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#sec-37-3-2">テスト駆動開発の一サイクルのテンプレート</a>
<ul>
<li><a href="#sec-37-3-2-1">機能の設計</a>
<ul>
<li><a href="#sec-37-3-2-1-1">インタフェースの設計</a>
<ul>
<li><a href="#sec-37-3-2-1-1-1">インタフェースを考える</a></li>
<li><a href="#sec-37-3-2-1-1-2">テスト test_&#x2026; () を書く</a></li>
<li><a href="#sec-37-3-2-1-1-3">test/test_deck.o を作る (test/Makefile)</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#sec-37-3-2-2">機能の実装</a>
<ul>
<li><a href="#sec-37-3-2-2-1">deck_new，deck_size の実装</a>
<ul>
<li><a href="#sec-37-3-2-2-1-1">インタフェースの確定 (src/deck.h)</a></li>
<li><a href="#sec-37-3-2-2-1-2">Deck を作る (src/deck.c)</a></li>
<li><a href="#sec-37-3-2-2-1-3">deck_new と deck_size を作る (src/deck.c)</a></li>
<li><a href="#sec-37-3-2-2-1-4">deck_new.o, deck_size.o を作る (src/Makefile)</a></li>
<li><a href="#sec-37-3-2-2-1-5">libdeck.a を作る (src/Makefile)</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#sec-37-3-2-3">機能テスト</a>
<ul>
<li><a href="#sec-37-3-2-3-1">テスト</a>
<ul>
<li><a href="#sec-37-3-2-3-1-1">テスト test_deck.so のビルド</a></li>
<li><a href="#sec-37-3-2-3-1-2">テストの実行とデバッグ</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#sec-37-3-3">山のテスト駆動開発</a>
<ul>
<li><a href="#sec-37-3-3-1">開発ディレクトリ</a></li>
<li><a href="#sec-37-3-3-2">開発リポジトリ</a></li>
<li><a href="#sec-37-3-3-3">card モジュールを利用するための決まり</a></li>
<li><a href="#sec-37-3-3-4">山 (Deck) の機能の設計・実装・テスト</a>
<ul>
<li><a href="#sec-37-3-3-4-1">インタフェースの設計</a>
<ul>
<li><a href="#sec-37-3-3-4-1-1">インタフェースを考える</a></li>
</ul>
</li>
<li><a href="#sec-37-3-3-4-2">テスト test_deck_new() を書く</a>
<ul>
<li><a href="#sec-37-3-3-4-2-1">test/test_deck.o を作る</a></li>
</ul>
</li>
<li><a href="#sec-37-3-3-4-3">deck_new，deck_size の実装</a>
<ul>
<li><a href="#sec-37-3-3-4-3-1">インタフェースの確定 (src/deck.h)</a></li>
<li><a href="#sec-37-3-3-4-3-2">Deck を作る (src/deck.c)</a></li>
<li><a href="#sec-37-3-3-4-3-3">Todo new と size を作る (src/deck.c)</a></li>
<li><a href="#sec-37-3-3-4-3-4">Todo deck.o を作る (src/deck.o)</a>
<ul>
<li><a href="#sec-37-3-3-4-3-4-1">Todo deck/src/Makefile の変更</a></li>
</ul>
</li>
<li><a href="#sec-37-3-3-4-3-5">Todo libdeck.a を作る</a></li>
</ul>
</li>
<li><a href="#sec-37-3-3-4-4">Todo テスト</a>
<ul>
<li><a href="#sec-37-3-3-4-4-1">Todo テスト test_deck.so のビルド</a></li>
<li><a href="#sec-37-3-3-4-4-2">Todo テストの実行とデバッグ</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#sec-37-3-3-5">Todo 山から引く機能の設計・実装・テスト</a>
<ul>
<li>
<ul>
<li><a href="#sec-37-3-3-5-0-1">インタフェースの設計</a></li>
<li><a href="#sec-37-3-3-5-0-2">テスト</a></li>
</ul>
</li>
<li><a href="#sec-37-3-3-5-1">deck_draw をテストする:</a></li>
<li><a href="#sec-37-3-3-5-2">deck.h への追加変更</a></li>
<li><a href="#sec-37-3-3-5-3">deck.c への追加変更</a></li>
<li><a href="#sec-37-3-3-5-4">deck.o の作成</a></li>
<li><a href="#sec-37-3-3-5-5">libdeck.a の作成</a></li>
<li><a href="#sec-37-3-3-5-6">test_deck.so の作成</a></li>
<li><a href="#sec-37-3-3-5-7">test</a></li>
</ul>
</li>
<li><a href="#sec-37-3-3-6">Todo カードを捨てる (test_deck.c#test_discard)</a></li>
<li><a href="#sec-37-3-3-7">Todo 山の再構成 (deck_renew)</a>
<ul>
<li><a href="#sec-37-3-3-7-1">機能</a></li>
<li><a href="#sec-37-3-3-7-2">テストする</a></li>
<li><a href="#sec-37-3-3-7-3">renewの実装 (src/deck.c#renew)</a></li>
<li><a href="#sec-37-3-3-7-4">deck.o の作成</a></li>
<li><a href="#sec-37-3-3-7-5">libdeck.a の作成</a></li>
<li><a href="#sec-37-3-3-7-6">test_deck.so の作成</a></li>
<li><a href="#sec-37-3-3-7-7">test</a></li>
</ul>
</li>
<li><a href="#sec-37-3-3-8">Todo シャッフル</a></li>
<li><a href="#sec-37-3-3-9">山を印刷</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#sec-37-4">37.4. Hand モジュールの開発</a>
<ul>
<li><a href="#sec-37-4-1">手札について考える</a>
<ul>
<li><a href="#sec-37-4-1-1">手札の機能</a>
<ul>
<li><a href="#sec-37-4-1-1-1">ゲームの説明から手札に関する部分を取り出す</a></li>
<li><a href="#sec-37-4-1-1-2">手札モジュールの機能</a></li>
</ul>
</li>
<li><a href="#sec-37-4-1-2">機能の設計</a>
<ul>
<li><a href="#sec-37-4-1-2-1">機能の名前</a>
<ul>
<li><a href="#sec-37-4-1-2-1-1">手札を作ることに関する機能達</a></li>
<li><a href="#sec-37-4-1-2-1-2">手札に一枚加える/引く機能達</a></li>
<li><a href="#sec-37-4-1-2-1-3">手札の全カードを扱う機能達</a></li>
<li><a href="#sec-37-4-1-2-1-4">役に関する機能達</a></li>
</ul>
</li>
<li><a href="#sec-37-4-1-2-2">インタフェースを考える (deckと同じ)</a></li>
<li><a href="#sec-37-4-1-2-3">機能のインタフェース</a>
<ul>
<li><a href="#sec-37-4-1-2-3-1">手札</a></li>
<li><a href="#sec-37-4-1-2-3-2">hand_new</a></li>
<li><a href="#sec-37-4-1-2-3-3">hand_size</a></li>
<li><a href="#sec-37-4-1-2-3-4">hand_add</a></li>
<li><a href="#sec-37-4-1-2-3-5">hand_draw</a></li>
<li><a href="#sec-37-4-1-2-3-6">hand_sort</a></li>
<li><a href="#sec-37-4-1-2-3-7">hand_to_string</a></li>
<li><a href="#sec-37-4-1-2-3-8">hand_calc</a></li>
<li><a href="#sec-37-4-1-2-3-9">PokerHand (物)</a></li>
<li><a href="#sec-37-4-1-2-3-10">poker_hand_to_string</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#sec-37-4-2">開発の決まり (deckとほぼ同じ)</a>
<ul>
<li><a href="#sec-37-4-2-1">開発ディレクトリ</a></li>
<li><a href="#sec-37-4-2-2">開発リポジトリ</a></li>
<li><a href="#sec-37-4-2-3">他のモジュールを利用するための決まり</a></li>
<li><a href="#sec-37-4-2-4">Makefileの準備</a></li>
<li><a href="#sec-37-4-2-5">テスト駆動開発の一サイクルのテンプレート</a></li>
</ul>
</li>
<li><a href="#sec-37-4-3">手札のテスト駆動開発</a></li>
<li><a href="#sec-37-4-4">作成された手札モジュールの解説</a></li>
<li><a href="#sec-37-4-5">src/hand.h</a>
<ul>
<li><a href="#sec-37-4-5-1">一回だけしか，include できなくする</a></li>
<li><a href="#sec-37-4-5-2">依存するモジュールのインタフェースを読む</a></li>
<li><a href="#sec-37-4-5-3">hand 型の定義</a></li>
<li><a href="#sec-37-4-5-4">手札の作成と状態を知る機能</a></li>
<li><a href="#sec-37-4-5-5">手札の出し入れ</a></li>
<li><a href="#sec-37-4-5-6">ソート</a></li>
<li><a href="#sec-37-4-5-7">手札の表示（用文字列の生成）</a></li>
<li><a href="#sec-37-4-5-8">役に関する定義</a></li>
</ul>
</li>
<li><a href="#sec-37-4-6">test_hand.c</a>
<ul>
<li><a href="#sec-37-4-6-1">test_hand header</a></li>
<li><a href="#sec-37-4-6-2">手札の生成のテスト</a></li>
<li><a href="#sec-37-4-6-3">手札へのカードの追加</a></li>
<li><a href="#sec-37-4-6-4">手札の no 番目のカードのテスト</a></li>
<li><a href="#sec-37-4-6-5">手札から1枚引く</a></li>
<li><a href="#sec-37-4-6-6">手札のソート</a></li>
<li><a href="#sec-37-4-6-7">手札の文字列化のテスト</a></li>
</ul>
</li>
<li><a href="#sec-37-4-7">hand/src/hand.c</a>
<ul>
<li><a href="#sec-37-4-7-1">Cの標準ラブラリを使う</a></li>
<li><a href="#sec-37-4-7-2">hand のインタフェースを遵守</a></li>
<li><a href="#sec-37-4-7-3">hand_new, hand_size</a></li>
<li><a href="#sec-37-4-7-4">hand_add</a></li>
<li><a href="#sec-37-4-7-5">hand_card</a></li>
<li><a href="#sec-37-4-7-6">hand_draw</a></li>
<li><a href="#sec-37-4-7-7">文字列化</a></li>
<li><a href="#sec-37-4-7-8">hand_sort</a></li>
</ul>
</li>
<li><a href="#sec-37-4-8">test/test_judge.c</a>
<ul>
<li><a href="#sec-37-4-8-1">必要なライブラリのヘッ</a></li>
</ul>
</li>
<li><a href="#sec-37-4-9">hand/src/judge.c</a>
<ul>
<li><a href="#sec-37-4-9-1">必要なシステムライブラリのインタフェースを読む (定跡)</a></li>
<li><a href="#sec-37-4-9-2">依存するモジュールのインタフェースを読む(定跡)</a></li>
<li><a href="#sec-37-4-9-3">定数の宣言 (定跡)</a></li>
<li><a href="#sec-37-4-9-4">このファイル内でのみ有効な関数の宣言 (定跡)</a></li>
<li><a href="#sec-37-4-9-5">役の計算</a></li>
</ul>
</li>
<li><a href="#sec-37-4-10">hand/test/hand_test.h</a></li>
<li><a href="#sec-37-4-11">hand/test/hand_test_data.c</a>
<ul>
<li><a href="#sec-37-4-11-1">利用ライブライのヘッダを読む</a></li>
<li><a href="#sec-37-4-11-2">利用モジュールのヘッダを読む</a></li>
<li><a href="#sec-37-4-11-3">手札テストデータ操作用ヘッダを読む</a></li>
<li><a href="#sec-37-4-11-4">5枚のカードの組のデータ定義</a></li>
<li><a href="#sec-37-4-11-5">テストデータの初期化</a></li>
<li><a href="#sec-37-4-11-6">テストデータから Hand型データを生成する機能</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#sec-37-5">37.5. Pokerモジュールの開発</a>
<ul>
<li><a href="#sec-37-5-1">ゲームモジュール</a>
<ul>
<li><a href="#sec-37-5-1-1">機能、設計，実装</a>
<ul>
<li><a href="#sec-37-5-1-1-1">ゲームの説明からゲームに関する部分を取り出す</a></li>
<li><a href="#sec-37-5-1-1-2">poker モジュールの機能</a></li>
<li><a href="#sec-37-5-1-1-3">poker モジュールの機能の名前</a></li>
<li><a href="#sec-37-5-1-1-4">poker モジュールの機能のインタフェース</a></li>
</ul>
</li>
<li><a href="#sec-37-5-1-2">~/progs/game/poker が開発ディレクトリ</a></li>
<li><a href="#sec-37-5-1-3">~/progs/game/Makefile</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>
<p>
<a href="./">ホーム</a> /
<a href="./lects.html">講義</a> / 
<a href="./supplement.html">説明</a> / 
<a href="./org-docs.html">資料</a> / 
<a href="./memos.html">雑メモ</a> /
<a href="http://wiki.cis.iwate-u.ac.jp/~suzuki/lects/prog/">2015</a>
</p>
<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1"><span class="section-number-2">1</span> <a href="./cis-programming-lects/">プログラム関連講義</a></h2>
<div class="outline-text-2" id="text-1">
</div><div id="outline-container-sec-1-1" class="outline-3">
<h3 id="sec-1-1"><span class="section-number-3">1.1</span> プログラミング関連のサイト</h3>
<div class="outline-text-3" id="text-1-1">
<ol class="org-ol">
<li><a href="http://www.kono.cis.iwate-u.ac.jp/~hirayama/local/jkiso/index.html">情報基礎</a>
</li>

<li><a href="http://www.kono.cis.iwate-u.ac.jp/~hirayama/local/pnyumon/index.html">プログラム言語入門</a>
</li>

<li><a href="http://wiki.cis.iwate-u.ac.jp/~cis/prog1/pukiwiki/">プログラム言語及び演習１</a>
</li>

<li><a href="http://wiki.cis.iwate-u.ac.jp/~cis/prog2/pukiwiki/">プログラム言語及び演習２</a>
</li>

<li><a href="http://wiki.cis.iwate-u.ac.jp/~suzuki/lects/prog/">ソフトウェア構成論</a> ((<a href="file:///home/staff/suzuki/lects/prog/site/index.html">cis-org</a> <a href="file:///home/staff/suzuki/COMM/Lects/prog/site/index.html">s-org</a>))
</li>
</ol>
</div>
</div>
</div>

<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2"><span class="section-number-2">2</span> プログラム言語入門の資料</h2>
<div class="outline-text-2" id="text-2">
<p>
平成26年度 教材と今後の授業予定
</p>
<ul class="org-ul">
<li>第1回 <a href="http://www.kono.cis.iwate-u.ac.jp/~hirayama/local/pnyumon/2014/note-01.pdf">Emacsの復習</a>
</li>
<li>第2回 <a href="http://www.kono.cis.iwate-u.ac.jp/~hirayama/local/pnyumon/2014/note-02.pdf">Mewの復習と発展</a>
</li>
<li>第3回 <a href="http://www.kono.cis.iwate-u.ac.jp/~hirayama/local/pnyumon/2014/note-03.pdf">Emacsの発展</a>
</li>
<li>第4回 <a href="http://www.kono.cis.iwate-u.ac.jp/~hirayama/local/pnyumon/2014/note-04.pdf">コマンドの復習</a>
</li>
<li>第5回 <a href="http://www.kono.cis.iwate-u.ac.jp/~hirayama/local/pnyumon/2014/note-05.pdf">コマンドの発展</a>
</li>
<li>第6回 <a href="http://www.kono.cis.iwate-u.ac.jp/~hirayama/local/pnyumon/2014/note-06.pdf">正規表現の基礎</a>
</li>
<li>第7回 <a href="http://www.kono.cis.iwate-u.ac.jp/~hirayama/local/pnyumon/2014/note-07.pdf">制御構文とシェルスクリプトの基礎</a>
</li>
<li>第e回 <a href="http://www.kono.cis.iwate-u.ac.jp/~hirayama/local/pnyumon/2014/note-14.pdf">Processing 6 (オブジェクト指向プログラミングの入り口)</a>
</li>
</ul>

<p>
疑問質問は<a href="http://wiki.eecs.iwate-u.ac.jp/~lect/jkiso/hiki.cgi">Wikiページ</a>にどうぞ。
</p>
</div>
</div>
<div id="outline-container-sec-3" class="outline-2">
<h2 id="sec-3"><span class="section-number-2">3</span> プログラミング演習I 実施順</h2>
<div class="outline-text-2" id="text-3">
<ul class="org-ul">
<li><a href="http://wiki.cis.iwate-u.ac.jp/~cis/prog1/pukiwiki/index.php?%E7%AC%AC1%E5%9B%9E">第1回</a> &#x2013; 作業ディレクトリの作成，カレントディレクトリを移動する，ソー
スファイルの作成，プログラミングの流れ，Emacsの使い方，コンパイルと実行
<ul class="org-ul">
<li>emacs::エラー箇所を表示
</li>
<li>emacs::c言語モード
</li>
</ul>
</li>
<li><a href="http://wiki.cis.iwate-u.ac.jp/~cis/prog1/pukiwiki/index.php?%E7%AC%AC2%E5%9B%9E">第2回</a> &#x2013; コンピュータの仕組み，コンピュータの5大機能，プログラムがで
きるまで（用語の意味），プログラムの基本事項 (include，main，return)，
printf関数，エスケープシーケンス
</li>
<li><a href="http://wiki.cis.iwate-u.ac.jp/~cis/prog1/pukiwiki/index.php?%E7%AC%AC3%E5%9B%9E">第3回</a> &#x2013; 3.1 変数とは，3.2 データ型，3.3 変数の宣言，3.4 変数の値の表
</li>
<li><a href="http://wiki.cis.iwate-u.ac.jp/~cis/prog1/pukiwiki/index.php?%E7%AC%AC4%E5%9B%9E">第4回</a> &#x2013; フローチャートの書き方，4.1 式と演算子，4.2 データ型と計算，
4.3 各種演算子，4.4 インクリメント・デクリメント演算子
</li>
<li><a href="http://wiki.cis.iwate-u.ac.jp/~cis/prog1/pukiwiki/index.php?%E7%AC%AC5%E5%9B%9E">第5回</a> &#x2013; 4.5 sizeof演算子，4.6 不等号演算子，4.7 等価演算子と非等価
演算子，4.8 代入演算子，4.9 キャスト演算子
</li>
<li><a href="http://wiki.cis.iwate-u.ac.jp/~cis/prog1/pukiwiki/index.php?%E7%AC%AC6%E5%9B%9E">第6回</a> &#x2013; 4.10 ビット演算子，4.11 条件演算子，5.1 if文
</li>
<li><a href="http://wiki.cis.iwate-u.ac.jp/~cis/prog1/pukiwiki/index.php?%E7%AC%AC7%E5%9B%9E">第7回</a> &#x2013; 5.2 関係演算子と論理演算子，5.3 switch文，5.4 for文
</li>
<li><a href="http://wiki.cis.iwate-u.ac.jp/~cis/prog1/pukiwiki/index.php?%E7%AC%AC8%E5%9B%9E">第8回</a> &#x2013; 5.5 while文
</li>
<li><a href="http://wiki.cis.iwate-u.ac.jp/~cis/prog1/pukiwiki/index.php?%E7%AC%AC9%E5%9B%9E">第9回</a> &#x2013; 5.6 do～while文，5.7 break文とcontinue文，5.8 goto文
</li>
<li><a href="http://wiki.cis.iwate-u.ac.jp/~cis/prog1/pukiwiki/index.php?%E7%AC%AC10%E5%9B%9E">第a回</a> &#x2013; 6.1 関数の基本，6.2 引数と戻り値
</li>
<li><a href="http://wiki.cis.iwate-u.ac.jp/~cis/prog1/pukiwiki/index.php?%E7%AC%AC11%E5%9B%9E">第b回</a> &#x2013; 6.3 変数の寿命とスコープ，6.4 再帰呼び出し
</li>
<li><a href="http://wiki.cis.iwate-u.ac.jp/~cis/prog1/pukiwiki/index.php?%E7%AC%AC12%E5%9B%9E">第c回</a> &#x2013; 7.1 メモリのアドレス，7.2 ポインタの基本，7.3 ポインタへの
値代入，7.4 ポインタと引数，7.5 ポインタのポインタ
</li>
</ul>

<p>
<a href="http://wiki.cis.iwate-u.ac.jp/~cis/prog1/pukiwiki/index.php?plugin=attach&pcmd=list">添付ファイル一覧</a>
</p>
</div>
</div>


<div id="outline-container-sec-4" class="outline-2">
<h2 id="sec-4"><span class="section-number-2">4</span> プログラミング演習I 内容のまとめ</h2>
<div class="outline-text-2" id="text-4">
</div><div id="outline-container-sec-4-1" class="outline-3">
<h3 id="sec-4-1"><span class="section-number-3">4.1</span> プログラミングのはじまり</h3>
<div class="outline-text-3" id="text-4-1">
<ul class="org-ul">
<li><a href="http://wiki.cis.iwate-u.ac.jp/~cis/prog1/pukiwiki/index.php?%E7%AC%AC1%E5%9B%9E">第1回</a> &#x2013; 作業ディレクトリの作成，カレントディレクトリを移動する，ソー
スファイルの作成，プログラミングの流れ，Emacsの使い方，コンパイルと実行
<ul class="org-ul">
<li>emacs::エラー箇所を表示
</li>
<li>emacs::c言語モード
</li>
</ul>
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-4-2" class="outline-3">
<h3 id="sec-4-2"><span class="section-number-3">4.2</span> コンピュータとプログラム</h3>
<div class="outline-text-3" id="text-4-2">
<ul class="org-ul">
<li><a href="http://wiki.cis.iwate-u.ac.jp/~cis/prog1/pukiwiki/index.php?%E7%AC%AC2%E5%9B%9E">第2回</a> &#x2013; コンピュータの仕組み，コンピュータの5大機能，プログラムがで
きるまで（用語の意味），プログラムの基本事項 (include，main，return)，
printf関数，エスケープシーケンス
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-4-3" class="outline-3">
<h3 id="sec-4-3"><span class="section-number-3">4.3</span> 名前(変数と関数)</h3>
<div class="outline-text-3" id="text-4-3">
<ul class="org-ul">
<li><a href="http://wiki.cis.iwate-u.ac.jp/~cis/prog1/pukiwiki/index.php?%E7%AC%AC3%E5%9B%9E">第3回</a> &#x2013; 3.1 変数とは，3.2 データ型，3.3 変数の宣言，3.4 変数の値の表
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-4-4" class="outline-3">
<h3 id="sec-4-4"><span class="section-number-3">4.4</span> 値と式(計算)と型</h3>
<div class="outline-text-3" id="text-4-4">
<ul class="org-ul">
<li><a href="http://wiki.cis.iwate-u.ac.jp/~cis/prog1/pukiwiki/index.php?%E7%AC%AC4%E5%9B%9E">第4回</a> &#x2013; フローチャートの書き方，4.1 式と演算子，4.2 データ型と計算，
4.3 各種演算子，4.4 インクリメント・デクリメント演算子
</li>
<li><a href="http://wiki.cis.iwate-u.ac.jp/~cis/prog1/pukiwiki/index.php?%E7%AC%AC5%E5%9B%9E">第5回</a> &#x2013; 4.5 sizeof演算子，4.6 不等号演算子，4.7 等価演算子と非等価
演算子，4.8 代入演算子，4.9 キャスト演算子
</li>
<li><a href="http://wiki.cis.iwate-u.ac.jp/~cis/prog1/pukiwiki/index.php?%E7%AC%AC6%E5%9B%9E">第6回</a> &#x2013; 4.10 ビット演算子，4.11 条件演算子，5.1 if文
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-4-5" class="outline-3">
<h3 id="sec-4-5"><span class="section-number-3">4.5</span> 文と流れの制御 ー 実行順序の制御</h3>
<div class="outline-text-3" id="text-4-5">
<ul class="org-ul">
<li><a href="http://wiki.cis.iwate-u.ac.jp/~cis/prog1/pukiwiki/index.php?%E7%AC%AC7%E5%9B%9E">第7回</a> &#x2013; 5.2 関係演算子と論理演算子，5.3 switch文，5.4 for文
</li>
<li><a href="http://wiki.cis.iwate-u.ac.jp/~cis/prog1/pukiwiki/index.php?%E7%AC%AC8%E5%9B%9E">第8回</a> &#x2013; 5.5 while文
</li>
<li><a href="http://wiki.cis.iwate-u.ac.jp/~cis/prog1/pukiwiki/index.php?%E7%AC%AC9%E5%9B%9E">第9回</a> &#x2013; 5.6 do～while文，5.7 break文とcontinue文，5.8 goto文
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-4-6" class="outline-3">
<h3 id="sec-4-6"><span class="section-number-3">4.6</span> 関数</h3>
<div class="outline-text-3" id="text-4-6">
<ul class="org-ul">
<li><a href="http://wiki.cis.iwate-u.ac.jp/~cis/prog1/pukiwiki/index.php?%E7%AC%AC10%E5%9B%9E">第a回</a> &#x2013; 6.1 関数の基本，6.2 引数と戻り値
<ul class="org-ul">
<li>プロトタイプ宣言
</li>
</ul>
</li>

<li><a href="http://wiki.cis.iwate-u.ac.jp/~cis/prog1/pukiwiki/index.php?%E7%AC%AC11%E5%9B%9E">第b回</a> &#x2013; 6.3 変数の寿命とスコープ，6.4 再帰呼び出し
<ul class="org-ul">
<li>ローカル, グローバル
</li>
<li>extern
</li>
<li>ブロック { &#x2026; }
</li>
</ul>
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-4-7" class="outline-3">
<h3 id="sec-4-7"><span class="section-number-3">4.7</span> ポインタ</h3>
<div class="outline-text-3" id="text-4-7">
<ul class="org-ul">
<li><a href="http://wiki.cis.iwate-u.ac.jp/~cis/prog1/pukiwiki/index.php?%E7%AC%AC12%E5%9B%9E">第c回</a> &#x2013; 7.1 メモリのアドレス，7.2 ポインタの基本，7.3 ポインタへの
値代入，7.4 ポインタと引数，7.5 ポインタのポインタ
</li>
</ul>

<p>
<a href="http://wiki.cis.iwate-u.ac.jp/~cis/prog1/pukiwiki/index.php?plugin=attach&pcmd=list">添付ファイル一覧</a>
</p>
</div>
</div>
</div>


<div id="outline-container-sec-5" class="outline-2">
<h2 id="sec-5"><span class="section-number-2">5</span> プログラムの構成要素</h2>
<div class="outline-text-2" id="text-5">
<ul class="org-ul">
<li>型と値
</li>
<li>式 (値の計算)
</li>
<li>変数 (値の記憶)
</li>
<li>文 (実行順序の制御)
</li>
<li><b>関数</b> (文のまとめ)
</li>
<li><b>名前</b> (変数と関数) のスコープ
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-6" class="outline-2">
<h2 id="sec-6"><span class="section-number-2">6</span> プログラム言語及び演習II 実施順</h2>
<div class="outline-text-2" id="text-6">
<ul class="org-ul">
<li><a href="http://wiki.cis.iwate-u.ac.jp/~cis/prog2/pukiwiki/index.php?1%E5%9B%9E%E7%9B%AE">1回目</a> &#x2013; 7 ポインタ
</li>
<li><a href="http://wiki.cis.iwate-u.ac.jp/~cis/prog2/pukiwiki/index.php?2%E5%9B%9E%E7%9B%AE">2回目</a> &#x2013; 8.1 配列の基本，8.2 配列とアドレス, 8.3 多次元配列
</li>
<li><a href="http://wiki.cis.iwate-u.ac.jp/~cis/prog2/pukiwiki/index.php?3%E5%9B%9E%E7%9B%AE">3回目</a> &#x2013; 8.4 文字と文字列，8.5 文字配列，8.6 文字の入力
</li>
<li><a href="http://wiki.cis.iwate-u.ac.jp/~cis/prog2/pukiwiki/index.php?4%E5%9B%9E%E7%9B%AE">4回目</a> &#x2013; 8.6 文字の入力, 8.7 文字列の加工, 8.8 文字列ポインタを配列
にする，8.9 コマンド・ライン引数，
</li>
<li><a href="http://wiki.cis.iwate-u.ac.jp/~cis/prog2/pukiwiki/index.php?5%E5%9B%9E%E7%9B%AE">5回目</a> &#x2013; 8.10 関数に配列を渡す，9.1 構造体の宣言，9.2 構造体メンバ
へのアクセス方法，9.3 構造体の配列
</li>
<li><a href="http://wiki.cis.iwate-u.ac.jp/~cis/prog2/pukiwiki/index.php?6%E5%9B%9E%E7%9B%AE">6回目</a> &#x2013; ポインタの復習
</li>
<li><a href="http://wiki.cis.iwate-u.ac.jp/~cis/prog2/pukiwiki/index.php?7%E5%9B%9E%E7%9B%AE">7回目</a> &#x2013; 9.4 構造体へのポインタ, 9.5 新しい型を定義する，9.6 メンバ
に同じ型へのポインタを持つ構造体, 9.7 共用体
</li>
<li><a href="http://wiki.cis.iwate-u.ac.jp/~cis/prog2/pukiwiki/index.php?8%E5%9B%9E%E7%9B%AE">8回目</a> &#x2013; 10 ファイル入出力
</li>
<li><a href="http://wiki.cis.iwate-u.ac.jp/~cis/prog2/pukiwiki/index.php?9%E5%9B%9E%E7%9B%AE">9回目</a> &#x2013; 10 ファイル入出力 (ランダムアクセス)
</li>
<li><a href="http://wiki.cis.iwate-u.ac.jp/~cis/prog2/pukiwiki/index.php?10%E5%9B%9E%E7%9B%AE">a回目</a> &#x2013; 11 高度なプロラミング，11.1 ポインタを返す関数， 11.2 関数
へのポインタ，11.3 可変個の引数を持つ関数, 11.4 メモリの動的確保，
11.5 確保領域の大きさを変更する
</li>
<li><a href="http://wiki.cis.iwate-u.ac.jp/~cis/prog2/pukiwiki/index.php?11%E5%9B%9E%E7%9B%AE">b回目</a> &#x2013; 11.6 分割コンパイル，ヘッダファイル
</li>
<li><a href="http://wiki.cis.iwate-u.ac.jp/~cis/prog2/pukiwiki/index.php?12%E5%9B%9E%E7%9B%AE">c回目</a> &#x2013; 11.7 プリプロセッサ, make
</li>
<li><a href="http://wiki.cis.iwate-u.ac.jp/~cis/prog2/pukiwiki/index.php?13%E5%9B%9E%E7%9B%AE">d回目</a> &#x2013; 応用プログラミング
</li>
<li><a href="http://wiki.cis.iwate-u.ac.jp/~cis/prog2/pukiwiki/index.php?14%E5%9B%9E%E7%9B%AE">e回目</a> &#x2013; 応用プログラミング
</li>
</ul>
</div>
</div>


<div id="outline-container-sec-7" class="outline-2">
<h2 id="sec-7"><span class="section-number-2">7</span> プログラム言語及び演習II 項目順</h2>
<div class="outline-text-2" id="text-7">
</div><div id="outline-container-sec-7-1" class="outline-3">
<h3 id="sec-7-1"><span class="section-number-3">7.1</span> 配列</h3>
<div class="outline-text-3" id="text-7-1">
<ul class="org-ul">
<li><a href="http://wiki.cis.iwate-u.ac.jp/~cis/prog2/pukiwiki/index.php?2%E5%9B%9E%E7%9B%AE">2回目</a> &#x2013; 8.1 配列の基本，8.2 配列とアドレス, 8.3 多次元配列
</li>
<li><a href="http://wiki.cis.iwate-u.ac.jp/~cis/prog2/pukiwiki/index.php?3%E5%9B%9E%E7%9B%AE">3回目</a> &#x2013; 8.4 文字と文字列，8.5 文字配列，8.6 文字の入力
</li>
<li><a href="http://wiki.cis.iwate-u.ac.jp/~cis/prog2/pukiwiki/index.php?4%E5%9B%9E%E7%9B%AE">4回目</a> &#x2013; 8.6 文字の入力, 8.7 文字列の加工, 8.8 文字列ポインタを配列
にする，8.9 コマンド・ライン引数，
</li>
</ul>
</div>
</div>


<div id="outline-container-sec-7-2" class="outline-3">
<h3 id="sec-7-2"><span class="section-number-3">7.2</span> 構造体</h3>
<div class="outline-text-3" id="text-7-2">
<ul class="org-ul">
<li><a href="http://wiki.cis.iwate-u.ac.jp/~cis/prog2/pukiwiki/index.php?5%E5%9B%9E%E7%9B%AE">5回目</a> &#x2013; 8.10 関数に配列を渡す，9.1 構造体の宣言，9.2 構造体メンバ
へのアクセス方法，9.3 構造体の配列
</li>
</ul>
</div>
</div>


<div id="outline-container-sec-7-3" class="outline-3">
<h3 id="sec-7-3"><span class="section-number-3">7.3</span> ポインタ</h3>
<div class="outline-text-3" id="text-7-3">
<ul class="org-ul">
<li><a href="http://wiki.cis.iwate-u.ac.jp/~cis/prog2/pukiwiki/index.php?1%E5%9B%9E%E7%9B%AE">1回目</a> &#x2013; 7 ポインタ
</li>
<li><a href="http://wiki.cis.iwate-u.ac.jp/~cis/prog2/pukiwiki/index.php?6%E5%9B%9E%E7%9B%AE">6回目</a> &#x2013; ポインタの復習
</li>
<li><a href="http://wiki.cis.iwate-u.ac.jp/~cis/prog2/pukiwiki/index.php?10%E5%9B%9E%E7%9B%AE">a回目</a> &#x2013; 11.1 ポインタを返す関数， 11.2 関数
へのポインタ，11.3 可変個の引数を持つ関数, 
</li>
</ul>
</div>
</div>


<div id="outline-container-sec-7-4" class="outline-3">
<h3 id="sec-7-4"><span class="section-number-3">7.4</span> 型の定義</h3>
<div class="outline-text-3" id="text-7-4">
<ul class="org-ul">
<li><a href="http://wiki.cis.iwate-u.ac.jp/~cis/prog2/pukiwiki/index.php?7%E5%9B%9E%E7%9B%AE">7回目</a> &#x2013; 9.4 構造体へのポインタ, 9.5 新しい型を定義する，9.6 メンバ
に同じ型へのポインタを持つ構造体, 9.7 共用体
</li>
</ul>
</div>
</div>


<div id="outline-container-sec-7-5" class="outline-3">
<h3 id="sec-7-5"><span class="section-number-3">7.5</span> ファイル入出力</h3>
<div class="outline-text-3" id="text-7-5">
<ul class="org-ul">
<li><a href="http://wiki.cis.iwate-u.ac.jp/~cis/prog2/pukiwiki/index.php?8%E5%9B%9E%E7%9B%AE">8回目</a> &#x2013; 10 ファイル入出力
</li>
<li><a href="http://wiki.cis.iwate-u.ac.jp/~cis/prog2/pukiwiki/index.php?9%E5%9B%9E%E7%9B%AE">9回目</a> &#x2013; 10 ファイル入出力 (ランダムアクセス)
</li>
</ul>
</div>
</div>


<div id="outline-container-sec-7-6" class="outline-3">
<h3 id="sec-7-6"><span class="section-number-3">7.6</span> 動的メモリ確保</h3>
<div class="outline-text-3" id="text-7-6">
<ul class="org-ul">
<li><a href="http://wiki.cis.iwate-u.ac.jp/~cis/prog2/pukiwiki/index.php?10%E5%9B%9E%E7%9B%AE">a回目</a> &#x2013; 11.4 メモリの動的確保，11.5 確保領域の大きさを変更する
</li>
</ul>
</div>
</div>


<div id="outline-container-sec-7-7" class="outline-3">
<h3 id="sec-7-7"><span class="section-number-3">7.7</span> 分割コンパイル</h3>
<div class="outline-text-3" id="text-7-7">
<ul class="org-ul">
<li><a href="http://wiki.cis.iwate-u.ac.jp/~cis/prog2/pukiwiki/index.php?11%E5%9B%9E%E7%9B%AE">b回目</a> &#x2013; 11.6 分割コンパイル，ヘッダファイル
</li>
<li><a href="http://wiki.cis.iwate-u.ac.jp/~cis/prog2/pukiwiki/index.php?12%E5%9B%9E%E7%9B%AE">c回目</a> &#x2013; 11.7 プリプロセッサ,
</li>
</ul>
</div>
</div>


<div id="outline-container-sec-7-8" class="outline-3">
<h3 id="sec-7-8"><span class="section-number-3">7.8</span> make</h3>
<div class="outline-text-3" id="text-7-8">
<ul class="org-ul">
<li><a href="http://wiki.cis.iwate-u.ac.jp/~cis/prog2/pukiwiki/index.php?12%E5%9B%9E%E7%9B%AE">c回目</a> &#x2013; make
</li>
</ul>
</div>
</div>


<div id="outline-container-sec-7-9" class="outline-3">
<h3 id="sec-7-9"><span class="section-number-3">7.9</span> 実践的なデータ処理プログラム</h3>
<div class="outline-text-3" id="text-7-9">
<ul class="org-ul">
<li><a href="http://wiki.cis.iwate-u.ac.jp/~cis/prog2/pukiwiki/index.php?13%E5%9B%9E%E7%9B%AE">d回目</a> &#x2013; 応用プログラミング
</li>
<li><a href="http://wiki.cis.iwate-u.ac.jp/~cis/prog2/pukiwiki/index.php?14%E5%9B%9E%E7%9B%AE">e回目</a> &#x2013; 応用プログラミング
</li>
</ul>
</div>
</div>
</div>

<div id="outline-container-sec-8" class="outline-2">
<h2 id="sec-8"><span class="section-number-2">8</span> テストと開発</h2>
<div class="outline-text-2" id="text-8">
</div>
</div>

<div id="outline-container-sec-9" class="outline-2">
<h2 id="sec-9"><span class="section-number-2">9</span> テスト駆動開発について</h2>
<div class="outline-text-2" id="text-9">
</div><div id="outline-container-sec-9-1" class="outline-3">
<h3 id="sec-9-1"><span class="section-number-3">9.1</span> 入門サイト</h3>
<div class="outline-text-3" id="text-9-1">
<ul class="org-ul">
<li><a href="http://www.slideshare.net/shuji_w6e/ss-15246933">テスト駆動開発入門</a> (slideshare)
</li>

<li><a href="http://www.atmarkit.co.jp/ait/articles/1403/05/news035.html">超入門テスト駆動開発／振る舞い駆動開発を始めるための基礎知識 (1/3) - ＠IT</a>
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-9-2" class="outline-3">
<h3 id="sec-9-2"><span class="section-number-3">9.2</span> やりたいこと</h3>
<div class="outline-text-3" id="text-9-2">
<p>
少しづつ，以下のことを，繰り返すことで，開発を進めること：
</p>

<ul class="org-ul">
<li>まず，(テストを書くことで APIを）設計し，
</li>
<li>次に，(APIを守って) 機能を実装し，
</li>
<li>そして，要求を満たしていることを確かめる，
</li>
<li>今回の変更が，他に影響を及ぼさないことを確かめる
</li>
</ul>
</div>
</div>
</div>


<div id="outline-container-sec-10" class="outline-2">
<h2 id="sec-10"><span class="section-number-2">10</span> 開発と機能とテスト</h2>
<div class="outline-text-2" id="text-10">
</div><div id="outline-container-sec-10-1" class="outline-3">
<h3 id="sec-10-1"><span class="section-number-3">10.1</span> 開発と機能</h3>
<div class="outline-text-3" id="text-10-1">
<p>
機能の要求と実現を，一人で行う場合もありますし，
他人からの要求に応えて，実現を引き受ける場合もあります。
</p>

<p>
どちらの場合にも，機能を要求・利用する側と実現・提供する側に分けるこ
とで，インタフェースを守ることにより，プログラムの開発を分割し独立し
て行うことが出来ます。
</p>

<p>
多人数で開発する場合は分担開発ができるということですし，一人で開発す
る場合でも，より小さな開発へ分割できることになります。
</p>

<p>
大きなプログラムを開発する場合を考えます。大きな機能の実現が求められ
る場合，より小さな機能の組み合わせとなるよう考えます。実際，そうなっ
ていることがほとんどです。また，プログラムがたくさんの機能を要求す
る場合は，復数の機能がグループ化されたり，階層化されたりします。
この場合もやはり，より小さな開発の組み合わせとなります。
</p>
</div>
</div>

<div id="outline-container-sec-10-2" class="outline-3">
<h3 id="sec-10-2"><span class="section-number-3">10.2</span> 開発とテスト</h3>
<div class="outline-text-3" id="text-10-2">
<p>
小さな機能の組み合わせで大きな開発をおこなう場合，利用する各機能が
正しく動くことが保証されていると，スムーズに開発できます。
</p>

<p>
おかしなことが起こった場合でも，切り分けが可能になります。
</p>

<p>
テストは，誰でも時間が経過し中身を忘れても，その保証を確認できます。
</p>
</div>
</div>
</div>












<div id="outline-container-sec-11" class="outline-2">
<h2 id="sec-11"><span class="section-number-2">11</span> 機能とヘッダファイル/ライブラリ</h2>
<div class="outline-text-2" id="text-11">
<p>
三角関数を使う下記のプログラムを考えます:
</p>

<div class="org-src-container">

<pre class="src src-c"># include &lt;stdio.h&gt;
# include &lt;stdlib.h&gt;
# include &lt;math.h&gt;
int
main()
{
  double result = sin(3.14L);
  printf("sin(3.14)=%g\n", result);
  exit(0);
}
</pre>
</div>

<p>
このソースプログラムをコンパイルし，実行形式プログラムを作成するに
は，下記コマンドを実行します:
</p>

<div class="org-src-container">

<pre class="src src-sh">%  cc -o sin314 sin314.c -lm
</pre>
</div>

<p>
実行は：
</p>

<div class="org-src-container">

<pre class="src src-sh">% ./sin314
</pre>
</div>

<p>
sin関数を計算する機能を，プログラムから利用するために，上記のプログ
ラムで行なわれていることをまとめると:
</p>

<dl class="org-dl">
<dt> 提供 </dt><dd>/usr/lib/libm.so ライブラリ, % nm /usr/lib/libm.so 
</dd>
<dt> 利用 </dt><dd>#include &lt;math&gt;, cc -lm
</dd>
<dt> 情報 </dt><dd>% man 3 sin
</dd>
</dl>
</div>


<div id="outline-container-sec-11-1" class="outline-3">
<h3 id="sec-11-1"><span class="section-number-3">11.1</span> 機能を要求する</h3>
<div class="outline-text-3" id="text-11-1">
<p>
数値計算プログラムから使う"三角関数の計算"機能, double sin(double);
が要求する機能。
</p>

<div class="org-src-container">

<pre class="src src-sh">grep sin /usr/include/math.h
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-11-2" class="outline-3">
<h3 id="sec-11-2"><span class="section-number-3">11.2</span> 提供されている機能</h3>
<div class="outline-text-3" id="text-11-2">
<p>
機能を提供しているのは，Linux の数値計算ライブラリ /usr/lib/libm.so。
</p>

<div class="org-src-container">

<pre class="src src-sh">file /usr/lib/libm.so
nm /usr/lib/libm.so | grep sin
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-11-3" class="outline-3">
<h3 id="sec-11-3"><span class="section-number-3">11.3</span> 機能の説明</h3>
<div class="outline-text-3" id="text-11-3">
<p>
ユーザはmanコマンドで使い方を知り，~#include &lt;math.h&gt;~ で sin 関数
を使うためのインタフェースを取り込み，~cc &#x2026; -lm~ で数学ライブラリ
を取り込む。
</p>
</div>
</div>

<div id="outline-container-sec-11-4" class="outline-3">
<h3 id="sec-11-4"><span class="section-number-3">11.4</span> 機能を使うきまり</h3>
<div class="outline-text-3" id="text-11-4">
<ul class="org-ul">
<li>利用側のプログラムでは，利用インタフェースが記述されたヘッダファイ
ルをインクルードし，インタフェースを遵守します。
</li>

<li>提供側のプログラムは，利用インタフェースが記述されたヘッダファイル
を作成し，自らそれをインクルードすることで，自身もインタフェースを
遵守します。
</li>

<li>提供側は，プログラムソースは見せずに，機能をライブラリに詰め込み，
ライブラリとヘッダファイルを公開します。
</li>

<li>利用側は，自身のプログラムとライブラリをリンクすることで，自身の実
行プログラムに機能を取り込むことができます。
</li>
</ul>

<p>
Linux システム上で，C言語を使ってプログラム開発をおこなう際の，決まり
事です。
</p>
</div>
</div>

<div id="outline-container-sec-11-5" class="outline-3">
<h3 id="sec-11-5"><span class="section-number-3">11.5</span> 機能を利用する側と機能を提供する側とヘッダファイル</h3>
<div class="outline-text-3" id="text-11-5">
<p>
main関数は，sin関数（機能）を使う側です。数学ライブラリを開発する
側が，sin関数を提供する側で，math.hがsin関数を使う際の決まりごと（イン
タフェース）を定めています。
</p>

<p>
使う側は，ヘッダファイル math.h を include し，コンパイル時にエラー
が起きないことで，そのインタフェースを守っていることが保証されるの
です。
</p>
</div>
</div>
</div>


<div id="outline-container-sec-12" class="outline-2">
<h2 id="sec-12"><span class="section-number-2">12</span> プログラムの機能</h2>
<div class="outline-text-2" id="text-12">
<p>
プログラムの働きを <b>機能</b> と呼ぶことにします。
</p>
</div>

<div id="outline-container-sec-12-1" class="outline-3">
<h3 id="sec-12-1"><span class="section-number-3">12.1</span> 基本は関数</h3>
<div class="outline-text-3" id="text-12-1">
<p>
プログラム演習Iの関数の基本を思いだそう
</p>

<ul class="org-ul">
<li><a href="http://wiki.cis.iwate-u.ac.jp/~cis/prog1/pukiwiki/index.php?%E7%AC%AC10%E5%9B%9E">第a回</a> &#x2013; 6.1 関数の基本，6.2 引数と戻り値
</li>
<li><a href="http://wiki.cis.iwate-u.ac.jp/~cis/prog1/pukiwiki/index.php?%E7%AC%AC11%E5%9B%9E">第b回</a> &#x2013; 6.3 変数の寿命とスコープ，6.4 再帰呼び出し
</li>
</ul>
</div>

<div id="outline-container-sec-12-1-1" class="outline-4">
<h4 id="sec-12-1-1">関数を呼び出すこと</h4>
<div class="outline-text-4" id="text-12-1-1">
<pre class="example">
{ int value = f(1.0, "abc"); ... }
</pre>
</div>
</div>

<div id="outline-container-sec-12-1-2" class="outline-4">
<h4 id="sec-12-1-2">関数を定めること</h4>
<div class="outline-text-4" id="text-12-1-2">
<pre class="example">
int
f(double x, char *name)
{ ... ; return 1; }
</pre>
</div>
</div>

<div id="outline-container-sec-12-1-3" class="outline-4">
<h4 id="sec-12-1-3">関数を呼び出すことと定めることの間にある決まりごと</h4>
<div class="outline-text-4" id="text-12-1-3">
<pre class="example">
int f(double, char *name);
</pre>
</div>
</div>
</div>



<div id="outline-container-sec-12-2" class="outline-3">
<h3 id="sec-12-2"><span class="section-number-3">12.2</span> 機能とは</h3>
<div class="outline-text-3" id="text-12-2">
<p>
この講義では，C言語の関数の <b>働き</b> を機能といいます。
</p>

<p>
関数の働きとは，「関数に何を与えて，関数は何を計算してくれるか」です。
</p>
</div>
</div>

<div id="outline-container-sec-12-3" class="outline-3">
<h3 id="sec-12-3"><span class="section-number-3">12.3</span> 機能を要求する</h3>
<div class="outline-text-3" id="text-12-3">
<p>
このデータを与えると，こんな計算をして，こんな結果を返してくれる関数
を作ってくれませんか？
</p>

<ul class="org-ul">
<li>度数版sin関数::
</li>
</ul>
<pre class="example">
double型の，ラジアンではなく，度数で計算してくれる sin 関数で，結果はfloatでね。
</pre>

<dl class="org-dl">
<dt> トランプ・カードのスーツ計算 </dt><dd></dd>
</dl>
<pre class="example">
トランプのスーツを与えると，スーツの強さを整数で返してくれる関数を，お願い。
</pre>

<ul class="org-ul">
<li>カードに関する機能(群) &#x2013; モジュール
</li>
</ul>
<pre class="example">
ポーカーゲームで使うカードの機能達の組。個々の機能は自由に設計してね。
</pre>
</div>
</div>

<div id="outline-container-sec-12-4" class="outline-3">
<h3 id="sec-12-4"><span class="section-number-3">12.4</span> 機能を実現する</h3>
<div class="outline-text-3" id="text-12-4">
<p>
はい，了解。こんな入力に対して，こんな風にを計算して，こんな結果を
返す関数を作りました。
</p>

<p>
こんな風につかってくださいね。
</p>

<pre class="example">
float deg_sin(double);
</pre>

<pre class="example">
int suit_int(char *);
</pre>

<pre class="example">
card.h に使い方が書いてあります。
card/ ディレクトリの下にソースがありますが，見なくても使えるはずです。
</pre>
</div>
</div>

<div id="outline-container-sec-12-5" class="outline-3">
<h3 id="sec-12-5"><span class="section-number-3">12.5</span> 機能を提供する</h3>
<div class="outline-text-3" id="text-12-5">
<p>
ヘッダファイルを作りましたので，インクルードして使ってください。本
体は，オブジェクトファイルやライブラリで提供します。ソースを見る必
要はないはずです。
</p>

<pre class="example">
degsin.h
libdeg.a
</pre>

<pre class="example">
suit.h
suit_int.o をリンクしてください。
</pre>

<pre class="example">
card.h に使い方が書いてあります。
libcard.a をリンクしてください。
</pre>
</div>
</div>

<div id="outline-container-sec-12-6" class="outline-3">
<h3 id="sec-12-6"><span class="section-number-3">12.6</span> 機能を利用する</h3>
<div class="outline-text-3" id="text-12-6">
<p>
ありがとう，では使わせてもらいます。
</p>

<div class="org-src-container">

<pre class="src src-c" id="use_suit.c"># include &lt;stdlib.h&gt;
# include &lt;stdio.h&gt;

# include &lt;suit.h&gt;

main()
{
  int s = suit_int("HEART");
  printf("HEART = %d\n", s);
  exit(0);
}
</pre>
</div>

<div class="org-src-container">

<pre class="src src-sh" id="use_suit_cc.sh">INCLUDE_PATH = /path/to/header_file
LIBRARY_PATH = /path/to/library
cc -I $INCLUDE_PATH main.c -L $LIBRARY_PATH -lsuit
</pre>
</div>

<p>
うまく使えました。ありがとう。
</p>
</div>
</div>

<div id="outline-container-sec-12-7" class="outline-3">
<h3 id="sec-12-7"><span class="section-number-3">12.7</span> 機能の要求と実現と提供と利用</h3>
<div class="outline-text-3" id="text-12-7">
<p>
欲しい機能が既に存在すれば，それを再開発せずに，使えることが望まれ
ます。  欲しい機能が存在しなければ，その機能を実現し，上と同じ方法
で提供・利用することも望まれます。
</p>

<p>
機能に対する要求・実現・提供・利用が，別々に行えると融通性が高くな
ります。
</p>
<p>
原著: <a href="http://www.itmedia.co.jp/im/articles/1111/07/news192.html">情報システム用語事典：ソフトウェアテスト（そふとうぇあてすと）</a>
</p>

<p>
コンピュータのソフトウェアプログラムを実行し、それが意図したとおりに動
くかを観測・評価・検証する作業のこと。
</p>
</div>
</div>
</div>

<div id="outline-container-sec-13" class="outline-2">
<h2 id="sec-13"><span class="section-number-2">13</span> ソフトウェアテストを行う目的</h2>
<div class="outline-text-2" id="text-13">
<ul class="org-ul">
<li><b>欠陥やバグを検出する</b>
</li>
<li><b>要件を満たすことを保証する</b>
</li>
<li>リリース後の品質リスクを見積もる
</li>
<li>開発プロセス改善の指標となる
</li>
</ul>

<p>
どの目的を重視するかは、開発するソフトウェアプロダクトの目的やニーズ、
開発組織の成熟度などによって変わってくる。
</p>
</div>
</div>

<div id="outline-container-sec-14" class="outline-2">
<h2 id="sec-14"><span class="section-number-2">14</span> ソフトウェア開発におけるテスト</h2>
<div class="outline-text-2" id="text-14">
<ul class="org-ul">
<li>ユーザーの使用状況を反映した入力データを用いてソフトウェアを実行し、
</li>
<li>事前に想定した結果と実際の実行結果をつき合わせて合否の判定を行う。
</li>
</ul>
</div>

<div id="outline-container-sec-14-1" class="outline-3">
<h3 id="sec-14-1"><span class="section-number-3">14.1</span> テストとテストケース</h3>
<div class="outline-text-3" id="text-14-1">
<p>
このテスト用の <b>入力データ</b> とそれを実行したら得られるであろう <b>事前に
想定した結果</b> の対を <b>テストケース</b> という。
</p>

<p>
テストケースを使って対象を実行してみる行為がテストである。
</p>
</div>
</div>

<div id="outline-container-sec-14-2" class="outline-3">
<h3 id="sec-14-2"><span class="section-number-3">14.2</span> テストされていないプログラム</h3>
<div class="outline-text-3" id="text-14-2">
<p>
正しい動作を保証されず、実際に高い確率で正しく動作しない。
</p>

<p>
したがってソフトウェア開発において、でき得る限り網羅的にテストを行うべ
きであり、テスト自体は必須の工程と位置付けられてきた。
</p>

<p>
しかしながら、ソフトウェア開発の黎明期から「完全なテスト」の困難性が指
摘されている。
</p>
</div>
</div>

<div id="outline-container-sec-14-3" class="outline-3">
<h3 id="sec-14-3"><span class="section-number-3">14.3</span> テストの複雑さ</h3>
<div class="outline-text-3" id="text-14-3">
<p>
実用レベルの複雑さ（規模）を持つソフトウェアの場合、“入力データ”と
“実行結果”の組み合わせは事実上無限となる。
</p>

<p>
また、環境に依存する機能では、環境との組み合わせも発生する。
</p>

<p>
このため、ほとんどのテストは無限の組み合わせに対して有限個のテストケー
スをあてがう作業であって、完全なテストにはならないのである。
</p>
</div>
</div>
</div>

<div id="outline-container-sec-15" class="outline-2">
<h2 id="sec-15"><span class="section-number-2">15</span> ソフトウェアテストの技法や手法</h2>
<div class="outline-text-2" id="text-15">
</div><div id="outline-container-sec-15-1" class="outline-3">
<h3 id="sec-15-1"><span class="section-number-3">15.1</span> ソフトウェアテストの主な分類</h3>
<div class="outline-text-3" id="text-15-1">
</div><div id="outline-container-sec-15-1-1" class="outline-4">
<h4 id="sec-15-1-1">テストレベル（開発フェイズ）による分類</h4>
<div class="outline-text-4" id="text-15-1-1">
<ul class="org-ul">
<li>単体テスト
</li>
<li>結合テスト
</li>
<li>システムテスト
</li>
<li>受け入れテスト
</li>
<li>回帰テスト
</li>
<li>スモークテスト  
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-15-1-2" class="outline-4">
<h4 id="sec-15-1-2">テスト設計技法による分類</h4>
<div class="outline-text-4" id="text-15-1-2">
<ul class="org-ul">
<li>構造ベース技法 （制御パステスト、データフローパステストなど）  
</li>
<li>仕様ベース技法 （同値分割、 境界値分析、 原因結果グラフ技法、 状態遷
移テスト、ユースケーステスト、ドメイン分析テスト、組み合わせテスト／
ペア構成テストなど）
</li>
<li>経験ベース技法 （エラー推測、 探索的テスト、 アドホックテスト、 ラン
ダムテストなど）
</li>
</ul>

<p>
テスト設計テクニックによる分類: 
</p>

<ul class="org-ul">
<li>ホワイトボックステスト
</li>
<li>ブラックボックステスト 
</li>
<li>グレーボックステスト
</li>
</ul>
</div>

<div id="outline-container-sec-15-1-2-1" class="outline-5">
<h5 id="sec-15-1-2-1">テスト対象となる品質特性による分類</h5>
<div class="outline-text-5" id="text-15-1-2-1">
<ul class="org-ul">
<li>機能テスト  
</li>

<li>非機能テスト 
<ul class="org-ul">
<li>性能テスト
</li>
<li>負荷テスト
</li>
<li>ユーザビリティテスト
</li>
<li>相互運用性テスト
</li>
<li>保守性テスト
</li>
<li>信頼性テスト
</li>
<li>移植性テスト
</li>
</ul>
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-15-1-2-2" class="outline-5">
<h5 id="sec-15-1-2-2">テスト実施者、テスト目的による分類</h5>
<div class="outline-text-5" id="text-15-1-2-2">
<ul class="org-ul">
<li>デベロッパテスト
</li>
<li>カスタマテスト
</li>
<li>品質保証テスト  
</li>
</ul>
</div>
</div>
</div>
</div>


<div id="outline-container-sec-15-2" class="outline-3">
<h3 id="sec-15-2"><span class="section-number-3">15.2</span> テストの一般原則</h3>
<div class="outline-text-3" id="text-15-2">
<p>
ソフトウェアテストの世界には、長年の経験をまとめた7つの一般原則がある。
</p>

<ul class="org-ul">
<li>原則1　テストは欠陥があることしか示せない。

<p>
欠陥がないことを証明できない
</p>
</li>

<li>原則2　全数テストは不可能。

<p>
ごく単純なソフトウェア以外は、すべての条件をテストすることは非現実的
である
</p>
</li>

<li>原則3　初期テスト。

<p>
テストは開発ライフサイクルの早い時期に開始すべきである
</p>
</li>

<li>原則4　欠陥の偏在。

<p>
テストで見つかる欠陥の大部分は、特定の部分に集中する
</p>
</li>

<li>原則5　殺虫剤のパラドックス。

<p>
同じテストを何度も繰り返すと、そのテストでは新しいバグを見つけられな
くなる
</p>
</li>

<li>原則6　テストは条件次第。

<p>
ソフトウェアの要件が異なれば、テストの方法も変わる
</p>
</li>

<li>原則7　「バグゼロ」の落とし穴

<p>
仮にバグがゼロだとしても、要求を満たしていなければ、そのシステムは役
に立たない
</p>
</li>
</ul>
</div>
</div>
</div>

<div id="outline-container-sec-16" class="outline-2">
<h2 id="sec-16"><span class="section-number-2">16</span> バイザーのテスト成熟度</h2>
<div class="outline-text-2" id="text-16">
<ul class="org-ul">
<li>レベル0  テストとは、デバッグのことである  
</li>
<li>レベル1  テストの目的は、ソフトウェアが正常に働くことを示すことである  
</li>
<li>レベル2  テストの目的は、ソフトウェアが正常に働かないことを示すことで
ある
</li>
<li>レベル3  テストの目的は、ソフトウェアが正常に働かないことで生じるリス
クを許容値まで下げることである
</li>
<li>レベル 4 テストとは、高品質のソフトウェアを開発しようという精神的な規
律である
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-17" class="outline-2">
<h2 id="sec-17"><span class="section-number-2">17</span> cutter</h2>
<div class="outline-text-2" id="text-17">
<p>
cutter は C/C++ 言語用の単体テストフレームワークです。
</p>

<p>
<a href="http://cutter.sourceforge.net/reference/ja/readme.html">はじめに: Cutterリファレンスマニュアル - Cutter</a> をざっと読んでみましょう。使いながら覚えましょう。
</p>
</div>
</div>

<div id="outline-container-sec-18" class="outline-2">
<h2 id="sec-18"><span class="section-number-2">18</span> テスト・ファイルの作成</h2>
<div class="outline-text-2" id="text-18">
<p>
cutterで*テスト*を行なうためには，テスト用ディレクトリを作成し，テ
スト用ディレクトリの中に，*テスト*を作成します。
</p>

<p>
cutterでのテストは，ディレクトリの中の，test_ で始まるtest_*.so と
いう名前のテストファイル(達)です。
</p>

<p>
テストファイルを作成するため，test_*.c にソースプログラムを書き，コ
ンパイルして，test_*.so を作成します。
</p>

<p>
ここでは，~/progs/cutter/test がテスト用ディレクトリ，
~/progs/cutter/test/test_first.c がテストのソースファイルです。
テスト test_first.so を作成することが目的で，そのためにMakefileを容
易します。
</p>

<p>
まず，テスト用ディレクトリを作成します。
次のコマンドで行います:
</p>

<div class="org-src-container">

<pre class="src src-sh"># [~/progs] % 
mkdir -p cutter/test
</pre>
</div>

<p>
テストファイルを作成するため，ソースプログラム
(cutter/test/test_first.c) を作成します：
</p>

<div class="org-src-container">

<pre class="src src-c">// ~/progs/cutter/test/test_first.c
#include &lt;cutter.h&gt;
#include &lt;string.h&gt;

static int condition = 0;

void
cut_setup (void)
{
    /* 初期化用コード */
    condition = 1;
}

void
cut_teardown (void)
{
    /* 後片付け用コード */
    condition = 0;
}

void
test_condition(void)
{
    cut_set_message("conditionの値はcut_setup()で1に設定されているはず");
    cut_assert(condition==1);
}

void
test_strcmp(void)
{
    cut_set_message("同じ文字列に対し，strcmpは0を返すはず");
    cut_assert(strcmp("string", "string")==0);
}
</pre>
</div>

<ul class="org-ul">
<li>cutter.h をインクルードし， cutter が提供する機能のインタフェース
を受け入れます。
</li>

<li>string.h をインクルードし，テストしたい文字列機能のインタフェース
を受け入れます。
</li>

<li>テストに使う変数 condition を宣言します。
</li>

<li>cut_setup と cut_teardown 関数は，各テストの前後に呼ばれる初期化
と後処理のための関数です。ここでは，conditionの値を設定，クリアしています。
</li>

<li>test_ で始まる関数がテストを行なうテスト関数です。

<p>
テスト関数は，テストのための*表明*を含みます。表明とは，機能が正し
いときに真となる論理式のことです。
</p>

<p>
cutterでの表明は，cut_assert で
始まる関数に，表明をあらわす論理値を与える呼び出しで書きます。
</p>
</li>

<li>cut_assert(condition==1) は，conditionの値が1であることを確かめる
ための表明です。
</li>

<li>cut_assert(strcmp("string", "string")==0) は，strcmp 関数が0を
返すことを確かめるための表明です。

<p>
cut_assert関数は，その値が真ならテスト成功として，偽ならテスト失
敗として，振舞います。
</p>
</li>

<li>cut_set_message("message")は　表明が失敗した場合に表示するメッ
セージを指定します。
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-19" class="outline-2">
<h2 id="sec-19"><span class="section-number-2">19</span> テストのビルド</h2>
<div class="outline-text-2" id="text-19">
</div><div id="outline-container-sec-19-1" class="outline-3">
<h3 id="sec-19-1"><span class="section-number-3">19.1</span> Makefile</h3>
<div class="outline-text-3" id="text-19-1">
<p>
テストをビルド(作成)するために，makeを使います。Makefileの書き方は，
</p>

<p>
<a href="http://wiki.cis.iwate-u.ac.jp/~cis/prog2/pukiwiki/index.php?12%E5%9B%9E%E7%9B%AE#f623ebec">prog2::make</a> を見て，思い出して下さい。
</p>

<p>
テストディレクトリの中に Makefile を作成します:
</p>

<div class="org-src-container">

<pre class="src src-makefile"># ~/progs/cutter/test/Makefile
CFLAGS = -fPIC `pkg-config cutter --cflags`
LDFLAGS = `pkg-config cutter --libs`

test_first.so: test_first.o
	gcc -o $@ -shared $&lt; $(LDFLAGS)

test_first.o: test_first.c
	gcc -c $&lt; $(CFLAGS)

.PHONY: clean
clean:
	rm -f *.o *.so
</pre>
</div>

<ul class="org-ul">
<li>CFLAGS にはコンパイラへの指示を書きます。   

<p>
`pkg-config cutter &#x2013;cflags` と書くのは，
</p>

<p>
'-I /usr/include/cutter'と書くのと同等です。
</p>

<p>
'-I' はインクルードパスの指定です。cutter.h のあるディレクトリを指定しています。
</p>
</li>
</ul>


<ul class="org-ul">
<li>LDFLAGS にはローダへの指示を書きます。'-lcutter' はライブラリパス
にある libcutter.a または libcutter.so を意味します。利用環境では，
/usr/lib/libcutter.soになります。
</li>

<li>test_first.so がビルドのターゲットです。-share オプションで，共有ライブラリにします。
main関数は必要ありません。
</li>

<li>test_first.c をコンパイルしオブジェクト・ファイル test_first.o を
作ります。このとき CFLAGS変数で，cutter.h の在処を指定しています。
</li>
</ul>

<p>
make してテストをビルドしましょう:
</p>

<div class="org-src-container">

<pre class="src src-sh"># [~/progs/cutter/test] %
 make
</pre>
</div>

<pre class="example">
gcc -c test_first.c -fPIC `pkg-config cutter --cflags`
gcc -o test_first.so -shared test_first.o `pkg-config cutter --libs`
</pre>

<p>
上記のコマンドが成功すれば，test_first.so が出来上がっています。
</p>
</div>
</div>
</div>

<div id="outline-container-sec-20" class="outline-2">
<h2 id="sec-20"><span class="section-number-2">20</span> テストのビルドへの補足説明</h2>
<div class="outline-text-2" id="text-20">
</div><div id="outline-container-sec-20-1" class="outline-3">
<h3 id="sec-20-1"><span class="section-number-3">20.1</span> コンパイラへの指示</h3>
<div class="outline-text-3" id="text-20-1">
<p>
Makefile 中の記述への補足です:
</p>
</div>

<div id="outline-container-sec-20-1-1" class="outline-4">
<h4 id="sec-20-1-1">include パス</h4>
<div class="outline-text-4" id="text-20-1-1">
<div class="org-src-container">

<pre class="src src-sh"># 次のコマンドを実行してみてください
pkg-config cutter --cflags
</pre>
</div>

<pre class="example">
-I/usr/include/cutter  
</pre>

<p>
この結果を，Cコンパイラのオプションで指定すると，インクルード・パ
スに~/usr/include/cutter~ を加えることになり，cutter.h がインクルー
ドできることになります。
</p>
</div>
</div>

<div id="outline-container-sec-20-1-2" class="outline-4">
<h4 id="sec-20-1-2">ライブラリとライブラリ・パス</h4>
<div class="outline-text-4" id="text-20-1-2">
<div class="org-src-container">

<pre class="src src-sh"># 次のコマンドを実行してみてください
# cutter を使うために必要なライブラリの情報がわかります。
pkg-config cutter --libs
</pre>
</div>

<pre class="example">
-lcutter  
</pre>

<ul class="org-ul">
<li>この結果を，Cコンパイラ(実はローダ)のオプションで指定すると，ライ
ブラリに libcutter.so を加えることになります。
</li>
</ul>
</div>
</div>
</div>

<div id="outline-container-sec-20-2" class="outline-3">
<h3 id="sec-20-2"><span class="section-number-3">20.2</span> ヘッダファイルやライブラリファイルの場所</h3>
<div class="outline-text-3" id="text-20-2">
<p>
cutter.h や libcutter.so の在処を調べてみましょう:
</p>

<div class="org-src-container">

<pre class="src src-sh"># 次のコマンドを実行してみてください
# cutter.h がある場所がわかります。
locate cutter.h
</pre>
</div>

<p>
&lt;cutter.h&gt; は /usr/include/cutter/cutter.h ですね。
</p>

<div class="org-src-container">

<pre class="src src-sh"># 次のコマンドを実行してみてください
# libcutter.so がある場所がわかります。
locate libcutter.so
</pre>
</div>

<p>
-lcutter で指定した libcutter.so は /usr/lib/libbutter.so です。
/usr/lib はシステムの通常のライブラリを置く場所です。
</p>
</div>
</div>

<div id="outline-container-sec-20-3" class="outline-3">
<h3 id="sec-20-3"><span class="section-number-3">20.3</span> オブジェクト・ファイルのこと</h3>
<div class="outline-text-3" id="text-20-3">
<div class="org-src-container">

<pre class="src src-sh"># [~/progs/cutter/test] % 
# test_first.o の中に何があるか調べましょう。
# 次のコマンドを実行してください。e

nm test_first.o
</pre>
</div>

<pre class="example">
000000000000036d s L_.str
00000000000003ad s L_.str1
00000000000003d0 s L_.str2
00000000000003eb s L_.str3
00000000000003f8 s L_.str4
0000000000000440 s L_.str5
000000000000046c s L_.str6
0000000000000473 s L_.str7
00000000000003ba s L___PRETTY_FUNCTION__.test_condition
000000000000042d s L___PRETTY_FUNCTION__.test_strcmp
                 U ___stack_chk_fail
                 U ___stack_chk_guard
00000000000005d0 b _condition
                 U _cut_assert_helper
0000000000000000 T _cut_setup
0000000000000010 T _cut_teardown
                 U _cut_test_context_current_peek
                 U _cut_test_context_finish_user_message_jump
                 U _cut_test_context_get_have_current_result
                 U _cut_test_context_get_jump_buffer
                 U _cut_test_context_in_user_message_jump
                 U _cut_test_context_long_jump
                 U _cut_test_context_pop_backtrace
                 U _cut_test_context_process_current_result
                 U _cut_test_context_push_backtrace
                 U _cut_test_context_set_jump_buffer
                 U _cut_test_context_set_user_message
                 U _cut_test_context_start_user_message_jump
                 U _setjmp
                 U _strcmp
0000000000000020 T _test_condition
00000000000001b0 T _test_strcmp
</pre>

<p>
test_first.o に入っている変数や関数，参照している関数情報などですね:
</p>
<ul class="org-ul">
<li>T は定義されている関数です
</li>
<li>U は参照している関数です
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-20-4" class="outline-3">
<h3 id="sec-20-4"><span class="section-number-3">20.4</span> ライブラリ・ファイルのこと</h3>
<div class="outline-text-3" id="text-20-4">
<p>
test_first.so をいろいろ調べてみましょう.
</p>

<p>
まずは，test_first.so が使用しているライブラリを調べてみます。
</p>

<div class="org-src-container">

<pre class="src src-sh"># [~/progs/cutter/test] % 
# test_first.soが使う動的ライブラリを表示するため，
# 次のコマンドを実行してください

ldd test_first.so
</pre>
</div>

<pre class="example">
linux-vdso.so.1 =&gt;  (0x00007fff1f595000)
libcutter.so.0 =&gt; /usr/lib/libcutter.so.0 (0x00007fc59afa4000)
libc.so.6 =&gt; /lib/x86_64-linux-gnu/libc.so.6 (0x00007fc59abdf000)
libgmodule-2.0.so.0 =&gt; /usr/lib/x86_64-linux-gnu/libgmodule-2.0.so.0 (0x00007fc59a9da000)
libgio-2.0.so.0 =&gt; /usr/lib/x86_64-linux-gnu/libgio-2.0.so.0 (0x00007fc59a667000)
libgobject-2.0.so.0 =&gt; /usr/lib/x86_64-linux-gnu/libgobject-2.0.so.0 (0x00007fc59a416000)
libglib-2.0.so.0 =&gt; /lib/x86_64-linux-gnu/libglib-2.0.so.0 (0x00007fc59a10d000)
libpthread.so.0 =&gt; /lib/x86_64-linux-gnu/libpthread.so.0 (0x00007fc599eef000)
/lib64/ld-linux-x86-64.so.2 (0x00007fc59b456000)
libdl.so.2 =&gt; /lib/x86_64-linux-gnu/libdl.so.2 (0x00007fc599ceb000)
libz.so.1 =&gt; /lib/x86_64-linux-gnu/libz.so.1 (0x00007fc599ad1000)
libselinux.so.1 =&gt; /lib/x86_64-linux-gnu/libselinux.so.1 (0x00007fc5998ae000)
libresolv.so.2 =&gt; /lib/x86_64-linux-gnu/libresolv.so.2 (0x00007fc599693000)
libffi.so.6 =&gt; /usr/lib/x86_64-linux-gnu/libffi.so.6 (0x00007fc59948a000)
libpcre.so.3 =&gt; /lib/x86_64-linux-gnu/libpcre.so.3 (0x00007fc59924c000)
</pre>

<p>
つぎに test_first.so の中に何が入っているか調べてみます:
</p>

<div class="org-src-container">

<pre class="src src-sh"># [~/progs/cutter/test] % 
# test_first.soで定義された，または参照している関数を表示するため，
# 次のコマンドを実行してください

nm test_first.so
</pre>
</div>
</div>
</div>
</div>


<div id="outline-container-sec-21" class="outline-2">
<h2 id="sec-21"><span class="section-number-2">21</span> テストの実行</h2>
<div class="outline-text-2" id="text-21">
<p>
作成したテストを実行します:
</p>

<div class="org-src-container">

<pre class="src src-sh"># [~/progs/cutter/] %
# test/ ディレクトリ中のテストを cutter で実行するために，
# 次のコマンドを実行してください
cutter -v v test/
</pre>
</div>

<div class="org-src-container">

<pre class="src src-sh">test_first:
  test_condition:                                       .: (0.000125)
  test_strcmp:                                          .: (0.000044)

Finished in 0.001260 seconds (total: 0.000169 seconds)

2 test(s), 2 assertion(s), 0 failure(s), 0 error(s), 0 pending(s), 0 omission(s), 0 notification(s)
100% passed
</pre>
</div>
</div>



<div id="outline-container-sec-21-1" class="outline-3">
<h3 id="sec-21-1"><span class="section-number-3">21.1</span> テスト結果 (成功)</h3>
<div class="outline-text-3" id="text-21-1">
<pre class="example">
test_first:
  test_condition:					.: (0.000062)
  test_strcmp:						.: (0.000025)

Finished in 0.000775 seconds (total: 0.000087 seconds)

2 test(s), 2 assertion(s), 0 failure(s), 0 error(s), 0 pending(s), 0 omission(s), 0 notification(s)
100% passed
</pre>

<p>
上のテスト結果の出力を要約すると:
</p>
<blockquote>
<p>
テストファイル test_first にある，ふたつのテスト関数 test_condition,
test_strcmp の中，ふたつの表明を実行し，失敗はありませんでした。
</p>
</blockquote>
<p>
詳しい結果の見方については，<a href="http://cutter.sourceforge.net/reference/ja/readme.html">はじめに: Cutterリファレンスマニュアル - Cutter</a> を読んでください。
</p>
</div>
</div>

<div id="outline-container-sec-21-2" class="outline-3">
<h3 id="sec-21-2"><span class="section-number-3">21.2</span> テスト結果 (失敗)</h3>
<div class="outline-text-3" id="text-21-2">
<p>
cut_assert の中の式を変えて，失敗する場合も試してみましょう。
</p>

<pre class="example">
test_first:
  test_condition:					F
=============================================================================================================================================================
Failure: test_condition
conditionの値はcut_setup()で1に設定されているはず
expected: &lt;condition==0&gt; is neither FALSE nor NULL
test_first.c:25: test_condition(): cut_assert(condition==0, )
=============================================================================================================================================================
: (0.000219)
  test_strcmp:						F
=============================================================================================================================================================
Failure: test_strcmp
同じ文字列に対し，strcmpは0を返すはず
expected: &lt;strcmp("string", "string")==1&gt; is neither FALSE nor NULL
test_first.c:32: test_strcmp(): cut_assert(strcmp("string", "string")==1, )
=============================================================================================================================================================
: (0.000096)

Finished in 0.000879 seconds (total: 0.000315 seconds)

2 test(s), 0 assertion(s), 2 failure(s), 0 error(s), 0 pending(s), 0 omission(s), 0 notification(s)
0% passed
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-22" class="outline-2">
<h2 id="sec-22"><span class="section-number-2">22</span> カード表示問題</h2>
<div class="outline-text-2" id="text-22">
</div><div id="outline-container-sec-22-1" class="outline-3">
<h3 id="sec-22-1"><span class="section-number-3">22.1</span> CardDisplay問題</h3>
<div class="outline-text-3" id="text-22-1">
</div>

<div id="outline-container-sec-22-1-1" class="outline-4">
<h4 id="sec-22-1-1">目的</h4>
<div class="outline-text-4" id="text-22-1-1">
<p>
トランプ・カードをプログラムしてみよう。プログラムするとはどういうこと
かについて，考える。トランプ・カードの機能とは何かを考える。
</p>

<ul class="org-ul">
<li>トランプ・カードをデータとして入力し，出力して実感する
</li>

<li>トランプ・カードを扱うことについて考える
</li>

<li>トランプカードの部品化について考える

<ul class="org-ul">
<li>*トランプカードのデータ構造*を考え，プログラム化する
</li>

<li>*トランプカードの機能*について考え，プログラム化する
</li>
</ul>
</li>

<li>ポーカーゲームのために利用することを想定し，プログラムの保守と更新につ
いて考える
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-22-1-2" class="outline-4">
<h4 id="sec-22-1-2">トランプ・カード表示問題</h4>
<div class="outline-text-4" id="text-22-1-2">
<p>
一枚のカードを表示するプログラム (card_display_simple) から始めて，
復数のトランプカードを表示 (card_display_multi) し，
復数のトランプカードをソートし，表示 (card_display_sort) する
プログラムへ変更していきます。
</p>

<p>
データをデータ構造にまとめたり，
機能を関数にまとめたり，することの意味を理解しましょう。
</p>
</div>

<div id="outline-container-sec-22-1-2-1" class="outline-5">
<h5 id="sec-22-1-2-1">card_display_simple 問題</h5>
<div class="outline-text-5" id="text-22-1-2-1">
<p>
コマンドラインからトランプカードの札種（スーツ）と番号を指定すると，
そのカードを表す文字列を表示するプログラムを作成する
</p>

<p>
例えば，プログラムへの入力と出力は，下記のようになる:
</p>

<pre class="example">
% card_display heart 10 
&gt; H0 	     # と表示される
% card_display spade 13 
&gt; SK 	     # と表示される
% card_display diamond 1 
&gt; DA 	     # と表示される
% card_display club 2
&gt; C2           # と表示される
</pre>
</div>
</div>

<div id="outline-container-sec-22-1-2-2" class="outline-5">
<h5 id="sec-22-1-2-2">card_display_multi 問題</h5>
<div class="outline-text-5" id="text-22-1-2-2">
<p>
複数のカードを指定して，そのカード達を表示する
</p>

<p>
但し，できるだけ card_display_simple プログラムを再利用すること
</p>

<pre class="example">
% card_display_multi heart 10 spade 13 diamond 1 club 2 は
&gt; H0 SK DA C2   # と表示される
</pre>
</div>
</div>

<div id="outline-container-sec-22-1-2-3" class="outline-5">
<h5 id="sec-22-1-2-3">card_display_sort 問題</h5>
<div class="outline-text-5" id="text-22-1-2-3">
<p>
複数のカードを入力し，ソートして表示するプログラム
</p>

<pre class="example">
% card_display_sort heart 10 spade 13 diamond 1 club 2
&gt; DA SK H0 C2    # と表示される
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-sec-22-2" class="outline-3">
<h3 id="sec-22-2"><span class="section-number-3">22.2</span> card_display_simple 問題への解法</h3>
<div class="outline-text-3" id="text-22-2">
<p>
大きな要求を，細かな機能への要求に分解していきましょう。
</p>
</div>

<div id="outline-container-sec-22-2-1" class="outline-4">
<h4 id="sec-22-2-1">card_display_simple 問題</h4>
<div class="outline-text-4" id="text-22-2-1">
<p>
コマンドラインからトランプカードの札種（スーツ）と番号を指定すると，
</p>

<p>
そのトランプカード（を表す文字列）を表示するプログラムを作成する
</p>
</div>
</div>

<div id="outline-container-sec-22-2-2" class="outline-4">
<h4 id="sec-22-2-2">プログラムの設計</h4>
<div class="outline-text-4" id="text-22-2-2">
</div><div id="outline-container-sec-22-2-2-1" class="outline-5">
<h5 id="sec-22-2-2-1">設計方針</h5>
<div class="outline-text-5" id="text-22-2-2-1">
<p>
もっとも難しく，大切なこと。*構造化プログラミング*とか，*抽象データ型*とか，
*オブジェクト指向設計*とか，いろいろある。
</p>

<p>
学問分野としては，ソフトウェア工学。
</p>

<p>
プログラムを正しく設計作成できるように，*プログラムの証明*という考
え方がある。
</p>

<p>
*モジュール*と*モジュール化*という考え方が基本（だと思う）。
</p>
</div>
</div>

<div id="outline-container-sec-22-2-2-2" class="outline-5">
<h5 id="sec-22-2-2-2">card_display_simple の設計</h5>
<div class="outline-text-5" id="text-22-2-2-2">
<p>
設計し易いよう，部分に分ける
</p>
<ul class="org-ul">
<li>全体の処理処理を，入力，処理，出力に分割し，
</li>
<li>分割できるように，いったん内部データ化する
<ul class="org-ul">
<li>入力は，文字列をカード型のデータにすること
</li>
<li>出力は，その逆
</li>
</ul>
</li>
</ul>

<p>
データを主に考えると，まとめやすいことが多い
</p>
<ul class="org-ul">
<li>トランプ・カードが主役
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-22-2-2-3" class="outline-5">
<h5 id="sec-22-2-2-3">入力と出力例と内部トランプ表現</h5>
<div class="outline-text-5" id="text-22-2-2-3">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="left" />

<col  class="left" />

<col  class="left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="left">入力値</th>
<th scope="col" class="left">プログラム内部表現</th>
<th scope="col" class="left">出力</th>
</tr>
</thead>
<tbody>
<tr>
<td class="left">"heart" "10"</td>
<td class="left">"heart”を表す整数値3 "10" を表す10</td>
<td class="left">"H0"</td>
</tr>

<tr>
<td class="left">"spade" "13"</td>
<td class="left">"spade”を表す整数値4 "13" を表す13</td>
<td class="left">"SK"</td>
</tr>

<tr>
<td class="left">"diamond" "1"</td>
<td class="left">"diamond”を表す整数値2 "1" を表す14</td>
<td class="left">"DA"</td>
</tr>

<tr>
<td class="left">"club" "1"</td>
<td class="left">"club”を表す整数値1 "2" を表す2</td>
<td class="left">"C2"</td>
</tr>
</tbody>
</table>
</div>
</div>

<div id="outline-container-sec-22-2-2-4" class="outline-5">
<h5 id="sec-22-2-2-4">スーツ入力文字列からスーツ内部表現へ</h5>
<div class="outline-text-5" id="text-22-2-2-4">
<p>
要求
</p>
<ul class="org-ul">
<li>スーツの強さ S&gt;H&gt;D&gt;C
</li>
</ul>

<p>
処理
</p>
<ul class="org-ul">
<li>入力文字列から整数への変換

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="left" />

<col  class="right" />
</colgroup>
<tbody>
<tr>
<td class="left">"spade"</td>
<td class="right">4</td>
</tr>

<tr>
<td class="left">"heart"</td>
<td class="right">3</td>
</tr>

<tr>
<td class="left">"diamond"</td>
<td class="right">2</td>
</tr>

<tr>
<td class="left">"club"</td>
<td class="right">1</td>
</tr>
</tbody>
</table>
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-22-2-2-5" class="outline-5">
<h5 id="sec-22-2-2-5">カードの数から内部表現へ</h5>
<div class="outline-text-5" id="text-22-2-2-5">
<p>
要求(ポーカの場合)
</p>
<ul class="org-ul">
<li>A&gt;K&gt;Q&gt;J&gt;10&gt;9&gt;8&gt;7&gt;6&gt;5&gt;4&gt;3&gt;2
</li>
</ul>

<p>
処理
</p>
<ul class="org-ul">
<li>"1"は14に，
</li>
<li>残りはそのまま文字列を整数へ
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-22-2-2-6" class="outline-5">
<h5 id="sec-22-2-2-6">カードを作る</h5>
<div class="outline-text-5" id="text-22-2-2-6">
<p>
要求
</p>
<ul class="org-ul">
<li>スーツの内部表現と数字の内部表現から，
</li>
<li>カードを表すデータを作る
</li>
<li>カードデータからそのスーツが分かること
</li>
<li>カードデータからその数字が分かること
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-22-2-2-7" class="outline-5">
<h5 id="sec-22-2-2-7">カードの内部表現を文字列へ</h5>
<div class="outline-text-5" id="text-22-2-2-7">
<p>
設計
</p>
<ul class="org-ul">
<li>2文字からなるの文字列
</li>
<li>スーツは 'S', 'H', 'D', 'C',  1文字
</li>
<li>数は 'A','K','Q','J','0','9','8','7','6','5','4','3','2'，1文字
</li>
</ul>

<p>
処理
</p>
<ul class="org-ul">
<li>スーツや数を添字に配列を参照する
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-22-2-2-8" class="outline-5">
<h5 id="sec-22-2-2-8">関数の名前</h5>
<div class="outline-text-5" id="text-22-2-2-8">
<p>
この講義では，基本，対象とするデータの型，データの属性，データの処理を下線でつな
げて命名することにする。
</p>

<p>
名前づけの一貫性と分かり易さが大切。
</p>
</div>

<div id="outline-container-sec-22-2-2-8-1" class="outline-6">
<h6 id="sec-22-2-2-8-1">スーツ入力文字列からスーツ内部表現へ</h6>
<div class="outline-text-6" id="text-22-2-2-8-1">
<p>
card_suit_new_from_string
</p>
</div>
</div>

<div id="outline-container-sec-22-2-2-8-2" class="outline-6">
<h6 id="sec-22-2-2-8-2">カードの数から内部表現へ</h6>
<div class="outline-text-6" id="text-22-2-2-8-2">
<p>
card_no_new_from_string
</p>
</div>
</div>

<div id="outline-container-sec-22-2-2-8-3" class="outline-6">
<h6 id="sec-22-2-2-8-3">カードを作る</h6>
<div class="outline-text-6" id="text-22-2-2-8-3">
<p>
card_new
</p>

<p>
カードはその属性としてスーツ(suit)と番号(no)をもつ
</p>

<ul class="org-ul">
<li>カードデータからそのスーツが分かること

<p>
card_suit
</p>
</li>

<li>カードデータからその数字が分かること

<p>
card_no
</p>
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-22-2-2-8-4" class="outline-6">
<h6 id="sec-22-2-2-8-4">カードの内部表現を文字列へ</h6>
<div class="outline-text-6" id="text-22-2-2-8-4">
<p>
card_to_string
</p>
<ul class="org-ul">
<li>card_suit_to_string
</li>
<li>card_no_to_string
</li>
</ul>
</div>
</div>
</div>


<div id="outline-container-sec-22-2-2-9" class="outline-5">
<h5 id="sec-22-2-2-9">関数の引数と戻り値の型 (APIの設計)</h5>
<div class="outline-text-5" id="text-22-2-2-9">
<ul class="org-ul">
<li>int card_suit_new_from_string(char *);
</li>
<li>int card_no_new_from_string(char *);
</li>
<li>Card card_new(int suit, int no);
<ul class="org-ul">
<li>int card_suit(Card);
</li>
<li>int card_no(Card);
</li>
</ul>
</li>
<li>char *card_to_string(Card);
<ul class="org-ul">
<li>char *card_suit_to_string(int suit);
</li>
<li>char *card_no_to_string(int no);
</li>
</ul>
</li>
</ul>
</div>
</div>
</div>


<div id="outline-container-sec-22-2-3" class="outline-4">
<h4 id="sec-22-2-3">card_display_simple 問題のテストによる開発</h4>
<div class="outline-text-4" id="text-22-2-3">
<p>
前章の設計を頭に入れて，プログラムの開発にとりかかりましょう。
</p>

<p>
テストによる開発に関しては別ドキュメントにしましたので，
<a href="http://wiki.cis.iwate-u.ac.jp/~suzuki/lects/prog/org-docs/tdd-card-display-simple/">カード表示問題_simpleのテストによる開発</a> ((<a href="file:///home/staff/suzuki/lects/prog/org-docs/tdd-card-display-simple/">@cis.org</a> <a href="file:///home/staff/suzuki/COMM/Lects/prog/site/org-docs/tdd-card-display-simple/">@s.org</a>)) こちらを読んでください。
</p>
</div>


<div id="outline-container-sec-22-2-3-1" class="outline-5">
<h5 id="sec-22-2-3-1">テストによる開発から設計へのフィードバック</h5>
<div class="outline-text-5" id="text-22-2-3-1">
<p>
スーツと番号のデータ構造に設計上の下記の変更がありました:
</p>

<pre class="example">
enum e_Suit card_suit_new_from_string (char *)
enum e_No card_no_new_from_string (char *)
</pre>
</div>
</div>

<div id="outline-container-sec-22-2-3-2" class="outline-5">
<h5 id="sec-22-2-3-2">card_display_simple の解</h5>
<div class="outline-text-5" id="text-22-2-3-2">
<p>
このプログラムの作成はレポート問題の一部になりましたので，
自分で考えて，作成してください。
</p>

<p>
card_display_multi の解の例
</p>

<div class="org-src-container">

<pre class="src src-c">#include &lt;stdio.h&gt;
#include &lt;card.h&gt;

int
main(int argc, char *argv[])
{
  Card cards[MaxCards];
  int no_cards = 0;

  for(i=0; i&lt;argc; i++)
    {
      cards[i] = card_new(card_suit_new_from_string(argv[i]++),
			  card_no_new_from_string(argv[i]++));
      no_cards++;
    }
  for(i=0; i&lt;no_cards; i++)
    {
      printf("%s ", card_to_string(cards[i]));
    }
  return 0;
}
</pre>
</div>

<p>
上記プログラムで，下記の部分はカードの構造が見え，生々しい気がします:
</p>
<div class="org-src-container">

<pre class="src src-c">cards[i] = card_new(card_suit_new_from_string(argv[i]++),
		    card_no_new_from_string(argv[i]++));
</pre>
</div>

<p>
card_to_stringと同じレベルで反対の機能 card_new_from_string がいい設計
かもしれません。
</p>

<pre class="example">
Card card_new_from_string(char *suit_str, char *no_str);
</pre>

<p>
を定義すれば，プログラム全体は下記のようになります:
</p>

<div class="org-src-container">

<pre class="src src-c">#include &lt;stdio.h&gt;
#include &lt;card.h&gt;

int
main(int argc, char *argv[])
{
  Card cards[MaxCards];
  int no_cards = 0;

  for(i=0; i&lt;argc; i++)
    {
      cards[i] = card_new_from_string(argv[i]++，argv[i]++);
      no_cards++;
    }
  for(i=0; i&lt;no_cards; i++)
    {
      printf("%s ", card_to_string(cards[i]));
    }
  return 0;
}
</pre>
</div>

<p>
こうすることで，入力 (card_new_from_string) と 出力 (card_to_string)
が対称的になり，
</p>

<p>
この設計変更を受け入れれば，card_new_from_string を開発することになり
ます。
</p>
</div>
</div>
</div>

<div id="outline-container-sec-22-2-4" class="outline-4">
<h4 id="sec-22-2-4">card_display_sort (準備中@<span class="timestamp-wrapper"><span class="timestamp">&lt;2015-12-01 火&gt;</span></span>)</h4>
<div class="outline-text-4" id="text-22-2-4">
</div><div id="outline-container-sec-22-2-4-1" class="outline-5">
<h5 id="sec-22-2-4-1">複数のカードをソートする機能</h5>
<div class="outline-text-5" id="text-22-2-4-1">
<p>
一枚のカードの機能をもとに，
</p>

<pre class="example">
Card * cards_sort(Card *，int)
</pre>

<p>
を開発しましょう。
</p>

<div class="org-src-container">

<pre class="src src-c">#include &lt;stdio.h&gt;
#include &lt;card.h&gt;

int
main(int argc, char *argv[])
{
  Card cards[MaxCards];
  int no_cards = 0;

  for(i=0; i&lt;argc; i++)
    {
      cards[i] = card_new_from_string(argv[i]++，argv[i]++);
      no_cards++;
    }

  card_cards_sort(cards);

  for(i=0; i&lt;no_cards; i++)
    {
      printf("%s ", card_to_string(cards[i]));
    }
  return 0;
}
</pre>
</div>
</div>
</div>
</div>
</div>

<div id="outline-container-sec-22-3" class="outline-3">
<h3 id="sec-22-3"><span class="section-number-3">22.3</span> card_display_multi 問題への解法</h3>
<div class="outline-text-3" id="text-22-3">
</div><div id="outline-container-sec-22-3-1" class="outline-4">
<h4 id="sec-22-3-1">card_display_multi</h4>
<div class="outline-text-4" id="text-22-3-1">
<p>
card_display_multi の解の例
</p>

<div class="org-src-container">

<pre class="src src-c">#include &lt;stdio.h&gt;
#include &lt;card.h&gt;

int
main(int argc, char *argv[])
{
  Card cards[MaxCards];
  int no_cards = 0;

  for(i=0; i&lt;argc; i++)
    {
      cards[i] = card_new(card_suit_new_from_string(argv[i]++),
			  card_no_new_from_string(argv[i]++));
      no_cards++;
    }
  for(i=0; i&lt;no_cards; i++)
    {
      printf("%s ", card_to_string(cards[i]));
    }
  return 0;
}
</pre>
</div>

<p>
上記プログラムで，下記の部分はカードの構造が見え，生々しい気がします:
</p>
<div class="org-src-container">

<pre class="src src-c">cards[i] = card_new(card_suit_new_from_string(argv[i]++),
		    card_no_new_from_string(argv[i]++));
</pre>
</div>

<p>
card_to_stringと同じレベルで反対の機能 card_new_from_string がいい設計
かもしれません。
</p>

<pre class="example">
Card card_new_from_string(char *suit_str, char *no_str);
</pre>

<p>
を定義すれば，プログラム全体は下記のようになります:
</p>

<div class="org-src-container">

<pre class="src src-c">#include &lt;stdio.h&gt;
#include &lt;card.h&gt;

int
main(int argc, char *argv[])
{
  Card cards[MaxCards];
  int no_cards = 0;

  for(i=0; i&lt;argc; i++)
    {
      cards[i] = card_new_from_string(argv[i]++，argv[i]++);
      no_cards++;
    }
  for(i=0; i&lt;no_cards; i++)
    {
      printf("%s ", card_to_string(cards[i]));
    }
  return 0;
}
</pre>
</div>

<p>
こうすることで，入力 (card_new_from_string) と 出力 (card_to_string)
が対称的になり，
</p>

<p>
この設計変更を受け入れれば，card_new_from_string を開発することになり
ます。
</p>
</div>
</div>
</div>

<div id="outline-container-sec-22-4" class="outline-3">
<h3 id="sec-22-4"><span class="section-number-3">22.4</span> card_display_sort 問題への解法</h3>
<div class="outline-text-3" id="text-22-4">
</div><div id="outline-container-sec-22-4-1" class="outline-4">
<h4 id="sec-22-4-1">card_display_sort (準備中@<span class="timestamp-wrapper"><span class="timestamp">&lt;2015-12-01 火&gt;</span></span>)</h4>
<div class="outline-text-4" id="text-22-4-1">
</div><div id="outline-container-sec-22-4-1-1" class="outline-5">
<h5 id="sec-22-4-1-1">複数のカードをソートする機能</h5>
<div class="outline-text-5" id="text-22-4-1-1">
<p>
一枚のカードの機能をもとに，
</p>

<pre class="example">
Card * cards_sort(Card *，int)
</pre>

<p>
を開発しましょう。
</p>

<div class="org-src-container">

<pre class="src src-c">#include &lt;stdio.h&gt;
#include &lt;card.h&gt;

int
main(int argc, char *argv[])
{
  Card cards[MaxCards];
  int no_cards = 0;

  for(i=0; i&lt;argc; i++)
    {
      cards[i] = card_new_from_string(argv[i]++，argv[i]++);
      no_cards++;
    }

  cards_sort(cards);

  for(i=0; i&lt;no_cards; i++)
    {
      printf("%s ", card_to_string(cards[i]));
    }
  return 0;
}
</pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div id="outline-container-sec-23" class="outline-2">
<h2 id="sec-23"><span class="section-number-2">23</span> カード表示問題_simpleのテストによる開発</h2>
<div class="outline-text-2" id="text-23">
</div>
</div>

<div id="outline-container-sec-24" class="outline-2">
<h2 id="sec-24"><span class="section-number-2">24</span> はじめに</h2>
<div class="outline-text-2" id="text-24">
<p>
テスト駆動開発の例として，card_display_simple問題を
テスト駆動開発してましょう。
</p>

<p>
その上で，わずかな変更を加えることで，card_display_multi 問題と，
card_display_sort 問題を，テスト駆動開発してましょう。
</p>

<p>
そして，その開発を通して，カードモジュールが出来上がることを実感して
みましょう。
</p>
</div>
</div>

<div id="outline-container-sec-25" class="outline-2">
<h2 id="sec-25"><span class="section-number-2">25</span> ディレクトリ構成</h2>
<div class="outline-text-2" id="text-25">
<p>
まず、プログラムを作成するためのディレクトリを用意する。ディレクトリは
simple/ とする。
</p>

<div class="org-src-container">

<pre class="src src-sh"># ~/
mkdir -p ~/progs/card_display/simple
cd ~/progs/card_display/simple
pwd
</pre>
</div>

<p>
続いて、simple/ ディレクトリ以下に，プログラム用ディレクトリ src/，テストプログラム用
ディレクトリ test/ を作成する。
</p>

<div class="org-src-container">

<pre class="src src-sh"># ~/progs/card_display/simple
mkdir -p src test
</pre>
</div>

<p>
つまり、ディレクトリ構成は以下のようになる。
</p>

<pre class="example">
simple/ --+- src/  ソースファイル用ディレクトリ
          |
          +- test/ テストプログラム用ディレクトリ
</pre>
</div>
</div>

<div id="outline-container-sec-26" class="outline-2">
<h2 id="sec-26"><span class="section-number-2">26</span> Makefileを作る</h2>
<div class="outline-text-2" id="text-26">
<p>
simple/ ディレクトリに Makefileを作成します。
目的は二つ，カードのテストをすることと，ディレクトリ配下をきれいにするこ
とです。
</p>

<div class="org-src-container">

<pre class="src src-makefile"># ~/progs/card_display/simple/Makefile
.PHONY: clean card_test

card_test:
	(cd src; make)
	(cd test; make) 
	cutter -v v test/

clean:
	(cd src; make clean)
	(cd test; make clean)
	rm -f *.o *.so *~ \#* .gch
</pre>
</div>

<p>
src/Makefileを作ります。まずの目的は，src/ディレクトリをきれいにすることで
す:
</p>

<div class="org-src-container">

<pre class="src src-makefile"># src/Makefile
.PHONY: clean 

clean:
	rm -f *.o *.so *~ \#* *.gch
</pre>
</div>

<p>
test/Makefileを作ります: 同様にまずの目的は，test/ディレクトリをきれ
いにすることです:
</p>

<div class="org-src-container">

<pre class="src src-makefile"># test/Makefile
.PHONY: clean 

clean:
	rm -f *.o *.so *~ \#* *.gch
</pre>
</div>

<p>
では，Makefile が正しく書けているか確かめるために make してみましょう。
</p>

<div class="org-src-container">

<pre class="src src-sh"># ~/progs/card_display/simple/
make
</pre>
</div>

<p>
それぞれのディレクトリで make clean して，空のテストをします:
</p>

<p>
最初のテストは，成功です。開発とテストに必要なディレクトリ，Makefile を
作成し，空のテストを行いました。
</p>
</div>
</div>

<div id="outline-container-sec-27" class="outline-2">
<h2 id="sec-27"><span class="section-number-2">27</span> 開発を機能に分ける</h2>
<div class="outline-text-2" id="text-27">
<p>
さて次は，card_display_simpleを，機能に分け，機能をテストしな
がら開発します。(<a href="card-display/">card-display/</a>)
</p>

<p>
下記の機能に分けてみます:
</p>

<ol class="org-ol">
<li>スーツを数値にする機能，
</li>
<li>トランプ番号を数値にする機能，
</li>
<li>トランプ・カード型を表す機能，
</li>
<li>スーツと番号からトランプカードを作成する機能
</li>
<li>トランプ・カードを文字列で表す機能。
</li>
</ol>


<p>
これらの機能を組み合わせてcard_display_simpleプログラムが開発できま
す。
</p>

<p>
実は，この機能分けが一番重要かもしれません。最初から全ての機能が取り
出せなくてもいいと思います。必要そうな機能を一つづつためしてもいいで
す。自分で丁度いいと思うことが大切です。
</p>
</div>
</div>

<div id="outline-container-sec-28" class="outline-2">
<h2 id="sec-28"><span class="section-number-2">28</span> 機能のテスト駆動開発 (概論)</h2>
<div class="outline-text-2" id="text-28">
<p>
これらの機能をひとつづつ確かめながら開発を進めるのが，テスト駆動開
発です。具体的な開発を進める前に，おおまかな流れを説明します。
</p>

<p>
進め方は:
</p>

<dl class="org-dl">
<dt> Makefileの作成 </dt><dd>テストと実装をビルドし，テストを実行するための
Makefile を書く。

<p>
./Makefile には src/, test/ でビルドするルールを書き，
cutter によりテストを実行する規則を書く。
</p>
</dd>

<dt> test/Makefileの作成 </dt><dd>テストをビルドするための規則を書く。

<p>
test/Makefile に test_card.c から test_card.so を作成し，
cutter によるテストの実行するための規則を書く。
</p>
</dd>

<dt> 機能テストの作成 </dt><dd>機能が正しく働くことを確かめるテスト (プログラム) を書く。このこ
とにより，*機能の使い方*を決める。

<p>
test/test_card.c に上の5つの機能テストを作成していく。
</p>
</dd>

<dt> テスト(のみ)のビルド </dt><dd>ビルドし，コンパイル・エラーが取れ，確かめ
る機能の関数のみが未定義の状態にする。
</dd>

<dt> src/Makefile </dt><dd>機能の実装をビルドするための規則を書く。

<p>
src/Makefile に card.c, card.h から libcard.a を
作成する規則を書く。
</p>
</dd>

<dt> インタフェースの決定 </dt><dd>確かめる機能の関数を使うために必要最小限
のインタフェースを決める。

<p>
test/test_card.c から取り出し，src/card.h に書く。
</p>
</dd>

<dt> 機能の実装 </dt><dd>インタフェースに従がい，機能を関数として実装する。

<p>
src/card.c を作成する。
</p>
</dd>

<dt> 機能の提供 </dt><dd>実装をビルドし，ライブラリとヘッダファイルで機能を提
供する。

<p>
src/Makefile にルールを書き，
src/libcard.aを作成する。
</p>
</dd>

<dt> テストのビルドと実行 </dt><dd></dd>
</dl>

<p>
では，続く節で，5つの機能のテスト駆動開発をおこないます。
</p>
</div>
</div>

<div id="outline-container-sec-29" class="outline-2">
<h2 id="sec-29"><span class="section-number-2">29</span> スーツを数値にする機能のテストと実装</h2>
<div class="outline-text-2" id="text-29">
<p>
まず最初は，文字列で表されたスーツを，プログラム内部での数値に変換す
る機能のテストです。
</p>

<p>
あわせてテスト等のビルドのためMakefileを作成していきます。
</p>
</div>

<div id="outline-container-sec-29-1" class="outline-3">
<h3 id="sec-29-1"><span class="section-number-3">29.1</span> テスト作成</h3>
<div class="outline-text-3" id="text-29-1">
<p>
テストは，test/test_card.c に作成します。
</p>

<p>
機能の名前を card_suit_new_from_string とし,
card_suit_new_from_string のAPIを決めるため，
card_suit_new_from_string が満たすテストを書きます:
</p>

<div class="org-src-container">

<pre class="src src-c">// test/test_card.c
  cut_assert(card_suit_new_from_string("SPADE")==SPADE);
</pre>
</div>

<p>
cut_assert は引数の値が真ならばテスト成功，偽ならばテスト失敗
とする cutter の機能です。失敗のときは，情報を提供してくれます。
</p>

<p>
card_suit_new_from_stringを関数の形で書けたので，関数の型を決めま
す。
</p>

<p>
戻り値の型は int，与える引数はスーツを示す文字列なので:
</p>

<div class="org-src-container">

<pre class="src src-c">int card_suit_new_from_string(char *);
</pre>
</div>

<p>
そして，cutterが提供する機能を使うためのインタフェースをインクルー
ドします:
</p>

<div class="org-src-container">

<pre class="src src-c"># include &lt;cutter.h&gt;
</pre>
</div>

<p>
テストに使う定数は，列挙型 (<a href="https://ja.wikipedia.org/wiki/%E5%88%97%E6%8C%99%E5%9E%8B">列挙型 - Wikipedia</a>) で書いてみます:
</p>

<div class="org-src-container">

<pre class="src src-c" id="suit_new_e_suit">enum e_Suit {CLUB=1, DIAMOND, HEART, SPADE};
</pre>
</div>
<p>
まだ列挙型を使かったことがないかもしれませんが，便利なので憶えましょ
う。これは，define で定義する次のコードと似ています:
</p>
<div class="org-src-container">

<pre class="src src-c"># define SPADE 4
# define HEART 3
# define DIAMOND 2
# define CLUB 1
</pre>
</div>

<p>
次に，テストに必要なことを記述します:
</p>

<ul class="org-ul">
<li>テスト・フレームワークとして cutter を使うので，必要な宣言をインク
ルードする:
</li>
</ul>

<div class="org-src-container">

<pre class="src src-c">// test/test_card.c
# include &lt;cutter.h&gt;
</pre>
</div>

<ul class="org-ul">
<li>テストを関数にする。cutterからの要請で，関数名は test_ で始まる
名前で，型は，void (void) です:
</li>
</ul>

<div class="org-src-container">

<pre class="src src-c">// test/test_card.c
void
test_card_suit_new_from_string(void)
{
  cut_set_message("文字列からスーツを作成する。");
  cut_assert_true(card_suit_new_from_string("SPADE")==SPADE);
}
</pre>
</div>

<p>
これだけです。
</p>

<p>
ここまでで，test/test_card.c の中身は:
</p>

<div class="org-src-container">

<pre class="src src-c">// test/test_card.c
# include &lt;cutter.h&gt;

enum e_Suit {CLUB=1, DIAMOND, HEART, SPADE};

enum e_Suit card_suit_new_from_string(char *);

void
test_card_suit_new_from_string(void)
{
  cut_set_message("文字列からスーツを作成する。");
  cut_assert_true(card_suit_new_from_string("SPADE")==SPADE);
}
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-29-2" class="outline-3">
<h3 id="sec-29-2"><span class="section-number-3">29.2</span> test/Makefileの作成</h3>
<div class="outline-text-3" id="text-29-2">
<p>
test/Makefile は，とりあえず，test_card.c をコンパイルするこ
とです:
</p>

<p>
Makefileに次のように規則を書き加えます:
</p>

<div class="org-src-container">

<pre class="src src-makefile"># test/Makefile
test_card.o: test_card.c
	gcc -c $&lt;
</pre>
</div>

<p>
test_card.c がインクルードしている cutter.h がどこにあるのかは，次
のコマンドを実行するとわかります:
</p>

<div class="org-src-container">

<pre class="src src-sh"># ~/progs/CardDisplay/simple/
pkg-config cutter --cflags
</pre>
</div>

<pre class="example">
-I/usr/include/cutter  
</pre>


<p>
cutter.hをインクルードするためのコンパイラへの指示が出力されていま
す。
</p>

<p>
これをMakefileに記述します:
</p>

<div class="org-src-container">

<pre class="src src-makefile"># test/Makefile
.PHONY: clean 
CFLAGS = -fPIC `pkg-config cutter --cflags`

test_card.o: test_card.c
	gcc -c $&lt; $(CFLAGS)

clean:
	rm -f *.o *.so *~ \#* *.gch
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-29-3" class="outline-3">
<h3 id="sec-29-3"><span class="section-number-3">29.3</span> 最初の make</h3>
<div class="outline-text-3" id="text-29-3">
<p>
test/{test_card.c, Makefile}ができたので，make してみましょう:
</p>

<div class="org-src-container">

<pre class="src src-sh"># ~/progs/card_display/simple/test
make clean
make test_card.o
</pre>
</div>

<pre class="example">
rm -f *.o *.so *~ \#* *.gch
gcc -c test_card.c -fPIC -I../src `pkg-config cutter --cflags`
</pre>

<p>
コンパイルが成功し，test/test_card.o ができていれば，
test/test_card.o の中身を見てみましょう:
</p>

<div class="org-src-container">

<pre class="src src-sh"># ~/progs/card_display/simple/test
nm test_card.o
</pre>
</div>

<pre class="example">
                 U _GLOBAL_OFFSET_TABLE_
0000000000000200 r __PRETTY_FUNCTION__.3239
                 U _setjmp
                 U card_suit_new_from_string
                 U cut_assert_helper
                 U cut_test_context_current_peek
                 U cut_test_context_finish_user_message_jump
                 U cut_test_context_get_have_current_result
                 U cut_test_context_get_jump_buffer
                 U cut_test_context_in_user_message_jump
                 U cut_test_context_long_jump
                 U cut_test_context_pop_backtrace
                 U cut_test_context_process_current_result
                 U cut_test_context_push_backtrace
                 U cut_test_context_set_jump_buffer
                 U cut_test_context_set_user_message
                 U cut_test_context_start_user_message_jump
0000000000000000 T test_card_suit_new_from_string
</pre>

<p>
card_suit_from_string, cut_assert が未定義で，
test_card_suit_new_from_string が定義されているのがわかります。
</p>
</div>
</div>

<div id="outline-container-sec-29-4" class="outline-3">
<h3 id="sec-29-4"><span class="section-number-3">29.4</span> cutterによるテスト</h3>
<div class="outline-text-3" id="text-29-4">
<p>
cutter でテストしてみましょう:
</p>

<div class="org-src-container">

<pre class="src src-sh">cutter -v v test
</pre>
</div>

<pre class="example">
Finished in 0.000062 seconds (total: 0.000000 seconds)

0 test(s), 0 assertion(s), 0 failure(s), 0 error(s), 0 pending(s), 0 omission(s), 0 notification(s)
0% passed
</pre>

<p>
test(s)が0と表示されているので， test_card.oはテストとして認識され
ていないことが分かります。
</p>
</div>
</div>

<div id="outline-container-sec-29-5" class="outline-3">
<h3 id="sec-29-5"><span class="section-number-3">29.5</span> テストのビルド</h3>
<div class="outline-text-3" id="text-29-5">
<p>
cutter は，test_ で始まる動的ライブラリをテストと認めます。なので動的ライ
ブラリを作ります。そのために test/Makefileに規則を追加します:
</p>

<div class="org-src-container">

<pre class="src src-Makefile"># test/Makefile

CFLAGS = -fPIC `pkg-config cutter --cflags` 
LDFLAGS = `pkg-config --libs cutter`

test_card.so: test_card.o
	gcc -o $@ --shared $^ $(LDFLAGS)
</pre>
</div>

<p>
gcc に対するオプション -fPIC とか &#x2013;shared は動的ライブラリを作る
ためのものです。
</p>

<p>
ここまでで test/Makefile 全体は下記のようになります:
</p>

<div class="org-src-container">

<pre class="src src-makefile"># test/Makefile (2)
.PHONY: clean
CFLAGS = -fPIC `pkg-config cutter --cflags` 
LDFLAGS = `pkg-config --libs cutter`

test_card.so: test_card.o       
	gcc -o $@ --shared $^ $(LDFLAGS)

test_card.o: test_card.c
	gcc -c $&lt; $(CFLAGS)

clean:
	rm -f *.o *.so *~ \#* *.gch
</pre>
</div>

<p>
.soは動的ライブラリを示す拡張子で，gccへのオプション &#x2013;shared が動
的ライブラリの作成を意味しています。
</p>

<p>
変数LDFLAGSに，ローダへの指示を格納します。pkg-configは，システム
に組み込まれたパッケージの設定を見るためのコマンドで，&#x2013;libs は，
ライブラリとして使う場合のローダへの指示を出力してくれます:
</p>

<div class="org-src-container">

<pre class="src src-sh">pkg-config --libs cutter
</pre>
</div>

<p>
シェルコマンド中では，コマンドを``で括ることで，そのコマンドの実行
結果をその場所に埋め込むことを意味します。
</p>

<p>
変数LDFLAGS中の `pkg-config &#x2013;libs cutter`は，gcc コマンド 
中で参照されることで，cutterライブラリをリンクするため指示を埋め込
むことができます。
</p>

<p>
では，makeしてテストをビルドしてみましょう:
</p>

<p>
card_suit_new_from_string関数がまだ実装されていないため，みつから
ない旨のエラーが出て，test_card.so を作るための make は失敗します。
が，前進しています。cutterが提供する関数への参照は全て解決され，ま
だ未実装の card_suit_new_from_string のみ未解決となっていることを
理解してください。
</p>
</div>
</div>

<div id="outline-container-sec-29-6" class="outline-3">
<h3 id="sec-29-6"><span class="section-number-3">29.6</span> card_suit_new_from_string の実装</h3>
<div class="outline-text-3" id="text-29-6">
<p>
さて次は，機能 card_suit_new_from_string の実装です。
以下のように実装しましょう:
</p>
<ul class="org-ul">
<li>test/test_card.c を作成するときに決めたインタフェースをとりだし，
src/card.hを作成する。
</li>
<li>test/test_card.c の対応部分は # include &lt;card.h&gt; とする。
<ul class="org-ul">
<li>test/Makefile も変更する
</li>
</ul>
</li>
<li>src/card.hを遵守し，src/card.c を作成する。
</li>
<li>提供する機能を入れた src/libcard.a を作成する，Makefileを作成す
る
</li>
</ul>

<p>
<b>src/{card.h，libcard.a} で機能を提供します</b>
</p>
</div>

<div id="outline-container-sec-29-6-1" class="outline-4">
<h4 id="sec-29-6-1">src/card.h の作成 <code>card/card.h</code></h4>
<div class="outline-text-4" id="text-29-6-1">
<p>
test/test_card.c から card_suit_new_from_string に関する宣言を取り出し， 
src/card.h にします。
</p>

<div class="org-src-container">

<pre class="src src-c">// src/card.h
enum e_Suit {CLUB=1,DIAMOND,HEART,SPADE};

enum e_Suit card_suit_new_from_string(char *);
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-29-6-2" class="outline-4">
<h4 id="sec-29-6-2">test/test_card.cの変更</h4>
<div class="outline-text-4" id="text-29-6-2">
<p>
インタフェースの定義を，src/card.h に移し，定義の責任を src/ に移
します。test/ は，責任者の定義に従うという意味で，ヘッダファイル
をインクルードします:
</p>

<div class="org-src-container">

<pre class="src src-c">// test/test_card.c
# include &lt;card.h&gt;
</pre>
</div>

<p>
&lt;card.h&gt; は， コンパイラのインクルード・パス上の card.h という名前
のファイルを意味します。今 test/test_card.c にとって，&lt;card.h&gt; は
../src/card.h を意味します。ですが，次のように書いてはいけません:
</p>

<div class="org-src-container">

<pre class="src src-c"># include "../src/card.h"
</pre>
</div>

<p>
test/test_card.c は，下記のようになります:
</p>

<div class="org-src-container">

<pre class="src src-c">// test/test_card.c
# include &lt;cutter.h&gt;
# include &lt;card.h&gt;

void
test_card_suit_new_from_string(void)
{
  cut_set_message("文字列からスーツを作成する。");
  cut_assert(card_suit_new_from_string("SPADE")==SPADE);
  cut_assert(card_suit_new_from_string("HEART")==HEART);
  cut_assert(card_suit_new_from_string("DIAMOND")==DIAMOND);
  cut_assert(card_suit_new_from_string("CLUB")==CLUB);
}
</pre>
</div>

<p>
ここで，説明を簡略化するため，HEART, DIAMOND, CLUB のテストも追加してしま
いましたが，本来はひとつテストが通ってから，増やしていくべきです。
</p>
</div>
</div>

<div id="outline-container-sec-29-6-3" class="outline-4">
<h4 id="sec-29-6-3">test/Makefileの変更</h4>
<div class="outline-text-4" id="text-29-6-3">
<p>
src/card.hがインクルードできるようにインクルードパスをコンパイラに
指示します。具体的には，CFLAGSを以下のように書き換えます:
</p>

<div class="org-src-container">

<pre class="src src-make">CFLAGS = -fPIC -I../src `pkg-config cutter --cflags`
</pre>
</div>

<p>
変更後，makeして，以前と同じ状態であることを確かめておきましょう。
</p>
</div>
</div>

<div id="outline-container-sec-29-6-4" class="outline-4">
<h4 id="sec-29-6-4">src/card.c の作成</h4>
<div class="outline-text-4" id="text-29-6-4">
<p>
src/card.h に書かれている API を守って，card_suit_new_from_string
関数を実装します。
</p>

<p>
取り敢えず，与えられた文字列 suit_str と，スーツ文字列を比較して判
定することにします。
</p>

<div class="org-src-container">

<pre class="src src-c">// src/card.c
# include &lt;string.h&gt;
# include &lt;card.h&gt;

enum e_Suit
card_suit_new_from_string(char *suit_str)
{
  if (strcmp("CLUB", suit_str)==0)
    return CLUB;
  if (strcmp("DIAMOND", suit_str)==0)
    return DIAMOND;
  if (strcmp("HEART", suit_str)==0)
    return HEART;
  if (strcmp("SPADE", suit_str)==0)
    return SPADE;
  return 0;
}
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-29-6-5" class="outline-4">
<h4 id="sec-29-6-5">src/Makefile</h4>
<div class="outline-text-4" id="text-29-6-5">
<p>
src/card.c をコンパイルし，src/libcard.a を作成する規則を追加しま
しょう:
</p>

<div class="org-src-container">

<pre class="src src-makefile"># src/Makefile 
.PHONY: clean
CFLAGS = -g -c -fPIC -I. 
LDFLAGS = -lc

libcard.a: card.o
	rm -f $@
	ar r $@ $^

card.o: card.c card.h
	gcc $&lt; $(CFLAGS)

clean: 
	rm -f *.o *.so *~ \#* *.gch
</pre>
</div>

<p>
ビルドしてみましょう:
</p>

<div class="org-src-container">

<pre class="src src-sh"># ~/progs/card_display/simple/src
make clean
make libcard.a
</pre>
</div>

<pre class="example">
rm -f *.o *.so *~ \#* *.gch
gcc card.c -g -c -fPIC -I. 
rm -f libcard.a
ar r libcard.a card.o
</pre>

<p>
src/card.h と src/card.c に文法上のエラーや宣言上の食い違いがなけれ
あば，card.o ができているはずです。
</p>

<p>
card.o ができて，Makefile に間違いがなければ libcard.a もできている
はずです。
</p>

<p>
libcard.a の中身を確かめて，card_suit_new_from_string 関数が入ってい
るか，確かめてみましょう:
</p>

<div class="org-src-container">

<pre class="src src-sh"># ~/progs/card_display/simple/src
nm libcard.a
</pre>
</div>

<pre class="example">
card.o:
                 U _GLOBAL_OFFSET_TABLE_
0000000000000000 T card_suit_new_from_string
                 U strcmp
</pre>
</div>
</div>

<div id="outline-container-sec-29-6-6" class="outline-4">
<h4 id="sec-29-6-6">テスト test/test_card.so のビルド</h4>
<div class="outline-text-4" id="text-29-6-6">
<p>
src/libcard.a ができたので，次は test/test_card.so に libcard.a を取り
込むようにmakeの規則を書き換えます:
</p>

<div class="org-src-container">

<pre class="src src-makefile">LDFLAGS = -L../src/ -lcard `pkg-config cutter --libs`
</pre>
</div>

<p>
test/Makefileは下記のようになります:
</p>

<div class="org-src-container">

<pre class="src src-makefile"># test/Makefile (3) 
.PHONY: clean
CFLAGS = -fPIC -I../src `pkg-config cutter --cflags`
LDFLAGS = -L../src/ -lcard `pkg-config cutter --libs`

test_card.so: test_card.o
	gcc -o $@ --shared $^ $(LDFLAGS)

test_card.o: test_card.c
	gcc -c $&lt; $(CFLAGS)

clean:
	rm -f *.o *.so *~ \#* *.gch
</pre>
</div>

<p>
make し，src/libcard.a を取り込んだ test/test_card.so を作成します:
</p>

<div class="org-src-container">

<pre class="src src-sh"># ~/progs/card_display/simple/test/
make clean
make test_card.so
</pre>
</div>

<p>
make の結果中の下記ライン出力中に，
</p>
<pre class="example">
gcc -o test_card.so --shared test_card.o -L../src/ -lcard `pkg-config cutter --libs`
</pre>

<p>
-L../src/ -lcard `pkg-config cutter &#x2013;libs`　が含まれていれば，
test/test_card.so はできあがるはずです。
</p>
</div>
</div>
</div>

<div id="outline-container-sec-29-7" class="outline-3">
<h3 id="sec-29-7"><span class="section-number-3">29.7</span> テスト</h3>
<div class="outline-text-3" id="text-29-7">
<p>
テストと実装が終わり，テストをビルドするためのMakefileは完成してい
ます。テストするために simple/ で make してみましょう:
</p>

<div class="org-src-container">

<pre class="src src-sh"># ~/progs/card_display/simple
make
</pre>
</div>

<pre class="example">
(cd src; make)
make[1]: ディレクトリ `/home/staff/suzuki/COMM/Lects/prog/site/org-docs/tdd-card-display-simple/babel/simple/suit_new/src' に入ります
make[1]: `libcard.a' は更新済みです
make[1]: ディレクトリ `/home/staff/suzuki/COMM/Lects/prog/site/org-docs/tdd-card-display-simple/babel/simple/suit_new/src' から出ます
(cd test; make)	
make[1]: ディレクトリ `/home/staff/suzuki/COMM/Lects/prog/site/org-docs/tdd-card-display-simple/babel/simple/suit_new/test' に入ります
make[1]: `test_card.so' は更新済みです
make[1]: ディレクトリ `/home/staff/suzuki/COMM/Lects/prog/site/org-docs/tdd-card-display-simple/babel/simple/suit_new/test' から出ます
cutter -v v test/
test_card:
  test_card_suit_new_from_string:			.: (0.000066)

Finished in 0.000464 seconds (total: 0.000066 seconds)

1 test(s), 4 assertion(s), 0 failure(s), 0 error(s), 0 pending(s), 0 omission(s), 0 notification(s)
100% passed
</pre>

<p>
これからは，機能が要求を満たすことを確かめるためにテストし，テスト
が失敗した場合は，test/test_card.c, src/{card.h, card.c} を修正
していくことになります。
</p>
</div>
</div>

<div id="outline-container-sec-29-8" class="outline-3">
<h3 id="sec-29-8"><span class="section-number-3">29.8</span> テストと再設計</h3>
<div class="outline-text-3" id="text-29-8">
<p>
テストが通らなかった時，下記の場合が考えられます：
</p>
<ul class="org-ul">
<li>要求自体が間違っていた
</li>
<li>要求に対する設計が間違っていた
</li>
<li>要求・設計に対する実装が間違っていた
</li>
</ul>

<p>
それぞれどの箇所を見直すか考えてみましょう:
</p>

<ul class="org-ul">
<li>要求が間違っている場合 (テストの作り直し)
<ul class="org-ul">
<li>test/test_card.c の変更
</li>
<li>src/card.h の変更，それに伴ない
<ul class="org-ul">
<li>test/test_card.c, src/card.c の変更
</li>
</ul>
</li>
</ul>
</li>

<li>設計が間違っている場合 (インタフェースの見直し)
<ul class="org-ul">
<li>src/card.h の変更，それに伴ない
<ul class="org-ul">
<li>test/test_card.c, src/card.c の変更
</li>
</ul>
</li>
</ul>
</li>

<li>実装が間違っている場合 (実装のみの見直し)
<ul class="org-ul">
<li>src/card.c のみの変更
</li>
</ul>
</li>
</ul>

<p>
適切に対処しましょう。
</p>
</div>
</div>
</div>

<div id="outline-container-sec-30" class="outline-2">
<h2 id="sec-30"><span class="section-number-2">30</span> トランプ番号を数値に</h2>
<div class="outline-text-2" id="text-30">
</div><div id="outline-container-sec-30-1" class="outline-3">
<h3 id="sec-30-1"><span class="section-number-3">30.1</span> トランプ番号を数値に</h3>
<div class="outline-text-3" id="text-30-1">
<p>
次は，文字列で表された番号を，プログラム内部での数値に変換す
る機能のテストです。
</p>
</div>

<div id="outline-container-sec-30-1-1" class="outline-4">
<h4 id="sec-30-1-1">機能とテストの追加</h4>
<div class="outline-text-4" id="text-30-1-1">
<p>
番号のテストは，test/test_card.c に追加作成することにします。
</p>

<p>
機能の名前を card_no_new_from_string とし,
card_no_new_from_string を呼び出してみます：
</p>

<div class="org-src-container">

<pre class="src src-c">// test/test_card.c

  card_no_new_from_string("13")==KING;
</pre>
</div>

<p>
よさそうです。card_no_new_from_stringを関数の形で書けたので，テス
トを書きます:
</p>

<div class="org-src-container">

<pre class="src src-c">// test/test_card.c

  cut_set_message("番号から数値への変換のテスト");
  cut_assert(card_no_new_from_string("1")==ACE);
  cut_assert(card_no_new_from_string("13")==KING);
  cut_assert(card_no_new_from_string("12")==QUEEN);
  cut_assert(card_no_new_from_string("11")==JACK);
  cut_assert(card_no_new_from_string("10")==10);
</pre>
</div>

<p>
card_no_new_from_string 関数の型を決めます。
</p>

<p>
戻り値の型は enum e_No，与える引数は番号を示す文字列なので:
</p>

<div class="org-src-container">

<pre class="src src-c">// test/test_card.c

  enum e_No card_no_new_from_string(char *);
</pre>
</div>

<p>
テストに使う定数は，列挙型で書いてみます:
</p>

<div class="org-src-container">

<pre class="src src-c">// test/test_card.c

  enum e_No {JACK=11, QUEEN, KING, ACE};
</pre>
</div>

<p>
テストを関数にします。
</p>

<div class="org-src-container">

<pre class="src src-c">// test/test_card.c

void
test_card_suit_no_from_string(void)
{
  cut_set_message("番号から数値への変換のテスト");
  cut_assert(card_no_new_from_string("1")==ACE);
  cut_assert(card_no_new_from_string("13")==KING);
  cut_assert(card_no_new_from_string("12")==QUEEN);
  cut_assert(card_no_new_from_string("11")==JACK);
  cut_assert(card_no_new_from_string("10")==10);
}
</pre>
</div>

<p>
ここまでで，test/test_card.c の中身は:
</p>

<div class="org-src-container">

<pre class="src src-c">// test/test_card.c
# include &lt;cutter.h&gt;
# include &lt;card.h&gt;

enum e_No {JACK=11, QUEEN, KING, ACE};
enum e_No card_no_new_from_string(char *);

void
test_card_suit_new_from_string(void)
{
  cut_set_message("スーツから数値への変換のテスト");
  cut_assert_true(card_suit_new_from_string("SPADE")==SPADE);
  cut_assert(card_suit_new_from_string("HEART")==HEART);
  cut_assert(card_suit_new_from_string("DIAMOND")==DIAMOND);
  cut_assert(card_suit_new_from_string("CLUB")==CLUB);
}

void
test_card_no_new_from_string(void)
{
  cut_set_message("番号から数値への変換のテスト");
  cut_assert(card_no_new_from_string("1")==ACE);
  cut_assert(card_no_new_from_string("13")==KING);
  cut_assert(card_no_new_from_string("12")==QUEEN);
  cut_assert(card_no_new_from_string("11")==JACK);
  cut_assert(card_no_new_from_string("10")==10);
}
</pre>
</div>
</div>

<div id="outline-container-sec-30-1-1-1" class="outline-5">
<h5 id="sec-30-1-1-1">test/Makefileの更新</h5>
<div class="outline-text-5" id="text-30-1-1-1">
<p>
test/Makefile の目的は変わっていませんので，更新の必要はありません。
</p>
</div>
</div>

<div id="outline-container-sec-30-1-1-2" class="outline-5">
<h5 id="sec-30-1-1-2">test/test_card.o の更新</h5>
<div class="outline-text-5" id="text-30-1-1-2">
<p>
test/ で makeしてみましょう。
</p>

<p>
まずは，test/test_card.o の作成です:
</p>

<div class="org-src-container">

<pre class="src src-sh"># ~/progs/card_display/simple/test
make test_card.o
</pre>
</div>

<pre class="example">
gcc -c test_card.c -fPIC -I../src `pkg-config cutter --cflags`
</pre>

<p>
test_card.o ができれば，ひとまず，成功です。
</p>

<p>
できない時は，test_card.c に間違いがあるか，Makefile に間違いがあり
ます。エラーメッセージからどちらの間違いなのか特定し，修正しましょ
う。
</p>

<p>
成功したら，test/test_card.o の中身を見て確認しましょう:
</p>

<div class="org-src-container">

<pre class="src src-sh"># ~/progs/card_display/simple/test
nm test_card.o
</pre>
</div>

<pre class="example">
                 U _GLOBAL_OFFSET_TABLE_
0000000000000200 r __PRETTY_FUNCTION__.3239
                 U _setjmp
                 U card_suit_new_from_string
                 U cut_assert_helper
                 U cut_test_context_current_peek
                 U cut_test_context_finish_user_message_jump
\\                 U cut_test_context_get_have_current_result
                 U cut_test_context_get_jump_buffer
                 U cut_test_context_in_user_message_jump
                 U cut_test_context_long_jump
                 U cut_test_context_pop_backtrace
                 U cut_test_context_process_current_result
                 U cut_test_context_push_backtrace
                 U cut_test_context_set_jump_buffer
                 U cut_test_context_set_user_message
                 U cut_test_context_start_user_message_jump
0000000000000000 T test_card_suit_new_from_string
</pre>

<p>
card_no_from_stringが未定義で，
test_card_no_new_from_string が定義されているのがわかります。
</p>
</div>
</div>

<div id="outline-container-sec-30-1-1-3" class="outline-5">
<h5 id="sec-30-1-1-3">テスト (test/test_card.so) のビルド</h5>
<div class="outline-text-5" id="text-30-1-1-3">
<p>
つづいて，test/test_card.so を作りましょう:
</p>

<div class="org-src-container">

<pre class="src src-sh"># ~/progs/card_display/simple/test
make test_card.so
</pre>
</div>

<pre class="example">
gcc -o test_card.so --shared test_card.o -L../src/ -lcard `pkg-config cutter --libs`
</pre>
</div>
</div>
</div>


<div id="outline-container-sec-30-1-2" class="outline-4">
<h4 id="sec-30-1-2">card_no_new_from_string の実装</h4>
<div class="outline-text-4" id="text-30-1-2">
<p>
さて次は，機能 card_no_new_from_string の実装です。
以下のように実装しましょう:
</p>

<ul class="org-ul">
<li>test/test_card.c を作成するときに決めたインタフェースをとりだし，
src/card.hに追加する。
</li>

<li>test/test_card.c の対応部分は # include &lt;card.h&gt; に含まれることに
なる。
</li>

<li>src/card.hを遵守し，src/card.c に機能(関数)を追加する。
</li>

<li>提供する機能を入れた src/libcard.a を作成する，Makefileを作成す
る
</li>
</ul>

<p>
<b>src/{card.h，libcard.a} で機能を提供します</b>
</p>
</div>

<div id="outline-container-sec-30-1-2-1" class="outline-5">
<h5 id="sec-30-1-2-1">src/card.h の更新</h5>
<div class="outline-text-5" id="text-30-1-2-1">
<p>
test/test_card.c で宣言した card_no_new_from_string に関する
インタフェースの定義を，src/card.h に移し，定義の責任を src/ に移
します。
</p>

<p>
enum e_No の値も TWO~ACEまでにします.
</p>

<div class="org-src-container">

<pre class="src src-c">// src/card.h (追加)

enum e_Suit {CLUB=1,DIAMOND,HEART,SPADE};
enum e_Suit card_suit_new_from_string(char *);

enum e_No { TWO=2, THREE, FOUR, FIVE,
	    SIX, SEVEN, EIGHT, NINE, TEN,
	    JACK, QUEEN, KING, ACE};

enum e_No card_no_new_from_string(char *);
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-30-1-2-2" class="outline-5">
<h5 id="sec-30-1-2-2">test/test_card.cの変更</h5>
<div class="outline-text-5" id="text-30-1-2-2">
<p>
test/test_card.c から card_no_new_from_string に関する宣言を消しま
す。
</p>

<div class="org-src-container">

<pre class="src src-c">// test/test_card.c.1
# include &lt;cutter.h&gt;
# include &lt;card.h&gt;

void
test_card_suit_new_from_string(void)
{
  cut_set_message("文字列からスーツを作成する。");
  cut_assert_true(card_suit_new_from_string("SPADE")==SPADE);
  cut_assert_true(card_suit_new_from_string("HEART")==HEART);
  cut_assert_true(card_suit_new_from_string("DIAMOND")==DIAMOND);
  cut_assert_true(card_suit_new_from_string("CLUB")==CLUB);
}

void
test_card_no_new_from_string(void)
{
  cut_set_message("番号から数値への変換のテスト");
  cut_assert(card_no_new_from_string("1")==ACE);
  cut_assert(card_no_new_from_string("13")==KING);
  cut_assert(card_no_new_from_string("12")==QUEEN);
  cut_assert(card_no_new_from_string("11")==JACK);
  cut_assert(card_no_new_from_string("10")==10);
}
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-30-1-2-3" class="outline-5">
<h5 id="sec-30-1-2-3">card_no_new_from_string の実装 (src/card.c の更新)</h5>
<div class="outline-text-5" id="text-30-1-2-3">
<p>
番号を表す文字列から，内部番号にする関数 card_no_new_from_string
を実装します.
</p>

<ul class="org-ul">
<li>src/card.h 中の，下記インタフェースの宣言
</li>
</ul>

<div class="org-src-container">

<pre class="src src-C">// src/card.h
enum e_No card_no_new_from_string(char *);
</pre>
</div>

<p>
から入口と出口コードを書きます.
</p>

<p>
引数に名前をつけ， 戻り値の型を指定し，戻り値をリターンするコード
を書きます:
</p>

<div class="org-src-container">

<pre class="src src-c">enum e_No
card_no_new_from_string(char *no_str)
{
  int no;

  return (enum e_No) no;
}
</pre>
</div>

<p>
番号を表す文字列から数値を計算するコードは，例えば，つぎのように
なります。
</p>

<ul class="org-ul">
<li>整数値文字列を整数にするためのライブラリ関数 int atoi(char *) を使
います:
</li>
</ul>

<div class="org-src-container">

<pre class="src src-c">int no = atoi(no_str);
</pre>
</div>

<ul class="org-ul">
<li>1~13 の数値を，2~14 の数値に変換し，おかしな値がないかチェックし
ます
</li>
</ul>

<div class="org-src-container">

<pre class="src src-c">if (no==1)  no = ACE;

if ( no &lt; TWO || ACE &lt; no )
  {
    fprintf(stderr, "不適な数値 (%s)!\n", no_str);
  };
</pre>
</div>

<p>
全体を合わせて:
</p>

<div class="org-src-container">

<pre class="src src-c">// src/card.c
# include &lt;stdio.h&gt;
# include &lt;string.h&gt;
# include &lt;card.h&gt;

enum e_Suit
card_suit_new_from_string(char *suit_str)
{
  if (strcmp("CLUB",suit_str)==0)
    return CLUB;
  if (strcmp("DIAMOND",suit_str)==0)
    return DIAMOND;
  if (strcmp("HEART",suit_str)==0)
    return HEART;
  if (strcmp("SPADE",suit_str)==0)
    return SPADE;
  return 0;
}

enum e_No
card_no_new_from_string(char *no_str)
{
  int no = atoi(no_str);

  if (no==1)  no = ACE;

  if ( no &lt; TWO || ACE &lt; no )
    {
      fprintf(stderr, "不適な数値 (%s)!\n", no_str);
    };
  return (enum e_No) no;
}
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-30-1-2-4" class="outline-5">
<h5 id="sec-30-1-2-4">src/Makefile</h5>
<div class="outline-text-5" id="text-30-1-2-4">
<p>
src/card.h と src/card.c から src/card.o を作成し，src/card.o から
src/libcard.a を作成するルールに変更はありません。
</p>

<p>
なので，Makefileにルール変更はありません。
</p>


<div class="org-src-container">

<pre class="src src-sh"># ~/progs/card_display/simple/src
make card.o
</pre>
</div>

<pre class="example">
gcc card.c -g -c -fPIC -I. 
</pre>

<p>
実装コードに間違いがなければ， src/card.o ができて成功します。
</p>

<p>
src/card.o ができない場合，src/card.c に間違いあるか，Makefile に
間違いがあります。エラー箇所を特定し，エラーを取り除いてください。
</p>

<p>
src/card.o ができれば， src/libcard.a を作成します:
</p>

<div class="org-src-container">

<pre class="src src-sh"># ~/progs/CardDisplay/simple/src
make libcard.a
</pre>
</div>

<p>
Makefileが正しければ，これは成功します。libcard.a の中身を確かめてみましょう:
</p>

<div class="org-src-container">

<pre class="src src-sh"># ~/progs/CardDisplay/simple/src
nm libcard.a
</pre>
</div>

<pre class="example">
card.o:
                 U _GLOBAL_OFFSET_TABLE_
                 U atoi
000000000000008b T card_no_new_from_string
0000000000000000 T card_suit_new_from_string
                 U fprintf
                 U stderr
                 U strcmp
</pre>


<p>
T card_no_new_from_string， T card_suit_new_from_string で関数が定
義されているのがわかります。
</p>
</div>
</div>

<div id="outline-container-sec-30-1-2-5" class="outline-5">
<h5 id="sec-30-1-2-5">テスト test/test_card.so の再ビルド</h5>
<div class="outline-text-5" id="text-30-1-2-5">
<p>
src/libcard.a が更新できたので，次は libcard.a をリンクし直して，
test/test_card.so を更新します。
</p>

<div class="org-src-container">

<pre class="src src-sh"># ~/progs/card_display/simple/test/
make clean
make test_card.so
</pre>
</div>

<p>
rm -f <b>.o *.so *~ \#</b> *.gch
gcc -c test_card.c -fPIC -I../src `pkg-config cutter &#x2013;cflags`
gcc -o test_card.so &#x2013;shared test_card.o -L../src/ -lcard `pkg-config cutter &#x2013;libs`
</p>
</div>
</div>
</div>


<div id="outline-container-sec-30-1-3" class="outline-4">
<h4 id="sec-30-1-3">テスト</h4>
<div class="outline-text-4" id="text-30-1-3">
<p>
機能の実装が終り，テストもビルドできました。
</p>

<p>
これからは，機能が要求を満たすことを確かめるためにテストし，テスト
が失敗した場合は，test/test_card.c, src/{card.h, card.c} を修正
していくことになります。
</p>

<div class="org-src-container">

<pre class="src src-sh"># ~/progs/card_display/simple
make
</pre>
</div>

<pre class="example">
(cd src; make)
make[1]: ディレクトリ `/home/staff/suzuki/COMM/Lects/prog/site/org-docs/tdd-card-display-simple/babel/simple/no_new/src' に入ります
make[1]: `libcard.a' は更新済みです
make[1]: ディレクトリ `/home/staff/suzuki/COMM/Lects/prog/site/org-docs/tdd-card-display-simple/babel/simple/no_new/src' から出ます
(cd test; make)	
make[1]: ディレクトリ `/home/staff/suzuki/COMM/Lects/prog/site/org-docs/tdd-card-display-simple/babel/simple/no_new/test' に入ります
make[1]: `test_card.so' は更新済みです
make[1]: ディレクトリ `/home/staff/suzuki/COMM/Lects/prog/site/org-docs/tdd-card-display-simple/babel/simple/no_new/test' から出ます
cutter -v v test/
test_card:
  test_card_no_new_from_string:				.: (0.000075)
  test_card_suit_new_from_string:			.: (0.000038)

Finished in 0.000531 seconds (total: 0.000113 seconds)

2 test(s), 9 assertion(s), 0 failure(s), 0 error(s), 0 pending(s), 0 omission(s), 0 notification(s)
100% passed
</pre>

<p>
となればテスト成功です。
</p>

<p>
失敗した場合，失敗した関数を特定し，原因がテスト側
(test/test_card.c) なのか， 実装側 (src/card.c) なのか，
インタフェース (src/card.h) なのか，特定してし，
失敗の原因を取り 除いてください。
</p>
</div>


<div id="outline-container-sec-30-1-3-1" class="outline-5">
<h5 id="sec-30-1-3-1">テストと再設計</h5>
<div class="outline-text-5" id="text-30-1-3-1">
<p>
この節でおこなったこと:
</p>

<ul class="org-ul">
<li>新たな機能の要求 card_no_new_from_string があり，
</li>
<li>test/test_card.c に新らしいテスト関数を作成し，
</li>
<li>src/card.h に新たな機能のインターフェイス宣言を付け加え，
</li>
<li>src/card.c にその機能の実装を付け加えた
</li>
</ul>
</div>
</div>
</div>
</div>
</div>

<div id="outline-container-sec-31" class="outline-2">
<h2 id="sec-31"><span class="section-number-2">31</span> トランプ・カードを作成</h2>
<div class="outline-text-2" id="text-31">
</div>

<div id="outline-container-sec-31-1" class="outline-3">
<h3 id="sec-31-1"><span class="section-number-3">31.1</span> 機能の追加とテストの作成</h3>
<div class="outline-text-3" id="text-31-1">
<p>
カードを作る機能のテストは，test/test_card.c に追加作成します。
</p>

<p>
設計については，<a href="http://wiki.cis.iwate-u.ac.jp/~suzuki/lects/prog/org-docs/card-display/#outline-container-sec-2">card_display_simple問題への解法</a> も参考にしてくださ
い。
</p>
</div>

<div id="outline-container-sec-31-1-1" class="outline-4">
<h4 id="sec-31-1-1">card_new のテストを書く</h4>
<div class="outline-text-4" id="text-31-1-1">
<p>
機能の名前を card_new とし, card_newが満たすテストを書きます:
</p>

<div class="org-src-container">

<pre class="src src-c">Card sa = card_new(SPADE, ACE);
</pre>
</div>

<p>
次のような事が分かります:
</p>
<ul class="org-ul">
<li>Card型が必要である，
</li>
<li>スーツと番号を与え，
</li>
<li>Card型の値が返る。
</li>
</ul>

<p>
これだけではテストにならないので，スーツと番号を取り出す機能を合わ
せて，追加します。
</p>

<div class="org-src-container">

<pre class="src src-c">enum e_Suit card_suit(Card);
enum e_No card_no(Card);
</pre>
</div>

<p>
これにより，テストが書けます:
</p>

<div class="org-src-container">

<pre class="src src-c">Card sa = card_new(SPADE, ACE);
cut_assert( card_suit(sa)==SPADE );
cut_assert( card_no(sa)==ACE );
</pre>
</div>

<p>
スペードのACEを作り，つくられたカードのスーツと番号が正しいか，確
かめています。
</p>

<p>
Card型が定義できれば，これでよさそうです。
</p>

<div class="org-src-container">

<pre class="src src-c">void
test_card_new(void)
{
  cut_set_message("スーツと番号からカードを作成");
  {
    Card sa = card_new(SPADE,ACE);
    cut_assert( card_suit(sa)==SPADE );
    cut_assert( card_no(sa)==ACE );
  }
}
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-31-1-2" class="outline-4">
<h4 id="sec-31-1-2">card_new, card_suit, card_no のインタフェースを決める</h4>
<div class="outline-text-4" id="text-31-1-2">
<p>
card_new を関数の形で書けたので，関数の型を決めます。
</p>

<p>
戻り値の型は Card，与える引数はスーツと番号の内部表現なので:
</p>

<div class="org-src-container">

<pre class="src src-c">enum e_Suit card_suit(Card);
enum e_No card_no(Card);
Card card_new(enum e_Suit, enum e_No);
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-31-1-3" class="outline-4">
<h4 id="sec-31-1-3">Card型を定義する</h4>
<div class="outline-text-4" id="text-31-1-3">
<p>
Card 型を定義しましょう。Card型は次の情報を持ちます:
</p>

<ul class="org-ul">
<li>スーツを表す enum e_Suit 型の数値
</li>
<li>番号を表す enum e_No 型の数値
</li>
</ul>

<p>
これを構造体で表します:
</p>

<div class="org-src-container">

<pre class="src src-c">struct _Card {
  enum e_Suit suit;
  enum e_No no;
};
</pre>
</div>

<p>
ですね。
</p>

<p>
これを型にします。
</p>

<div class="org-src-container">

<pre class="src src-c">typdef struct _Card Card;
</pre>
</div>

<p>
struct _Card 型を Card 型として定義し，Card が
構造体であることを意識せずに使うことができます。
</p>
</div>
</div>

<div id="outline-container-sec-31-1-4" class="outline-4">
<h4 id="sec-31-1-4">テスト全体プログラムの確認</h4>
<div class="outline-text-4" id="text-31-1-4">
<p>
test/test_card.cは次のようになります:
</p>

<div class="org-src-container">

<pre class="src src-c"></pre>
</div>

<div class="org-src-container">

<pre class="src src-c"></pre>
</div>
</div>
</div>

<div id="outline-container-sec-31-1-5" class="outline-4">
<h4 id="sec-31-1-5">test/Makefile の確認</h4>
<div class="outline-text-4" id="text-31-1-5">
<p>
test/Makefile の目的は変わっていませんので，Makefile の更新の必要はありません。
</p>

<div class="org-src-container">

<pre class="src src-c"></pre>
</div>

<p>
test/test_card.c には card_new に関するテスト関数が加わっています。
card_new はまだ未実装ですが，test/test_card.o は作成できます。
</p>
</div>
</div>

<div id="outline-container-sec-31-1-6" class="outline-4">
<h4 id="sec-31-1-6">test/test_card.o の作成</h4>
<div class="outline-text-4" id="text-31-1-6">
<div class="org-src-container">

<pre class="src src-sh"># ~/progs/card_display/simple/test
make test_card.o
</pre>
</div>

<pre class="example">
gcc -c test_card.c -fPIC -I../src `pkg-config cutter --cflags`
</pre>

<p>
test_card.o ができれば，ひとまず，成功です。
</p>

<p>
できない時は，test_card.c に間違いがあるか，Makefile に間違いがあ
ります。エラーメッセージからどちらの間違いなのか特定し，修正しましょ
う。
</p>

<p>
成功したら，test/test_card.o の中身を見てみましょう:
</p>

<div class="org-src-container">

<pre class="src src-sh"># ~/progs/card_display/simple/test
nm test_card.o
</pre>
</div>

<pre class="example">
		 U _GLOBAL_OFFSET_TABLE_
00000000000004c0 r __PRETTY_FUNCTION__.3255
00000000000004e0 r __PRETTY_FUNCTION__.3271
00000000000004fd r __PRETTY_FUNCTION__.3302
		 U _setjmp
		 U card_new
		 U card_no
		 U card_no_new_from_string
		 U card_suit
		 U card_suit_new_from_string
		 U cut_assert_helper
		 U cut_assert_true_helper
		 U cut_test_context_current_peek
		 U cut_test_context_finish_user_message_jump
		 U cut_test_context_get_have_current_result
		 U cut_test_context_get_jump_buffer
		 U cut_test_context_in_user_message_jump
		 U cut_test_context_long_jump
		 U cut_test_context_pop_backtrace
		 U cut_test_context_process_current_result
		 U cut_test_context_push_backtrace
		 U cut_test_context_set_jump_buffer
		 U cut_test_context_set_user_message
		 U cut_test_context_start_user_message_jump
0000000000000a1b T test_card_new
0000000000000482 T test_card_no_new_from_string
0000000000000000 T test_card_suit_new_from_string
</pre>


<p>
card_newが未定義で，
test_card_new が定義されているのがわかります。
</p>
</div>
</div>
</div>

<div id="outline-container-sec-31-2" class="outline-3">
<h3 id="sec-31-2"><span class="section-number-3">31.2</span> card_new の実装</h3>
<div class="outline-text-3" id="text-31-2">
<p>
さて次は，機能 card_new の実装です。
手順は，card_no_new_from_string を実装したときと同様です:
</p>

<ul class="org-ul">
<li>test/test_card.c を作成するときに決めたインタフェースをとりだし，
src/card.h に移す。
</li>
<li>src/card.hを遵守し，src/card.c に機能を追加実装する。
</li>
<li>提供する機能を入れた src/libcard.a を作成する
</li>
</ul>

<p>
src/{card.h，libcard.a} で機能を提供する
</p>
</div>

<div id="outline-container-sec-31-2-1" class="outline-4">
<h4 id="sec-31-2-1">card/card.h の更新</h4>
<div class="outline-text-4" id="text-31-2-1">
<p>
test/test_card.c から card_new等に関するインタフェース宣言を，
src/card.h に移します。
</p>

<p>
ここまでで，src/card.h は次のようになります:
</p>

<div class="org-src-container">

<pre class="src src-c"></pre>
</div>
<p>
test/test_card.c は次のようになります：
</p>

<div class="org-src-container">

<pre class="src src-c"></pre>
</div>
</div>
</div>

<div id="outline-container-sec-31-2-2" class="outline-4">
<h4 id="sec-31-2-2">card_new の実装 (src/card.cの更新)</h4>
<div class="outline-text-4" id="text-31-2-2">
<p>
card_new関数への要求は
</p>
<ul class="org-ul">
<li>スーツの内部表現と数字の内部表現から，
</li>
<li>カードを表すデータを作る
</li>
</ul>

<p>
ことでしたから，実装は次のようになるでしょう:
</p>

<div class="org-src-container">

<pre class="src src-c"></pre>
</div>
</div>
</div>

<div id="outline-container-sec-31-2-3" class="outline-4">
<h4 id="sec-31-2-3">card_suit の実装 (src/card.cの更新)</h4>
<div class="outline-text-4" id="text-31-2-3">
<p>
要求は：
</p>
<ul class="org-ul">
<li>カードデータからそのスーツが分かること
</li>
</ul>

<p>
でしたから，
</p>

<div class="org-src-container">

<pre class="src src-c"></pre>
</div>
</div>
</div>

<div id="outline-container-sec-31-2-4" class="outline-4">
<h4 id="sec-31-2-4">card_no の実装 (src/card.cの更新)</h4>
<div class="outline-text-4" id="text-31-2-4">
<p>
要求は：
</p>
<ul class="org-ul">
<li>カードデータからその数字が分かること
</li>
</ul>

<p>
でしたから，
</p>
<div class="org-src-container">

<pre class="src src-c"></pre>
</div>
</div>
</div>

<div id="outline-container-sec-31-2-5" class="outline-4">
<h4 id="sec-31-2-5">src/card.c 全体</h4>
<div class="outline-text-4" id="text-31-2-5">
<p>
ここまでの，src/card.c を示しておきます:
</p>

<div class="org-src-container">

<pre class="src src-c"></pre>
</div>
</div>
</div>

<div id="outline-container-sec-31-2-6" class="outline-4">
<h4 id="sec-31-2-6">src/Makefile</h4>
<div class="outline-text-4" id="text-31-2-6">
<p>
src/Makefileに変更はありません。
</p>
<div class="org-src-container">

<pre class="src src-c"></pre>
</div>
</div>
</div>

<div id="outline-container-sec-31-2-7" class="outline-4">
<h4 id="sec-31-2-7">src/card.o の作成</h4>
<div class="outline-text-4" id="text-31-2-7">
<p>
src/card.o を make し, ソースコードにエラーがないか確かめます:
</p>

<div class="org-src-container">

<pre class="src src-sh"># ~/progs/card_display/simple/src
make card.o
</pre>
</div>

<pre class="example">
gcc card.c -g -c -fPIC -I. 
</pre>

<p>
src/card.o ができれば文法や宣言の食い違いはなくなったことになりま
す。
</p>
</div>
</div>

<div id="outline-container-sec-31-2-8" class="outline-4">
<h4 id="sec-31-2-8">src/libcard.a の作成</h4>
<div class="outline-text-4" id="text-31-2-8">
<p>
src/card.o ができれば，次は， src/libcard.a を make します。
</p>

<div class="org-src-container">

<pre class="src src-sh"># ~/progs/card_display/simple/src
make libcard.a
</pre>
</div>

<pre class="example">
rm -f libcard.a
ar r libcard.a card.o
</pre>

<p>
Makefile が正しければ，これは成功するはずです。
</p>

<p>
libcard.a の中身を確かめてみましょう:
</p>

<div class="org-src-container">

<pre class="src src-sh"># ~/progs/card_display/simple/src

nm libcard.a
</pre>
</div>

<pre class="example">
card.o:
                 U _GLOBAL_OFFSET_TABLE_
                 U atoi
00000000000000e6 T card_new
000000000000010f T card_no
000000000000008b T card_no_new_from_string
0000000000000102 T card_suit
0000000000000000 T card_suit_new_from_string
                 U fprintf
                 U stderr
                 U strcmp
</pre>

<p>
src/libcard.a が更新できたので，次はtest_card.so を更新します。    
</p>
</div>
</div>
</div>

<div id="outline-container-sec-31-3" class="outline-3">
<h3 id="sec-31-3"><span class="section-number-3">31.3</span> テスト</h3>
<div class="outline-text-3" id="text-31-3">
</div><div id="outline-container-sec-31-3-1" class="outline-4">
<h4 id="sec-31-3-1">test/test_card.so のビルド</h4>
<div class="outline-text-4" id="text-31-3-1">
<p>
src/libcard.a が更新されているので，test/test_card.so を作り直しま
す。
</p>

<div class="org-src-container">

<pre class="src src-sh"># ~/progs/card_display/simple/test/
make clean
make test_card.so
</pre>
</div>

<pre class="example">
rm -f *.o *.so *~ \#* *.gch
gcc -c test_card.c -fPIC -I../src `pkg-config cutter --cflags`
gcc -o test_card.so --shared test_card.o -L../src/ -lcard `pkg-config cutter --libs`
</pre>

<p>
test/test_card.so ができればテストの実行に移ります。
</p>

<p>
できない時は，多分，Makefile に間違いがあります。Makefile を修正してください。
</p>
</div>
</div>

<div id="outline-container-sec-31-3-2" class="outline-4">
<h4 id="sec-31-3-2">テストの実行</h4>
<div class="outline-text-4" id="text-31-3-2">
<p>
テストの作成と機能の実装が終ったので，機能が要求を満たすことを確か
めるためにテストする:
</p>

<div class="org-src-container">

<pre class="src src-sh"># ~/progs/card_display/simple
cutter -v v test
</pre>
</div>

<pre class="example">
test_card:
  test_card_no_new_from_string:                         .: (0.000136)
  test_card_suit_new_from_string:                       .: (0.000079)
  test_card_new:                                        .: (0.000044)

Finished in 0.001173 seconds (total: 0.000259 seconds)

3 test(s), 11 assertion(s), 0 failure(s), 0 error(s), 0 pending(s), 0 omission(s), 0 notification(s)
100% passed
</pre>
</div>
</div>

<div id="outline-container-sec-31-3-3" class="outline-4">
<h4 id="sec-31-3-3">テストと再設計</h4>
<div class="outline-text-4" id="text-31-3-3">
<p>
テストが成功すれば，テストによる開発の1サイクルが完結したことにな
ります。
</p>

<p>
テストが失敗した場合は，test/test_card.c, src/{card.h, card.c} を
修正していくことになります。
</p>

<p>
ソースコードを修正した後は，Makefileに間違いがなけれ
ば，~/progs/card_display/simpleで make すれば，全自動でテストまで
実行してくれます。テストが成功するまで繰り返してください。
</p>
</div>
</div>
</div>
</div>

<div id="outline-container-sec-32" class="outline-2">
<h2 id="sec-32"><span class="section-number-2">32</span> トランプ・カードを文字列に</h2>
<div class="outline-text-2" id="text-32">
<p>
自分でやってみましょう。
</p>
</div>

<div id="outline-container-sec-32-1" class="outline-3">
<h3 id="sec-32-1"><span class="section-number-3">32.1</span> 設計</h3>
<div class="outline-text-3" id="text-32-1">
<p>
要求は，カードの内部表現を文字列にすること
</p>

<ul class="org-ul">
<li>2文字からなるの文字列とする
</li>
<li>スーツは 'S', 'H', 'D', 'C',  1文字
</li>
<li>数は 'A','K','Q','J','0','9','8','7','6','5','4','3','2'，1文字
</li>
</ul>

<p>
処理
</p>
<ul class="org-ul">
<li>スーツや番号を添字に配列を参照するのも一つの方法
</li>
</ul>
</div>

<div id="outline-container-sec-32-1-1" class="outline-4">
<h4 id="sec-32-1-1">機能の名前と構造</h4>
<div class="outline-text-4" id="text-32-1-1">
<p>
card_to_string カードを文字列にする機能
</p>
<ul class="org-ul">
<li>card_suit_to_string  スーツを1文字にする機能
</li>
<li>card_no_to_string 番号を1文字にする機能
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-32-1-2" class="outline-4">
<h4 id="sec-32-1-2">関数の引数と戻り値の型 (APIの設計)</h4>
<div class="outline-text-4" id="text-32-1-2">
<ul class="org-ul">
<li>char *card_to_string(Card);
<ul class="org-ul">
<li>char *card_suit_to_string(int suit);
</li>
<li>char *card_no_to_string(int no);
</li>
</ul>
</li>
</ul>
</div>
</div>
</div>

<div id="outline-container-sec-32-2" class="outline-3">
<h3 id="sec-32-2"><span class="section-number-3">32.2</span> テストによる開発</h3>
<div class="outline-text-3" id="text-32-2">
<p>
card_no_new_from_string や card_new の開発をまねして，
テストによる開発を行って下さい。
</p>

<p>
開発の過程を，ドキュメントとしてまとめ，レポート提出
してください。
</p>
</div>
</div>
</div>

<div id="outline-container-sec-33" class="outline-2">
<h2 id="sec-33"><span class="section-number-2">33</span> トランプ・カードを文字列に</h2>
<div class="outline-text-2" id="text-33">
</div>

<div id="outline-container-sec-33-1" class="outline-3">
<h3 id="sec-33-1"><span class="section-number-3">33.1</span> 機能の追加とテストの作成</h3>
<div class="outline-text-3" id="text-33-1">
<p>
テストは，test/test_card.c に追加作成します。
</p>

<p>
設計については，<a href="http://wiki.cis.iwate-u.ac.jp/~suzuki/lects/prog/org-docs/card-display/#outline-container-sec-2">card_display_simple問題への解法</a> も参考にしてくださ
い。
</p>
</div>

<div id="outline-container-sec-33-1-1" class="outline-4">
<h4 id="sec-33-1-1">card_to_string のテストを書く</h4>
<div class="outline-text-4" id="text-33-1-1">
<p>
機能の名前を card_to_string とし, card_to_stringが満たすテストを書きます:
</p>

<div class="org-src-container">

<pre class="src src-c">Card sa = card_new(SPADE, ACE);

strcmp(card_to_string(sa), "SA")==0;
</pre>
</div>

<p>
テスト関数にします。
</p>

<div class="org-src-container">

<pre class="src src-c"></pre>
</div>
</div>
</div>

<div id="outline-container-sec-33-1-2" class="outline-4">
<h4 id="sec-33-1-2">card_to_string のインタフェースを決める</h4>
<div class="outline-text-4" id="text-33-1-2">
<p>
card_to_string を関数の形で書けたので，関数の型を決めます。
</p>

<p>
戻り値の型は char *，与える引数はカードなので:
</p>

<div class="org-src-container">

<pre class="src src-c"></pre>
</div>
</div>
</div>

<div id="outline-container-sec-33-1-3" class="outline-4">
<h4 id="sec-33-1-3">テスト全体プログラムの確認</h4>
<div class="outline-text-4" id="text-33-1-3">
<p>
test/test_card.cは次のようになります:
</p>

<div class="org-src-container">

<pre class="src src-c"></pre>
</div>

<div class="org-src-container">

<pre class="src src-c"></pre>
</div>
</div>
</div>

<div id="outline-container-sec-33-1-4" class="outline-4">
<h4 id="sec-33-1-4">test/Makefile の確認</h4>
<div class="outline-text-4" id="text-33-1-4">
<p>
test/Makefile の目的は変わっていませんので，Makefile の更新の必要はありません。
</p>

<div class="org-src-container">

<pre class="src src-c"></pre>
</div>

<p>
test/test_card.c には card_to_string に関するテスト関数が加わっています。
card_to_string はまだ未実装ですが，test/test_card.o は作成できます。
</p>
</div>
</div>

<div id="outline-container-sec-33-1-5" class="outline-4">
<h4 id="sec-33-1-5">test/test_card.o の作成</h4>
<div class="outline-text-4" id="text-33-1-5">
<div class="org-src-container">

<pre class="src src-sh"># ~/progs/card_display/simple/test
make test_card.o
</pre>
</div>

<pre class="example">
gcc -c test_card.c -fPIC -I../src `pkg-config cutter --cflags`
</pre>


<p>
test_card.o ができれば，ひとまず，成功です。
</p>

<p>
できない時は，test_card.c に間違いがあるか，Makefile に間違いがあ
ります。エラーメッセージからどちらの間違いなのか特定し，修正しましょ
う。
</p>

<p>
成功したら，test/test_card.o の中身を見てみましょう:
</p>

<div class="org-src-container">

<pre class="src src-sh"># ~/progs/card_display/simple/test
nm test_card.o
</pre>
</div>

<pre class="example">
		 U _GLOBAL_OFFSET_TABLE_
0000000000000540 r __PRETTY_FUNCTION__.3268
0000000000000560 r __PRETTY_FUNCTION__.3284
000000000000057d r __PRETTY_FUNCTION__.3304
0000000000000590 r __PRETTY_FUNCTION__.3317
		 U _setjmp
		 U card_new
		 U card_no
		 U card_no_new_from_string
		 U card_suit
		 U card_suit_new_from_string
		 U card_to_string
		 U cut_assert_helper
		 U cut_assert_true_helper
		 U cut_test_context_current_peek
		 U cut_test_context_finish_user_message_jump
		 U cut_test_context_get_have_current_result
		 U cut_test_context_get_jump_buffer
		 U cut_test_context_in_user_message_jump
		 U cut_test_context_long_jump
		 U cut_test_context_pop_backtrace
		 U cut_test_context_process_current_result
		 U cut_test_context_push_backtrace
		 U cut_test_context_set_jump_buffer
		 U cut_test_context_set_user_message
		 U cut_test_context_start_user_message_jump
		 U strcmp
0000000000000a1b T test_card_new
0000000000000482 T test_card_no_new_from_string
0000000000000000 T test_card_suit_new_from_string
0000000000000c8b T test_card_to_string
</pre>

<p>
card_to_stringが未定義で，
test_card_to_string が定義されているのがわかります。
</p>
</div>
</div>
</div>

<div id="outline-container-sec-33-2" class="outline-3">
<h3 id="sec-33-2"><span class="section-number-3">33.2</span> card_to_string の実装</h3>
<div class="outline-text-3" id="text-33-2">
<p>
さて次は，機能 card_to_string の実装です。
手順は，card_newを実装したときと同様です:
</p>

<ul class="org-ul">
<li>test/test_card.c を作成するときに決めたインタフェースをとりだし，
src/card.h に移す。
</li>
<li>src/card.hを遵守し，src/card.c に機能を追加実装する。
</li>
<li>提供する機能を入れた src/libcard.a を作成する
</li>
</ul>

<p>
src/{card.h，libcard.a} で機能を提供する
</p>
</div>

<div id="outline-container-sec-33-2-1" class="outline-4">
<h4 id="sec-33-2-1">card/card.h の更新</h4>
<div class="outline-text-4" id="text-33-2-1">
<p>
test/test_card.c から card_to_string等に関するインタフェース宣言を，
src/card.h に移します。
</p>

<p>
ここまでで，src/card.h は次のようになります:
</p>

<div class="org-src-container">

<pre class="src src-c"></pre>
</div>
<p>
test/test_card.c は次のようになります：
</p>

<div class="org-src-container">

<pre class="src src-c"></pre>
</div>
</div>
</div>

<div id="outline-container-sec-33-2-2" class="outline-4">
<h4 id="sec-33-2-2">card_to_string の実装 (src/card.cの更新)</h4>
<div class="outline-text-4" id="text-33-2-2">
<p>
card_to_string関数への要求を下記のように分解します:
</p>

<ul class="org-ul">
<li>スーツの内部表現を 'C', 'D', 'H', 'S' の文字へ

<p>
この機能を card_suit_to_char という関数で表します.
</p>

<ul class="org-ul">
<li>型は，char card_suit_to_char(enum e_Suit)

<p>
実装は，
</p>
</li>
</ul>
</li>
</ul>

<div class="org-src-container">

<pre class="src src-c"></pre>
</div>

<p>
スーツの文字型の配列を定義しています。0に相当するスーツ文字はな
いので，'*' にしています。
</p>

<ul class="org-ul">
<li>番号の内部表現を，2~9 の間に数値は，'2'~'9'へ，
10~14 は '0','J','Q','K','A' 
</li>
</ul>

<p>
この機能を card_no_to_char という関数で表します.
</p>

<ul class="org-ul">
<li>型は，char card_no_to_char(enum e_No)。
実装は，
</li>
</ul>

<div class="org-src-container">

<pre class="src src-c"></pre>
</div>

<ul class="org-ul">
<li>スーツを表す文字と番号を表す文字をあわせて，2文字からなる文字列
にする
</li>
</ul>

<p>
実装は次のようになるでしょう:
</p>

<div class="org-src-container">

<pre class="src src-c"></pre>
</div>
</div>
</div>

<div id="outline-container-sec-33-2-3" class="outline-4">
<h4 id="sec-33-2-3">src/card.c 全体</h4>
<div class="outline-text-4" id="text-33-2-3">
<p>
ここまでの，src/card.c を示しておきます:
</p>

<div class="org-src-container">

<pre class="src src-c"></pre>
</div>
</div>
</div>

<div id="outline-container-sec-33-2-4" class="outline-4">
<h4 id="sec-33-2-4">src/Makefile</h4>
<div class="outline-text-4" id="text-33-2-4">
<p>
src/Makefileに変更はありません。
</p>
<div class="org-src-container">

<pre class="src src-c"></pre>
</div>
</div>
</div>

<div id="outline-container-sec-33-2-5" class="outline-4">
<h4 id="sec-33-2-5">src/card.o の作成</h4>
<div class="outline-text-4" id="text-33-2-5">
<p>
src/card.o を make し, ソースコードにエラーがないか確かめます:
</p>

<div class="org-src-container">

<pre class="src src-sh"># ~/progs/card_display/simple/src
make card.o
</pre>
</div>

<pre class="example">
gcc card.c -g -c -fPIC -I. 
</pre>

<p>
src/card.o ができれば文法や宣言の食い違いはなくなったことになりま
す。
</p>
</div>
</div>

<div id="outline-container-sec-33-2-6" class="outline-4">
<h4 id="sec-33-2-6">src/libcard.a の作成</h4>
<div class="outline-text-4" id="text-33-2-6">
<p>
src/card.o ができれば，次は， src/libcard.a を make します。
</p>

<div class="org-src-container">

<pre class="src src-sh"># ~/progs/card_display/simple/src
make libcard.a
</pre>
</div>

<pre class="example">
rm -f libcard.a
ar r libcard.a card.o
</pre>

<p>
Makefile が正しければ，これは成功するはずです。
</p>

<p>
libcard.a の中身を確かめてみましょう:
</p>

<div class="org-src-container">

<pre class="src src-sh"># ~/progs/card_display/simple/src
nm libcard.a
</pre>
</div>

<pre class="example">
card.o:
0000000000000005 d NoChars
0000000000000000 d SuitChars
                 U _GLOBAL_OFFSET_TABLE_
                 U atoi
00000000000000e6 T card_new
000000000000010f T card_no
000000000000008b T card_no_new_from_string
00000000000001a2 T card_no_to_char
0000000000000102 T card_suit
0000000000000000 T card_suit_new_from_string
000000000000018b T card_suit_to_char
000000000000011c T card_to_string
                 U fprintf
                 U malloc
                 U stderr
                 U strcmp
</pre>

<p>
src/libcard.a が更新できたので，次はtest_card.so を更新します。    
</p>
</div>
</div>
</div>

<div id="outline-container-sec-33-3" class="outline-3">
<h3 id="sec-33-3"><span class="section-number-3">33.3</span> テスト</h3>
<div class="outline-text-3" id="text-33-3">
</div><div id="outline-container-sec-33-3-1" class="outline-4">
<h4 id="sec-33-3-1">test/test_card.so のビルド</h4>
<div class="outline-text-4" id="text-33-3-1">
<p>
src/libcard.a が更新されているので，test/test_card.so を作り直しま
す。
</p>

<div class="org-src-container">

<pre class="src src-sh"># ~/progs/card_display/simple/test/
make clean
make test_card.so
</pre>
</div>

<pre class="example">
rm -f *.o *.so *~ \#* *.gch
gcc -c test_card.c -fPIC -I../src `pkg-config cutter --cflags`
gcc -o test_card.so --shared test_card.o -L../src/ -lcard `pkg-config cutter --libs`
</pre>


<p>
test/test_card.so ができればテストの実行に移ります。
</p>

<p>
できない時は，多分，Makefile に間違いがあります。Makefile を修正してください。
</p>
</div>
</div>

<div id="outline-container-sec-33-3-2" class="outline-4">
<h4 id="sec-33-3-2">テストの実行</h4>
<div class="outline-text-4" id="text-33-3-2">
<p>
テストの作成と機能の実装が終ったので，機能が要求を満たすことを確か
めるためにテストする:
</p>

<div class="org-src-container">

<pre class="src src-sh"># ~/progs/card_display/simple
cutter -v v test
</pre>
</div>

<pre class="example">
test_card:
  test_card_to_string:					.: (0.000067)
  test_card_new:					.: (0.000044)
  test_card_suit_new_from_string:			.: (0.000078)
  test_card_no_new_from_string:				.: (0.000093)

Finished in 0.001416 seconds (total: 0.000282 seconds)

4 test(s), 12 assertion(s), 0 failure(s), 0 error(s), 0 pending(s), 0 omission(s), 0 notification(s)
100% passed
</pre>
</div>
</div>

<div id="outline-container-sec-33-3-3" class="outline-4">
<h4 id="sec-33-3-3">テストと再設計</h4>
<div class="outline-text-4" id="text-33-3-3">
<p>
テストが成功すれば，テストによる開発の1サイクルが完結したことにな
ります。
</p>

<p>
テストが失敗した場合は，test/test_card.c, src/{card.h, card.c} を
修正していくことになります。
</p>

<p>
ソースコードを修正した後は，Makefileに間違いがなけれ
ば，~/progs/card_display/simpleで make すれば，全自動でテストまで
実行してくれます。テストが成功するまで繰り返してください。
</p>
</div>
</div>
</div>
</div>

<div id="outline-container-sec-34" class="outline-2">
<h2 id="sec-34"><span class="section-number-2">34</span> card_display_simple 問題の解の作成</h2>
<div class="outline-text-2" id="text-34">
<ul class="org-ul">
<li>~/progs/card_display/simple/ に，
</li>

<li>作成した src/libcard.a を利用し，
</li>

<li>card_display_simple.c を作成し，
</li>

<li>Makefile を書き換えて, card_display_simple をビルドできるように，
してください。
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-35" class="outline-2">
<h2 id="sec-35"><span class="section-number-2">35</span> card_display_multi</h2>
<div class="outline-text-2" id="text-35">
<p>
Card cards\[5\]; を使ってみる。
</p>
</div>
</div>

<div id="outline-container-sec-36" class="outline-2">
<h2 id="sec-36"><span class="section-number-2">36</span> card_display_sort</h2>
<div class="outline-text-2" id="text-36">
</div>

<div id="outline-container-sec-36-1" class="outline-3">
<h3 id="sec-36-1"><span class="section-number-3">36.1</span> Doing checks <code>[1/3]</code></h3>
<div class="outline-text-3" id="text-36-1">
<ul class="org-ul">
<li><code>[X]</code> document structure check
</li>
<li><code>[&#xa0;]</code> tangle check
</li>
<li><code>[&#xa0;]</code> shell check
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-36-2" class="outline-3">
<h3 id="sec-36-2"><span class="section-number-3">36.2</span> 複数のカードをソートする機能</h3>
<div class="outline-text-3" id="text-36-2">
<p>
複数のカードを <b>Card型配列へのポインタ</b> で表すことにする:
</p>

<div class="org-src-container">

<pre class="src src-c">Card *cards;
</pre>
</div>

<p>
Card * が型で，cards が変数名。
</p>

<p>
ソートの機能は，関数で表す。
</p>

<p>
名前を cards_sort とする。cards_ は複数のカードを扱う関数の接頭詞と
した。
</p>

<p>
次に，関数 cards_sort の型を決める。cards_sort へ何を与え，
cards_sort が何を返すかを考える:
</p>


<ul class="org-ul">
<li>cards_sort は関数である:

<pre class="example">
cards_sort()
</pre>
</li>

<li>複数のカードをもらう:

<pre class="example">
cards_sort(Card *)
</pre>
</li>

<li>複数のカードの枚数ももらう:

<pre class="example">
cards_sort(Card *, int)
</pre>
</li>

<li>返す値は， (ソートした) 複数のカード:

<pre class="example">
Card *cards_sort(Card *, int)
</pre>
</li>
</ul>

<p>
ということで，関数の宣言全体は下記となります:
</p>

<div class="org-src-container">

<pre class="src src-c"></pre>
</div>
</div>
</div>

<div id="outline-container-sec-36-3" class="outline-3">
<h3 id="sec-36-3"><span class="section-number-3">36.3</span> 機能の追加とテストの作成</h3>
<div class="outline-text-3" id="text-36-3">
<p>
カードを作る機能のテストは，test/test_sort.c を新たに作成することにします。
</p>
</div>

<div id="outline-container-sec-36-3-1" class="outline-4">
<h4 id="sec-36-3-1">cards_sort のテストを書く</h4>
<div class="outline-text-4" id="text-36-3-1">
<p>
機能の名前を cards_sort とし, cards_sortが満たすテストを書きます。
</p>

<p>
まずは，試し書きしてみます:
</p>

<div class="org-src-container">

<pre class="src src-c">// test/test_sort.c

Card *cards, *sorted_cards;

sorted_cards = cards_sort(cards, 5);
</pre>
</div>

<p>
関数として書けますね。
</p>

<p>
まだテストにはなっていません。まず，テストのためのデータを用意して
みます:
</p>

<div class="org-src-container">

<pre class="src src-c"></pre>
</div>

<p>
よさそうです。
</p>

<p>
テストにするために，期待されるデータを用意し，ソート後のデータと比
較し，等しいことでテストにすることにします。
</p>

<p>
期待されるデータを用意します:
</p>

<div class="org-src-container">

<pre class="src src-c"></pre>
</div>


<p>
つぎにテストを書きます。テストの基本は，2枚のカードが等しいかです。
</p>

<p>
2枚のカードが等しいかを次のように書きたいところです:
</p>

<div class="org-src-container">

<pre class="src src-c">expected_cards[0]==sorted_cards[0]
</pre>
</div>

<p>
Card型の比較は == ではできません。関数で行なうことします:
</p>

<div class="org-src-container">

<pre class="src src-c">card_compare(expected_cards[0], sorted_cards[0])
</pre>
</div>


<p>
二枚のカードの比較を関数 card_compare で書けたので，
card_compare のインタフェースと機能を決めましょう：
</p>

<ul class="org-ul">
<li>card_compare は，2枚のカードを与え，それが等しいか大きいか小さい
かを0，1，-1で返す関数とします：
</li>

<li>card_compare は関数:

<pre class="example">
card_compare()
</pre>
</li>

<li>二枚のカードをもらって:

<pre class="example">
card_compare(Card, Card)
</pre>
</li>

<li>1,0,-1 の整数値を返す

<pre class="example">
int card_compare(Card, Card)
</pre>
</li>
</ul>

<p>
card_compare の宣言は次となります:
</p>

<div class="org-src-container">

<pre class="src src-c"></pre>
</div>

<p>
では，表明にしてみましょう:
</p>

<div class="org-src-container">

<pre class="src src-c">cut_assert(card_compare(expected_cards[0], sorted_cards[0])==0 );
</pre>
</div>

<p>
よさそうですね。
</p>

<p>
5枚のカードをテストする表明にして，全体を合わせて，関数にします。
</p>
</div>
</div>

<div id="outline-container-sec-36-3-2" class="outline-4">
<h4 id="sec-36-3-2">テスト全体プログラムの確認</h4>
<div class="outline-text-4" id="text-36-3-2">
<p>
test/test_sort.cは次のようになります:
</p>

<div class="org-src-container">

<pre class="src src-c"></pre>
</div>
</div>
</div>

<div id="outline-container-sec-36-3-3" class="outline-4">
<h4 id="sec-36-3-3">test/Makefile の確認</h4>
<div class="outline-text-4" id="text-36-3-3">
<p>
test_sort.c を用意したことで，
test/Makefile の目的は変わりました。Makefile を更新します:
</p>

<div class="org-src-container">

<pre class="src src-c"></pre>
</div>
</div>
</div>

<div id="outline-container-sec-36-3-4" class="outline-4">
<h4 id="sec-36-3-4">test/test_sort.o の作成</h4>
<div class="outline-text-4" id="text-36-3-4">
<div class="org-src-container">

<pre class="src src-sh"># ~/progs/card_display/simple/test
make test_sort.o
</pre>
</div>

<p>
test_sort.o ができれば，ひとまず，成功です。
</p>

<p>
できない時は，test_sort.c に間違いがあるか，Makefile に間違いがあ
ります。エラーメッセージからどちらの間違いなのか特定し，修正しましょ
う。
</p>

<p>
成功したら，test/test_sort.o の中身を見てみましょう:
</p>

<div class="org-src-container">

<pre class="src src-sh"># ~/progs/card_display/simple/test
nm test_sort.o
</pre>
</div>

<p>
cards_sortが未定義で，test_cards_sort が定義されているのがわかるは
ずです。
</p>
</div>
</div>
</div>

<div id="outline-container-sec-36-4" class="outline-3">
<h3 id="sec-36-4"><span class="section-number-3">36.4</span> cards_sort，card_compare の実装</h3>
<div class="outline-text-3" id="text-36-4">
<p>
さて次は，機能 cards_sort, card_compare の実装です。
</p>

<p>
お決まりの手順です:
</p>

<ul class="org-ul">
<li>test/test_sort.c を作成するときに決めたインタフェースをとりだし，
src/card.h に移す。
</li>
<li>src/card.hを遵守し，*src/cards.c* に機能を追加実装する。
</li>
<li>提供する機能を入れた src/libcard.a を作成する
</li>
</ul>

<p>
src/{card.h，libcard.a} で機能を提供する
</p>
</div>

<div id="outline-container-sec-36-4-1" class="outline-4">
<h4 id="sec-36-4-1">card/card.h の更新</h4>
<div class="outline-text-4" id="text-36-4-1">
<p>
test/test_card.c から cards_sort等に関するインタフェース宣言を，
src/card.h に移します。
</p>

<p>
ここまでで，src/card.h は次のようになります:
</p>

<div class="org-src-container">

<pre class="src src-c"></pre>
</div>

<p>
test/test_sort.c からは削除してください。
</p>
</div>
</div>

<div id="outline-container-sec-36-4-2" class="outline-4">
<h4 id="sec-36-4-2">cards_sort の実装 (src/cards.cの作成)</h4>
<div class="outline-text-4" id="text-36-4-2">
<p>
cards_sort関数の使い方は決まっています。
</p>

<div class="org-src-container">

<pre class="src src-c"></pre>
</div>

<p>
ことでした。ソートのプログラムを書いた経験をもとにします。
</p>

<p>
単純ソートは，選択範囲中で，最も小さいものを見付け範囲の先頭に動か
すことを，範囲をせばめながら行いことで，ソートを行います。
</p>

<p>
実装は次のようになるでしょう:
</p>

<div class="org-src-container">

<pre class="src src-c"></pre>
</div>
</div>
</div>

<div id="outline-container-sec-36-4-3" class="outline-4">
<h4 id="sec-36-4-3">card_compare の実装</h4>
<div class="outline-text-4" id="text-36-4-3">
<p>
card_compare の使い方も決まっています:
</p>

<div class="org-src-container">

<pre class="src src-c"></pre>
</div>

<p>
カードの番号の大小，スーツの大小をから，カードの大小を決めます:
</p>

<div class="org-src-container">

<pre class="src src-c"></pre>
</div>
</div>
</div>

<div id="outline-container-sec-36-4-4" class="outline-4">
<h4 id="sec-36-4-4">cards.c の確認</h4>
<div class="outline-text-4" id="text-36-4-4">
<div class="org-src-container">

<pre class="src src-c"></pre>
</div>
</div>
</div>

<div id="outline-container-sec-36-4-5" class="outline-4">
<h4 id="sec-36-4-5">src/Makefile</h4>
<div class="outline-text-4" id="text-36-4-5">
<p>
src/Makefileには，src/cards.o を作成する規則が追加になり，
libcard.a を作る時，cards.o も取り込むように規則を変更します:
</p>

<div class="org-src-container">

<pre class="src src-c"></pre>
</div>
</div>
</div>

<div id="outline-container-sec-36-4-6" class="outline-4">
<h4 id="sec-36-4-6">src/cards.o の作成</h4>
<div class="outline-text-4" id="text-36-4-6">
<p>
src/cards.o を make し, ソースコードにエラーがないか確かめます:
</p>

<div class="org-src-container">

<pre class="src src-sh"># ~/progs/card_display/simple/src
make cards.o
</pre>
</div>

<p>
src/cards.o ができれば文法や宣言の食い違いはなくなったことになりま
す。
</p>
</div>
</div>

<div id="outline-container-sec-36-4-7" class="outline-4">
<h4 id="sec-36-4-7">src/libcard.a の作成</h4>
<div class="outline-text-4" id="text-36-4-7">
<p>
src/cards.o ができれば，次は， src/libcard.a を make します。
</p>

<div class="org-src-container">

<pre class="src src-sh"># ~/progs/card_display/simple/src
make libcard.a
</pre>
</div>

<p>
Makefile が正しければ，これは成功するはずです。
</p>

<p>
libcard.a の中身を確かめてみましょう:
</p>

<div class="org-src-container">

<pre class="src src-sh"># ~/progs/card_display/simple/src
nm libcard.a
</pre>
</div>

<p>
src/libcard.a が更新できたので，次はtest_card.so を更新します。    
</p>
</div>
</div>
</div>

<div id="outline-container-sec-36-5" class="outline-3">
<h3 id="sec-36-5"><span class="section-number-3">36.5</span> テスト</h3>
<div class="outline-text-3" id="text-36-5">
</div><div id="outline-container-sec-36-5-1" class="outline-4">
<h4 id="sec-36-5-1">test/test_sort.so のビルド</h4>
<div class="outline-text-4" id="text-36-5-1">
<p>
test/test_sort.so を作り直します。
</p>

<div class="org-src-container">

<pre class="src src-sh"># ~/progs/card_display/simple/test/
make clean
make test_card.so
</pre>
</div>

<p>
test/test_card.so ができればテストの実行に移ります。
</p>

<p>
できない時は，多分，Makefile に間違いがあります。Makefile を修正してください。
</p>
</div>
</div>

<div id="outline-container-sec-36-5-2" class="outline-4">
<h4 id="sec-36-5-2">テストの実行</h4>
<div class="outline-text-4" id="text-36-5-2">
<p>
テストの作成と機能の実装が終ったので，機能が要求を満たすことを確か
めるためにテストする:
</p>

<div class="org-src-container">

<pre class="src src-sh"># ~/progs/card_display/simple
cutter -v v test
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-36-5-3" class="outline-4">
<h4 id="sec-36-5-3">テストと再設計</h4>
<div class="outline-text-4" id="text-36-5-3">
<p>
テストが成功すれば，テストによる開発の1サイクルが完結したことにな
ります。
</p>

<p>
テストが失敗した場合は，test/test_sort.c, src/{card.h, cards.c} を
修正していくことになります。
</p>

<p>
ソースコードを修正した後は，Makefileに間違いがなけれ
ば，~/progs/card_display/simpleで make すれば，全自動でテストまで
実行してくれます。テストが成功するまで繰り返してください。
</p>
</div>
</div>
</div>
</div>

<div id="outline-container-sec-37" class="outline-2">
<h2 id="sec-37"><span class="section-number-2">37</span> モジュール開発によるポーカーゲームの作成</h2>
<div class="outline-text-2" id="text-37">
</div><div id="outline-container-sec-37-1" class="outline-3">
<h3 id="sec-37-1"><span class="section-number-3">37.1</span> Pokerゲーム開発の始まり</h3>
<div class="outline-text-3" id="text-37-1">
<p>
<a href="http://wiki.cis.iwate-u.ac.jp/~wiki/prog.cgi">prog-wiki</a> を参考にしてください。
</p>
</div>

<div id="outline-container-sec-37-1-1" class="outline-4">
<h4 id="sec-37-1-1">はじまり</h4>
<div class="outline-text-4" id="text-37-1-1">
<p>
Wikiサイト <a href="http://wiki.cis.iwate-u.ac.jp/~wiki/prog.cgi?%E8%AC%9B%E7%BE%A9%E5%86%85%E5%AE%B9">Prog Wikky - 講義内容</a> の内容を，テストによる開発に会わせ
て，新しくドキュメントを作り直しています。
</p>
</div>

<div id="outline-container-sec-37-1-1-1" class="outline-5">
<h5 id="sec-37-1-1-1">Done ポーカーゲーム作りの始まり</h5>
<div class="outline-text-5" id="text-37-1-1-1">
<ul class="org-ul">
<li>あるゲームソフト会社で，無口な上司からの仕事依頼
</li>
<li>今のあなたなら、どんな情報があれば考えられますか? 作れますか?
</li>
</ul>
</div>

<div id="outline-container-sec-37-1-1-1-1" class="outline-6">
<h6 id="sec-37-1-1-1-1">カードモジュールつくってよ (@カードモジュールつくってよ)</h6>
<div class="outline-text-6" id="text-37-1-1-1-1">
<p>
口数少ない上司:
</p>
<blockquote>
<p>
「ポーカーゲームを作ることになったから，カードモジュール作ってよ．」
</p>
</blockquote>

<p>
私:
</p>
<blockquote>
<p>
「＠_＠ 何を．．．どうやって．．．何が必要．．．」
</p>
</blockquote>

<p>
口数少ない上司:
</p>
<blockquote>
<p>
「自分で考えてね．一を聞いて十を知るのがカリスマプログラマだよね．」
</p>
</blockquote>

<p>
私:
</p>
<blockquote>
<p>
「＠_＠ ．．．．．．」
</p>
</blockquote>
</div>
</div>


<div id="outline-container-sec-37-1-1-1-2" class="outline-6">
<h6 id="sec-37-1-1-1-2">講義で考えているポーカーゲーム</h6>
<div class="outline-text-6" id="text-37-1-1-1-2">
<p>
ここで想定しているポーカーとは以下を繰り返すことです：
</p>

<ul class="org-ul">
<li>山を作り直し，
</li>

<li>5人のプレーヤに，
</li>

<li>手札(5枚のカード) を配り，
</li>

<li>2回までの手札の交換後，
</li>

<li>手札役の強い順にプレーヤ名を表示する．
役については <a href="http://www6.airnet.ne.jp/spade/poker/rule/yaku.html">ポーカーの役についての説明</a> を参考にします。
</li>
</ul>

<p>
ゲーム全体をプログラムするには，この説明から何をどうプログラムする
のかを考えなくてはなりません．
</p>

<ul class="org-ul">
<li>この中に含まれる「もの」と「操作」が洗い出せますか？
それらがプログラムする対象となります。
</li>

<li>「もの」や「操作」を表す言葉は抽象化されていて，その中には隠され
た情報があることがわかりますか？
</li>
</ul>
</div>
</div>


<div id="outline-container-sec-37-1-1-1-3" class="outline-6">
<h6 id="sec-37-1-1-1-3">ゲーム説明とモジュールわけ</h6>
<div class="outline-text-6" id="text-37-1-1-1-3">
<p>
ゲーム説明を仕様と考えます。
</p>

<ul class="org-ul">
<li>仕様中には主体や対象となる *もの*(名詞) が現れます。

<ul class="org-ul">
<li>ものの間には関係があり，依存関係で大きなものにまとめられるもの
もあります。
</li>
</ul>
</li>

<li>主体や対象は，機能を行なうものや機能により処理されるもの，です。
</li>

<li>仕様中に現れた <b>もの</b> 達を機能のまとめ役と考えます。
</li>
</ul>

<p>
この <b>もの</b> を一つのまとまり (モジュール) として，考えていくこと
になります。
</p>

<p>
モジュール分けの良さの基準は曖昧ですが，一応結合度と凝集度という基
準があります。
</p>

<p>
<a href="http://wiki.cis.iwate-u.ac.jp/~suzuki/lects/meta-ruby/lects/note/#outline-container-sec-2">メタプログラミング Ruby 講義ノート・メモ</a> のモジューラプログラミング
を参考にしてください。
</p>
</div>
</div>

<div id="outline-container-sec-37-1-1-1-4" class="outline-6">
<h6 id="sec-37-1-1-1-4">ゲーム説明の分析 (課題)</h6>
<div class="outline-text-6" id="text-37-1-1-1-4">
<p>
ゲーム説明を読んで次の事を行なってみてください:
</p>
<ul class="org-ul">
<li>ものを取り出してください。
</li>
<li>機能を取り出して下さい。
</li>
<li>機能をもので分類してください。
</li>
<li>機能の対象と結果が何かを分析してください。
</li>
</ul>

<p>
講義の進行上，先生の分析とモジュール分けをもとに，開発を体験しても
らいますが，常に自分の分析と比較検討していって下さい。
</p>
</div>
</div>


<div id="outline-container-sec-37-1-1-1-5" class="outline-6">
<h6 id="sec-37-1-1-1-5">モジュール分け</h6>
<div class="outline-text-6" id="text-37-1-1-1-5">
<p>
ここでは下記のように分けて考えます
</p>

<ul class="org-ul">
<li>カード
</li>

<li>山
</li>

<li>手札
<ul class="org-ul">
<li>役
</li>
</ul>
</li>

<li>プレーヤー
<ul class="org-ul">
<li>プレーヤー名
</li>
</ul>
</li>

<li>ゲームモジュール
</li>
</ul>
</div>
</div>
</div>

<div id="outline-container-sec-37-1-1-2" class="outline-5">
<h5 id="sec-37-1-1-2">テストの意味</h5>
<div class="outline-text-5" id="text-37-1-1-2">
</div><div id="outline-container-sec-37-1-1-2-1" class="outline-6">
<h6 id="sec-37-1-1-2-1">「まずテストを書く」こと</h6>
<div class="outline-text-6" id="text-37-1-1-2-1">
<p>
プログラム化することで問題が <b>現実化</b> され，プログラミング上の検討
の対象となります。
</p>

<p>
モジュール分け・機能分けの設計の良さ悪さを，テストを書くことで，具
体的に評価したいのです。
</p>
</div>
</div>

<div id="outline-container-sec-37-1-1-2-2" class="outline-6">
<h6 id="sec-37-1-1-2-2">フィードバック</h6>
<div class="outline-text-6" id="text-37-1-1-2-2">
<p>
テストが 書けない/書きにくい なら，機能への分割が悪いかもしれません:
</p>

<ul class="org-ul">
<li>機能が粗く考えられている
</li>

<li>機能への入力出力が明確でない
</li>
</ul>

<p>
などが考えられます。他の原因も考えられます。
</p>

<p>
もっと前の段階の，機能をまとめるものが悪いことも考えられます。モジュー
ル分けが適切ではなかったということになります。
</p>

<p>
適切ではなかったと考えられる場合は，設計し直すことになります。
</p>
</div>
</div>
</div>
</div>
</div>

<div id="outline-container-sec-37-2" class="outline-3">
<h3 id="sec-37-2"><span class="section-number-3">37.2</span> Card モジュールの開発</h3>
<div class="outline-text-3" id="text-37-2">
</div><div id="outline-container-sec-37-2-1" class="outline-4">
<h4 id="sec-37-2-1">Cardモジュール</h4>
<div class="outline-text-4" id="text-37-2-1">
<p>
card_display 問題をやったことで，カードの機能はほぼ
できています。
</p>

<p>
libcard.a がモジュールの本体で，
card.h がインタフェースとなります。
</p>

<p>
pokerゲームの開発は，~/progs/game/の下で行いますので，
~/progs/card_display/simple/ を
~/progs/game/card/にコピーしてください。
</p>

<div class="org-src-container">

<pre class="src src-sh"># ~/progs/card_display/simple
mkdir  ~/progs/game/card/
cp -Rp * ~/progs/game/card/
cd ~/progs/game/card/
</pre>
</div>

<div class="org-src-container">

<pre class="src src-sh">make clean
make
</pre>
</div>

<p>
もし，Makefile 等にディレクトリに依存する内容があれば，書き換えて下
さい。
</p>

<p>
移動・変更後，card のすべてのテストが成功することを確かめましょう。
</p>

<p>
これでカードモジュールの開発は，一旦，終了です。
</p>
</div>
</div>
</div>

<div id="outline-container-sec-37-3" class="outline-3">
<h3 id="sec-37-3"><span class="section-number-3">37.3</span> Deck モジュールの開発</h3>
<div class="outline-text-3" id="text-37-3">
</div><div id="outline-container-sec-37-3-1" class="outline-4">
<h4 id="sec-37-3-1">山について考える</h4>
<div class="outline-text-4" id="text-37-3-1">
</div><div id="outline-container-sec-37-3-1-1" class="outline-5">
<h5 id="sec-37-3-1-1">山の機能</h5>
<div class="outline-text-5" id="text-37-3-1-1">
<p>
<a href="http://wiki.cis.iwate-u.ac.jp/~wiki/prog.cgi?%E5%B1%B1%E3%83%A2%E3%82%B8%E3%83%A5%E3%83%BC%E3%83%AB%E3%81%AE%E6%A9%9F%E8%83%BD%E3%81%AE%E6%A4%9C%E8%A8%8E">山モジュールの機能の検討</a> (prog-wiki) も参考にしてください。
</p>
</div>

<div id="outline-container-sec-37-3-1-1-1" class="outline-6">
<h6 id="sec-37-3-1-1-1">ゲームの説明から山に関する部分を取り出す</h6>
<div class="outline-text-6" id="text-37-3-1-1-1">
<ul class="org-ul">
<li>*山*を作り直し，
<ul class="org-ul">
<li>カードをシャッフルし、
</li>
<li>カードを積み上げる
</li>
</ul>
</li>

<li>手札(5枚のカード) を配り，
<ul class="org-ul">
<li>*山*の一番上のカードを引く
</li>
</ul>
</li>

<li>2回までの手札の交換後，
<ul class="org-ul">
<li>*山*の一番上のカードを引く
</li>
<li>（手札の）カードを捨てる
<ul class="org-ul">
<li>*ステ山*に積む
</li>
</ul>
</li>
</ul>
</li>

<li>手札役の強い順にプレーヤ名を表示する 
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-37-3-1-1-2" class="outline-6">
<h6 id="sec-37-3-1-1-2">山モジュールの機能</h6>
<div class="outline-text-6" id="text-37-3-1-1-2">
<p>
モジュールはトランプの山(という概念／機能) を提供する． 
</p>

<p>
それは以下：
</p>
<ul class="org-ul">
<li>山はカードの集まり．
<ul class="org-ul">
<li>カードを一列に積み上げる．
</li>
</ul>
</li>
<li>山からカードを一枚引く.
<ul class="org-ul">
<li>山が空になったら，捨て札の山から，山を作り直す．
</li>
</ul>
</li>
<li>(新しいトランプの組から)山を作り直す．
<ul class="org-ul">
<li>山を作り直すとき，シャッフルする．
</li>
</ul>
</li>
<li>捨て札を捨てる．つまり、捨て山に積む。
</li>
</ul>
</div>
</div>
</div>
</div>

<div id="outline-container-sec-37-3-2" class="outline-4">
<h4 id="sec-37-3-2">テスト駆動開発の一サイクルのテンプレート</h4>
<div class="outline-text-4" id="text-37-3-2">
<p>
モジュールの機能をテストします。
</p>

<p>
まず，機能の名前を決めます。
</p>
</div>

<div id="outline-container-sec-37-3-2-1" class="outline-5">
<h5 id="sec-37-3-2-1">機能の設計</h5>
<div class="outline-text-5" id="text-37-3-2-1">
</div><div id="outline-container-sec-37-3-2-1-1" class="outline-6">
<h6 id="sec-37-3-2-1-1">インタフェースの設計</h6>
<div class="outline-text-6" id="text-37-3-2-1-1">
</div><div id="outline-container-sec-37-3-2-1-1-1" class="outline-7">
<h7 id="sec-37-3-2-1-1-1">インタフェースを考える</h7>
<div class="outline-text-7" id="text-37-3-2-1-1-1">
<p>
機能が操作の場合
</p>
<ul class="org-ul">
<li>機能は箱，箱への入力と，箱からの出力を考える
</li>
<li>入力と出力が何であるか決める
</li>
</ul>

<p>
機能が物の場合
</p>
<ul class="org-ul">
<li>機能は箱，箱の中身を考える。
</li>
<li>何からできているかを決める
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-37-3-2-1-1-2" class="outline-7">
<h7 id="sec-37-3-2-1-1-2">テスト test_&#x2026; () を書く</h7>
</div>

<div id="outline-container-sec-37-3-2-1-1-3" class="outline-7">
<h7 id="sec-37-3-2-1-1-3">test/test_deck.o を作る (test/Makefile)</h7>
</div>
</div>
</div>

<div id="outline-container-sec-37-3-2-2" class="outline-5">
<h5 id="sec-37-3-2-2">機能の実装</h5>
<div class="outline-text-5" id="text-37-3-2-2">
</div><div id="outline-container-sec-37-3-2-2-1" class="outline-6">
<h6 id="sec-37-3-2-2-1">deck_new，deck_size の実装</h6>
<div class="outline-text-6" id="text-37-3-2-2-1">
</div><div id="outline-container-sec-37-3-2-2-1-1" class="outline-7">
<h7 id="sec-37-3-2-2-1-1">インタフェースの確定 (src/deck.h)</h7>
</div>

<div id="outline-container-sec-37-3-2-2-1-2" class="outline-7">
<h7 id="sec-37-3-2-2-1-2">Deck を作る (src/deck.c)</h7>
</div>

<div id="outline-container-sec-37-3-2-2-1-3" class="outline-7">
<h7 id="sec-37-3-2-2-1-3">deck_new と deck_size を作る (src/deck.c)</h7>
</div>

<div id="outline-container-sec-37-3-2-2-1-4" class="outline-7">
<h7 id="sec-37-3-2-2-1-4">deck_new.o, deck_size.o を作る (src/Makefile)</h7>
</div>

<div id="outline-container-sec-37-3-2-2-1-5" class="outline-7">
<h7 id="sec-37-3-2-2-1-5">libdeck.a を作る (src/Makefile)</h7>
</div>
</div>
</div>


<div id="outline-container-sec-37-3-2-3" class="outline-5">
<h5 id="sec-37-3-2-3">機能テスト</h5>
<div class="outline-text-5" id="text-37-3-2-3">
</div><div id="outline-container-sec-37-3-2-3-1" class="outline-6">
<h6 id="sec-37-3-2-3-1">テスト</h6>
<div class="outline-text-6" id="text-37-3-2-3-1">
</div><div id="outline-container-sec-37-3-2-3-1-1" class="outline-7">
<h7 id="sec-37-3-2-3-1-1">テスト test_deck.so のビルド</h7>
</div>

<div id="outline-container-sec-37-3-2-3-1-2" class="outline-7">
<h7 id="sec-37-3-2-3-1-2">テストの実行とデバッグ</h7>
</div>
</div>
</div>
</div>


<div id="outline-container-sec-37-3-3" class="outline-4">
<h4 id="sec-37-3-3">山のテスト駆動開発</h4>
<div class="outline-text-4" id="text-37-3-3">
<p>
山に名前をつけます。deck にします。
</p>
</div>

<div id="outline-container-sec-37-3-3-1" class="outline-5">
<h5 id="sec-37-3-3-1">開発ディレクトリ</h5>
<div class="outline-text-5" id="text-37-3-3-1">
<p>
~/progs/game/deck/{./, src/, test/} が開発に必要なディレクトリです。
</p>

<p>
Makefile を作っておきましょう。
</p>
<ul class="org-ul">
<li>card_display/simple/Makefile がそのまま使えるはずですよね。
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-37-3-3-2" class="outline-5">
<h5 id="sec-37-3-3-2">開発リポジトリ</h5>
<div class="outline-text-5" id="text-37-3-3-2">
<p>
<a href="http://wiki.cis.iwate-u.ac.jp/svn/prog/2015/progs/game/deck">deck</a>
ソースコードの提示用に用意しました:
</p>

<ul class="org-ul">
<li><a href="http://wiki.cis.iwate-u.ac.jp/svn/prog/2015/progs/game/deck/test">deck/test</a>
<ul class="org-ul">
<li><a href="http://wiki.cis.iwate-u.ac.jp/svn/prog/2015/progs/game/deck/test/Makefile">deck/test/Makefile</a>
</li>
<li><a href="http://wiki.cis.iwate-u.ac.jp/svn/prog/2015/progs/game/deck/test/test_deck.c">deck/test/test_deck.c</a>
</li>
</ul>
</li>
<li><a href="http://wiki.cis.iwate-u.ac.jp/svn/prog/2015/progs/game/deck/src">deck/src</a>
<ul class="org-ul">
<li><a href="http://wiki.cis.iwate-u.ac.jp/svn/prog/2015/progs/game/deck/src/Makefiel">deck/src/Makefile</a>
</li>
<li><a href="http://wiki.cis.iwate-u.ac.jp/svn/prog/2015/progs/game/deck/src/deck.h">deck/src/deck.h</a>
</li>
<li><a href="http://wiki.cis.iwate-u.ac.jp/svn/prog/2015/progs/game/deck/src/deck.c">deck/src/deck.c</a>
</li>
</ul>
</li>
</ul>

<p>
コメントの形で，ソースコードブロックに名前がついています。その名前
で参照します。#+name:test-deck#new とかです。
</p>
</div>
</div>

<div id="outline-container-sec-37-3-3-3" class="outline-5">
<h5 id="sec-37-3-3-3">card モジュールを利用するための決まり</h5>
<div class="outline-text-5" id="text-37-3-3-3">
<p>
モジュール利用規則を決めておく
</p>
<ul class="org-ul">
<li>game/inlcude にヘッダファイルを置くことにする
</li>
<li>game/lib にライブラリファイルを置くことにする
</li>
</ul>

<p>
card.h, libcard.a も使えるようにcard/src/Makefile を書き換えて，
make install でgame/include に card.h を，game/lib に libcard.a
を，コピーする規則を付け加える。
</p>

<ul class="org-ul">
<li><a href="http://wiki.cis.iwate-u.ac.jp/~suzuki/lects/prog/lects/supplyments.html">講義補足</a> ((<a href="file:///home/staff/suzuki/lects/prog/lects/supplyments.html">@cis.org</a> <a href="file:///home/staff/suzuki/COMM/Lects/prog/site/lects/supplyments.html">@s.org</a>)) のMakefileを参考にしてください。
</li>
<li><a href="http://wiki.cis.iwate-u.ac.jp/svn/prog/2015/progs/game/card/src/Makefiel">card/src/Makefile</a> を参考にしてください。
</li>
<li>card/src/Makefileが修正できたら，make install して，
card.h, libcard.a がコピーできたことを確認してください。
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-37-3-3-4" class="outline-5">
<h5 id="sec-37-3-3-4">山 (Deck) の機能の設計・実装・テスト</h5>
<div class="outline-text-5" id="text-37-3-3-4">
<p>
山はこのモジュールの主体である <b>もの*。*もの</b> はデータ構造となり，
型 (または実体(変数)) となります。
</p>

<p>
<b>もの</b> は生まれ・作られ，状態を持つ。
</p>

<p>
この状態をテストする。
</p>

<p>
はじめは簡単なテストしか書けないが，
他の機能ができてから，より詳しいテストができるようになる。
</p>
</div>

<div id="outline-container-sec-37-3-3-4-1" class="outline-6">
<h6 id="sec-37-3-3-4-1">インタフェースの設計</h6>
<div class="outline-text-6" id="text-37-3-3-4-1">
</div><div id="outline-container-sec-37-3-3-4-1-1" class="outline-7">
<h7 id="sec-37-3-3-4-1-1">インタフェースを考える</h7>
<div class="outline-text-7" id="text-37-3-3-4-1-1">
<p>
頭の中や，紙と鉛筆や，Emacs org-mode を使って，考える。
</p>

<ul class="org-ul">
<li>52枚のカードから山を作る:
<ul class="org-ul">
<li>引き札の山に52枚のカードが積まれ，
</li>
<li>捨て札の山は0枚のカードが積まれている，状態を作る
</li>
<li>二つの山は，山モジュールの中に隠れていて，プレーヤに見えてなくてもいい
</li>
<li>引き札の山から一枚のカードが引かれ，
</li>
<li>捨て札の山に一枚のカードが捨てらればいい。
</li>
</ul>
</li>
</ul>

<p>
ある程度見通しがたったら，test/test_deck.c に書き始める。
</p>

<pre class="example">
deck_new();
</pre>

<ul class="org-ul">
<li>テストにするため，検査の式を書く:
</li>
</ul>

<pre class="example">
deck_size(deck)==52
</pre>

<ul class="org-ul">
<li>deck_size()は山のカードの枚数を返す関数。新たな機能の登場。

<p>
良さそう
</p>
</li>

<li>インタフェースを書く

<pre class="example">
void deck_new (void);
int deck_size (void);
</pre>

<p>
良さそう。
</p>
</li>
</ul>
</div>
</div>
</div>

<div id="outline-container-sec-37-3-3-4-2" class="outline-6">
<h6 id="sec-37-3-3-4-2">テスト test_deck_new() を書く</h6>
<div class="outline-text-6" id="text-37-3-3-4-2">
<p>
<a href="http://wiki.cis.iwate-u.ac.jp/svn/prog/2015/progs/game/deck/test/test_deck.c">deck/test/test_deck.c</a>  #+name:test-deck#new に当たるテスト関数です。
</p>
</div>

<div id="outline-container-sec-37-3-3-4-2-1" class="outline-7">
<h7 id="sec-37-3-3-4-2-1">test/test_deck.o を作る</h7>
<div class="outline-text-7" id="text-37-3-3-4-2-1">
<p>
test/test_deck.c から test/test_deck.o を作りたいです。
</p>

<p>
test/Makefile が必要になります。
game/card/test/Makefile を参考に，deck/test用の Makefile を書いてください。
copy して，変更してもいい。
</p>

<p>
<a href="http://wiki.cis.iwate-u.ac.jp/svn/prog/2015/progs/game/deck/test/Makefile">deck/test/Makefile</a> のようになります。
</p>
</div>
</div>
</div>

<div id="outline-container-sec-37-3-3-4-3" class="outline-6">
<h6 id="sec-37-3-3-4-3">deck_new，deck_size の実装</h6>
<div class="outline-text-6" id="text-37-3-3-4-3">
</div><div id="outline-container-sec-37-3-3-4-3-1" class="outline-7">
<h7 id="sec-37-3-3-4-3-1">インタフェースの確定 (src/deck.h)</h7>
<div class="outline-text-7" id="text-37-3-3-4-3-1">
<p>
deck/test/test_deck.c にあったインタフェースを
deck/src/deck.h に移します。
</p>

<p>
<a href="http://wiki.cis.iwate-u.ac.jp/svn/prog/2015/progs/game/deck/src/deck.h">deck/src/deck.h</a> 中の下記部分になります。
</p>
<ul class="org-ul">
<li>#+name:deck.h#include
</li>
<li>#+name:deck.h#new
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-37-3-3-4-3-2" class="outline-7">
<h7 id="sec-37-3-3-4-3-2">Deck を作る (src/deck.c)</h7>
<div class="outline-text-7" id="text-37-3-3-4-3-2">
<p>
山の型と実体を作ります。
</p>

<ul class="org-ul">
<li>52枚のカードから山を作る:
<ul class="org-ul">
<li>引き札の山に52枚のカードが積まれ，
</li>
<li>捨て札の山は0枚のカードが積まれている，状態を作る
</li>
<li>二つの山は，山モジュールの中に隠れていて，プレーヤに見えてなくてもいい
</li>
</ul>
</li>
</ul>

<p>
なので，
</p>
<ul class="org-ul">
<li>山は構造体 
<pre class="example">
struct _Deck {};
</pre>
</li>
<li>52枚のカードが積まれ
<pre class="example">
# include &lt;Card&gt;
struct _Deck {Card cards[52];};
</pre>
</li>
<li>0枚のカードが積まれている，状態
<pre class="example">
# include &lt;Card&gt;
struct _Deck {Card cards[52]; int size};
</pre>
</li>

<li>引き札の山, 捨て札の山,
</li>
<li>二つの山は，山モジュールの中に隠れていて，プレーヤに見えてなく
てもいい
<pre class="example">
# include &lt;Card&gt;
struct _Deck {Card cards[52]; int size};
typedef struct _Deck Deck;
static Deck using;
static Deck used;
</pre>
</li>
</ul>

<p>
ということで， <a href="http://wiki.cis.iwate-u.ac.jp/svn/prog/2015/progs/game/deck/src/deck.c">deck/src/deck.c</a> の
</p>
<ul class="org-ul">
<li>#+name:deck.c#include
</li>
<li>#+name:deck.c#Deck 
</li>
</ul>
<p>
ができあがります。
</p>
</div>
</div>

<div id="outline-container-sec-37-3-3-4-3-3" class="outline-7">
<h7 id="sec-37-3-3-4-3-3">Todo new と size を作る (src/deck.c)</h7>
<div class="outline-text-7" id="text-37-3-3-4-3-3">
<p>
deck_new, deck_size を自分で実装してみましょう。
</p>
</div>
</div>

<div id="outline-container-sec-37-3-3-4-3-4" class="outline-7">
<h7 id="sec-37-3-3-4-3-4">Todo deck.o を作る (src/deck.o)</h7>
<div class="outline-text-7" id="text-37-3-3-4-3-4">
</div><div id="outline-container-sec-37-3-3-4-3-4-1" class="outline-8">
<h8 id="sec-37-3-3-4-3-4-1">Todo deck/src/Makefile の変更</h8>
<div class="outline-text-8" id="text-37-3-3-4-3-4-1">
<ul class="org-ul">
<li>~/progs/game/include/card.h が使えるようにする
</li>
</ul>
</div>
</div>
</div>

<div id="outline-container-sec-37-3-3-4-3-5" class="outline-7">
<h7 id="sec-37-3-3-4-3-5">Todo libdeck.a を作る</h7>
<div class="outline-text-7" id="text-37-3-3-4-3-5">
<p>
ただ make すればよいでしょう。
</p>
</div>
</div>
</div>


<div id="outline-container-sec-37-3-3-4-4" class="outline-6">
<h6 id="sec-37-3-3-4-4">Todo テスト</h6>
<div class="outline-text-6" id="text-37-3-3-4-4">
</div><div id="outline-container-sec-37-3-3-4-4-1" class="outline-7">
<h7 id="sec-37-3-3-4-4-1">Todo テスト test_deck.so のビルド</h7>
<div class="outline-text-7" id="text-37-3-3-4-4-1">
<ul class="org-ul">
<li>~/progs/game/lib/libcard.a が使えるようにする
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-37-3-3-4-4-2" class="outline-7">
<h7 id="sec-37-3-3-4-4-2">Todo テストの実行とデバッグ</h7>
</div>
</div>
</div>

<div id="outline-container-sec-37-3-3-5" class="outline-5">
<h5 id="sec-37-3-3-5">Todo 山から引く機能の設計・実装・テスト</h5>
<div class="outline-text-5" id="text-37-3-3-5">
<p>
山 (積み重ねられたカード) の一番上のカードを引く
</p>
</div>

<div id="outline-container-sec-37-3-3-5-0-1" class="outline-7">
<h7 id="sec-37-3-3-5-0-1">インタフェースの設計</h7>
<div class="outline-text-7" id="text-37-3-3-5-0-1">
<p>
Card c = deck_draw();
</p>
</div>
</div>

<div id="outline-container-sec-37-3-3-5-0-2" class="outline-7">
<h7 id="sec-37-3-3-5-0-2">テスト</h7>
<div class="outline-text-7" id="text-37-3-3-5-0-2">
<p>
deck_size()==51     
</p>
</div>
</div>

<div id="outline-container-sec-37-3-3-5-1" class="outline-6">
<h6 id="sec-37-3-3-5-1">deck_draw をテストする:</h6>
<div class="outline-text-6" id="text-37-3-3-5-1">
<p>
test_deck.c#deck_draw)
</p>

<pre class="example">
deck_new();
Card a = deck_draw();
cut_assert(deck_size(stock) == 51)
</pre>
</div>
</div>

<div id="outline-container-sec-37-3-3-5-2" class="outline-6">
<h6 id="sec-37-3-3-5-2">deck.h への追加変更</h6>
<div class="outline-text-6" id="text-37-3-3-5-2">
<p>
src/deck.h
</p>
<pre class="example">
Card deck_draw(void);
</pre>
</div>
</div>

<div id="outline-container-sec-37-3-3-5-3" class="outline-6">
<h6 id="sec-37-3-3-5-3">deck.c への追加変更</h6>
<div class="outline-text-6" id="text-37-3-3-5-3">
<div class="org-src-container">

<pre class="src src-nillangnilswitchesnilflags" id="deck.c-deck_draw">nilbody
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-37-3-3-5-4" class="outline-6">
<h6 id="sec-37-3-3-5-4">deck.o の作成</h6>
</div>

<div id="outline-container-sec-37-3-3-5-5" class="outline-6">
<h6 id="sec-37-3-3-5-5">libdeck.a の作成</h6>
</div>

<div id="outline-container-sec-37-3-3-5-6" class="outline-6">
<h6 id="sec-37-3-3-5-6">test_deck.so の作成</h6>
</div>

<div id="outline-container-sec-37-3-3-5-7" class="outline-6">
<h6 id="sec-37-3-3-5-7">test</h6>
</div>
</div>

<div id="outline-container-sec-37-3-3-6" class="outline-5">
<h5 id="sec-37-3-3-6">Todo カードを捨てる (test_deck.c#test_discard)</h5>
<div class="outline-text-5" id="text-37-3-3-6">
<p>
書いてみる
</p>
<pre class="example">
n = deck_discard(c);
</pre>

<ul class="org-ul">
<li>カードを一枚捨てる
</li>
<li>捨てられたカードの枚数が帰ってくる
</li>
<li>ちょっと不自然か？
</li>
<li>捨て山の枚数を取得する関数を用意したほうがいいかも
</li>
</ul>

<p>
deck.h
</p>
<pre class="example">
int deck_discard(Card);
</pre>

<p>
draw.c への変更追加
</p>
<ul class="org-ul">
<li>捨て山
</li>
</ul>
<pre class="example">
static Deck used;
</pre>

<ul class="org-ul">
<li>捨てる
</li>
</ul>
<pre class="example">
int deck_discard(Card a)
{
   used.cards[used.size++]=a;
   return used.size;
}
</pre>
</div>
</div>

<div id="outline-container-sec-37-3-3-7" class="outline-5">
<h5 id="sec-37-3-3-7">Todo 山の再構成 (deck_renew)</h5>
<div class="outline-text-5" id="text-37-3-3-7">
</div><div id="outline-container-sec-37-3-3-7-1" class="outline-6">
<h6 id="sec-37-3-3-7-1">機能</h6>
<div class="outline-text-6" id="text-37-3-3-7-1">
<p>
引き山がなくなり，捨て山から引き山を作り直す。
</p>

<p>
Deckモジュール内で利用する機能
</p>

<p>
deck_renew
</p>
</div>
</div>

<div id="outline-container-sec-37-3-3-7-2" class="outline-6">
<h6 id="sec-37-3-3-7-2">テストする</h6>
<div class="outline-text-6" id="text-37-3-3-7-2">
<p>
53枚引いて捨てて，山の枚数を確かめる。
</p>

<pre class="example">
deck_new();
while(deck_size()&gt;0) 
  deck_discard(deck_draw()); 
int n = deck_discar(deck_draw());
cut_assert(deck_size()==51)
cut_assert(n == 1)
</pre>
</div>
</div>

<div id="outline-container-sec-37-3-3-7-3" class="outline-6">
<h6 id="sec-37-3-3-7-3">renewの実装 (src/deck.c#renew)</h6>
<div class="outline-text-6" id="text-37-3-3-7-3">
<pre class="example">
using = used
used.size = 0
</pre>
</div>
</div>

<div id="outline-container-sec-37-3-3-7-4" class="outline-6">
<h6 id="sec-37-3-3-7-4">deck.o の作成</h6>
</div>

<div id="outline-container-sec-37-3-3-7-5" class="outline-6">
<h6 id="sec-37-3-3-7-5">libdeck.a の作成</h6>
</div>

<div id="outline-container-sec-37-3-3-7-6" class="outline-6">
<h6 id="sec-37-3-3-7-6">test_deck.so の作成</h6>
</div>

<div id="outline-container-sec-37-3-3-7-7" class="outline-6">
<h6 id="sec-37-3-3-7-7">test</h6>
</div>
</div>
<div id="outline-container-sec-37-3-3-8" class="outline-5">
<h5 id="sec-37-3-3-8">Todo シャッフル</h5>
<div class="outline-text-5" id="text-37-3-3-8">
<ul class="org-ul">
<li>0~stock.top-1 のカードを
<ul class="org-ul">
<li>適当な回数
</li>
<li>適当な2枚を入れ替える
</li>
</ul>
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-37-3-3-9" class="outline-5">
<h5 id="sec-37-3-3-9">山を印刷</h5>
<div class="outline-text-5" id="text-37-3-3-9">
<p>
test_print.cの作成
</p>
<pre class="example">
# include &lt;deck.h&gt;
Deck_newしてDeck_topが０になるまで，
while (Deck_top()&gt;0)
  printf("%s\n", Card_to_str(Deck_draw());
</pre>

<p>
デバッグ用
print.c の作成 
</p>
<pre class="example">
void Deck_print(Deck deck)
{
    for (i=0; i&lt;deck.top; i++)
      printf("%s\n", Card_to_string(deck.cards[i]))
}
</pre>

<p>
インターフェイスへの変更はない．test_deck の一部と考えられる．
</p>
</div>
</div>
</div>
</div>

<div id="outline-container-sec-37-4" class="outline-3">
<h3 id="sec-37-4"><span class="section-number-3">37.4</span> Hand モジュールの開発</h3>
<div class="outline-text-3" id="text-37-4">
</div><div id="outline-container-sec-37-4-1" class="outline-4">
<h4 id="sec-37-4-1">手札について考える</h4>
<div class="outline-text-4" id="text-37-4-1">
</div><div id="outline-container-sec-37-4-1-1" class="outline-5">
<h5 id="sec-37-4-1-1">手札の機能</h5>
<div class="outline-text-5" id="text-37-4-1-1">
<p>
<a href="http://wiki.cis.iwate-u.ac.jp/~wiki/prog.cgi?%E6%89%8B%E6%9C%AD%E3%83%A2%E3%82%B8%E3%83%A5%E3%83%BC%E3%83%AB%E3%81%AE%E8%A8%AD%E8%A8%88">Prog Wikky - 手札モジュールの設計</a> も参考にしてください。
</p>
</div>

<div id="outline-container-sec-37-4-1-1-1" class="outline-6">
<h6 id="sec-37-4-1-1-1">ゲームの説明から手札に関する部分を取り出す</h6>
<div class="outline-text-6" id="text-37-4-1-1-1">
<ul class="org-ul">
<li>手札(5枚のカード) を配り，
<ul class="org-ul">
<li>山から引いたカードを (ここは手札には関係ないが)
</li>
<li>手札に入れ，
</li>
<li>手札をソートする
</li>
</ul>
</li>

<li>2回までの手札の交換後，
<ul class="org-ul">
<li>手札のカードを引き，
</li>
<li>そのカードを捨て，
</li>
<li>山から引いたカードを (ここは手札には関係ないが)
</li>
<li>手札に入れ，
</li>
<li>手札をソートする
</li>
</ul>
</li>

<li>手札役の強い順にプレーヤ名を表示する 
<ul class="org-ul">
<li>手札の <b>役</b> 判定
</li>
<li>プレーヤーは関係なし
</li>
</ul>
</li>
</ul>

<p>
手札に関する説明に出てくる「もの」達は，「役」以外既知のもの。
</p>

<p>
「役」をどう扱うかは，要検討。
</p>
</div>
</div>


<div id="outline-container-sec-37-4-1-1-2" class="outline-6">
<h6 id="sec-37-4-1-1-2">手札モジュールの機能</h6>
<div class="outline-text-6" id="text-37-4-1-1-2">
<p>
モジュールはポーカーの手札(という概念／機能) を提供する． 
</p>

<p>
それは以下：
</p>
<ul class="org-ul">
<li>手札は5枚のカードの集まり．
</li>
<li>手札に一枚加える
</li>
<li>手札から選んだ一枚を引き抜く
</li>
<li>手札のソート
</li>
<li>手札の役を計算する
</li>
</ul>

<p>
入出力に関する機能
</p>
<ul class="org-ul">
<li>手札の表示
</li>
<li>役の名前
</li>
</ul>

<p>
これで，必要充分なのか，足りないのか，余計なものがあるのか考えます
が，テスト駆動開発では，仕様の変更を恐れず，開発を進めながら，考え
ていきます。
</p>
</div>
</div>
</div>

<div id="outline-container-sec-37-4-1-2" class="outline-5">
<h5 id="sec-37-4-1-2">機能の設計</h5>
<div class="outline-text-5" id="text-37-4-1-2">
</div><div id="outline-container-sec-37-4-1-2-1" class="outline-6">
<h6 id="sec-37-4-1-2-1">機能の名前</h6>
<div class="outline-text-6" id="text-37-4-1-2-1">
<p>
先ず，機能の説明から，その機能に名前をつけましょう。
</p>

<p>
今回の開発では，主体と操作を結合して名前を決めることにしています。
</p>
</div>

<div id="outline-container-sec-37-4-1-2-1-1" class="outline-7">
<h7 id="sec-37-4-1-2-1-1">手札を作ることに関する機能達</h7>
<div class="outline-text-7" id="text-37-4-1-2-1-1">
<p>
手札はこのモジュールの主体である <b>もの*。
*もの</b> はデータ構造となり， 型 (または実体(変数)) となります。
</p>

<p>
手札の英語名は，hand。
これがモジュールを纏める主体となります。 hand を*モジュールの名前*とし
ます。
</p>

<p>
操作には，主体が手札であることを表す hand_ を付けることにしています。
</p>

<ul class="org-ul">
<li>手札 - <b>Hand</b>
<ul class="org-ul">
<li>手札は最大5枚のカードの集まり。
</li>
</ul>
</li>

<li>空の手札を作る - <b>hand_new</b>
<ul class="org-ul">
<li>主体 ： 手札 hand
</li>
<li>操作 ： 空の手札を作る new
</li>
</ul>
</li>

<li>手札の枚数を計算する - <b>hand_size</b>
<ul class="org-ul">
<li>主体 ： 手札 hand
</li>
<li>操作 ： 手札の枚数 size
</li>
</ul>
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-37-4-1-2-1-2" class="outline-7">
<h7 id="sec-37-4-1-2-1-2">手札に一枚加える/引く機能達</h7>
<div class="outline-text-7" id="text-37-4-1-2-1-2">
<ul class="org-ul">
<li>手札に一枚加える - <b>hand_add</b>
<ul class="org-ul">
<li>主体 ： 手札 hand
</li>
<li>操作 ： カードを加える add
</li>
</ul>
</li>

<li>手札から選んだ一枚を引き抜く - <b>hand_draw</b>
<ul class="org-ul">
<li>主体 ： 手札 hand
</li>
<li>操作 ： カードを引く draw
</li>
</ul>
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-37-4-1-2-1-3" class="outline-7">
<h7 id="sec-37-4-1-2-1-3">手札の全カードを扱う機能達</h7>
<div class="outline-text-7" id="text-37-4-1-2-1-3">
<ul class="org-ul">
<li>手札のソート - <b>hand_sort</b>
<ul class="org-ul">
<li>主体 ： 手札 hand
</li>
<li>操作 ： 手札をソート sort
</li>
</ul>
</li>
</ul>


<ul class="org-ul">
<li>手札を文字列に - <b>hand_to_string</b>
<ul class="org-ul">
<li>主体 ： 手札 hand
</li>
<li>操作 ： 手札を文字列に (convert_)to_string. 長いし，曖昧性がないの
で，convert_を省略します。
</li>
</ul>
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-37-4-1-2-1-4" class="outline-7">
<h7 id="sec-37-4-1-2-1-4">役に関する機能達</h7>
<div class="outline-text-7" id="text-37-4-1-2-1-4">
<p>
役の英語訳は，poker hand.
役は手札に関する付加情報と考え，モジュールを構成する主体とは考えなかっ
た。
</p>

<ul class="org-ul">
<li>手札の役を計算する - <b>hand_calc</b>
<ul class="org-ul">
<li>主体 ： 手札 hand
</li>
<li>操作 ： 役の計算 calc

<p>
下請けの関数として，が考えられるが，今は詳細として，隠しておき，
hand_calc のテスト駆動開発の時に，検討しましょう:
</p>
<ul class="org-ul">
<li>hand_is_straight &#x2013; 手札はストレートか？
</li>
<li>hand_is_flush &#x2013; 手札はフラッシュか？
</li>
<li>hand_calc_pairs &#x2013; ペアを計算する
</li>
</ul>
</li>
</ul>
</li>

<li>役 <b>PokerHand</b> (物)
<ul class="org-ul">
<li>役のこと，いくつか具体的な役の名前の集まり
</li>
<li>なので型
</li>
<li>型は capital words で表すので，_P_oker_H_and.
</li>
</ul>
</li>
</ul>


<ul class="org-ul">
<li>役を文字列に - <b>hand_pokerhand_to_string</b>
<ul class="org-ul">
<li>主体 ： hand? 
</li>
<li>操作 ： 役を文字列に pokerhand_to_string
</li>
</ul>
</li>
</ul>
</div>
</div>
</div>


<div id="outline-container-sec-37-4-1-2-2" class="outline-6">
<h6 id="sec-37-4-1-2-2">インタフェースを考える (deckと同じ)</h6>
<div class="outline-text-6" id="text-37-4-1-2-2">
<p>
機能が操作の場合
</p>
<ul class="org-ul">
<li>機能は箱，箱への入力と，箱からの出力を考える
</li>
<li>入力と出力が何であるか決める
</li>
</ul>

<p>
機能が物の場合
</p>
<ul class="org-ul">
<li>機能は箱，箱の中身を考える。
</li>
<li>何からできているかを決める
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-37-4-1-2-3" class="outline-6">
<h6 id="sec-37-4-1-2-3">機能のインタフェース</h6>
<div class="outline-text-6" id="text-37-4-1-2-3">
<p>
主体，操作から機能の名前は決まっています。あとは，対象物と，操作の
結果の型を洗いだしていきます。
</p>
</div>

<div id="outline-container-sec-37-4-1-2-3-1" class="outline-7">
<h7 id="sec-37-4-1-2-3-1">手札</h7>
<div class="outline-text-7" id="text-37-4-1-2-3-1">
<p>
手札とは
</p>
<ul class="org-ul">
<li>カードと枚数からなる。したがって，手札は構造体。
</li>
<li>ゲーム中，手札は，いくつも存在する。変数ではなく，型となる。型
名は，最初の一文字を大文字で表す (capital word) ことにしていま
す。 Hand とします。
</li>
<li>構造体の中身は，テスト駆動開発時の機能の実装を行なうときに，考
えることにします。
</li>
</ul>

<p>
これらのことから，Hand は下記のようにC言語の宣言で書くことができま
す: 
</p>

<div class="org-src-container">

<pre class="src src-c">typedef struct _Hand Hand;
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-37-4-1-2-3-2" class="outline-7">
<h7 id="sec-37-4-1-2-3-2">hand_new</h7>
<div class="outline-text-7" id="text-37-4-1-2-3-2">
<p>
空の手札を作る     
</p>


<ul class="org-ul">
<li>主体 ： 手札 hand
</li>
<li>操作 ： 空の手札を作る new
</li>
<li>対象物 ： なし
</li>
<li>結果 ： Hand
</li>
</ul>

<div class="org-src-container">

<pre class="src src-c">Hand hand_new(void);
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-37-4-1-2-3-3" class="outline-7">
<h7 id="sec-37-4-1-2-3-3">hand_size</h7>
<div class="outline-text-7" id="text-37-4-1-2-3-3">
<p>
手札の枚数を計算する
</p>
<ul class="org-ul">
<li>主体 ： 手札 hand
</li>
<li>操作 ： 手札の枚数 size
</li>
<li>対象物 ： 手札
</li>
<li>結果 ： 枚数 int
</li>
</ul>

<div class="org-src-container">

<pre class="src src-c">int hand_size(Hand);
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-37-4-1-2-3-4" class="outline-7">
<h7 id="sec-37-4-1-2-3-4">hand_add</h7>
<div class="outline-text-7" id="text-37-4-1-2-3-4">
<p>
手札に一枚カードを加える
</p>
<ul class="org-ul">
<li>主体 ： 手札 hand
</li>
<li>操作 ： カードを加える add
</li>
<li>対象物 ： 手札に，カードを (Hand, Card)
</li>
<li>結果 ： 一枚カードが付加えられた手札 Hand
</li>
</ul>

<div class="org-src-container">

<pre class="src src-c">Hand hand_add (Hand, Card);
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-37-4-1-2-3-5" class="outline-7">
<h7 id="sec-37-4-1-2-3-5">hand_draw</h7>
<div class="outline-text-7" id="text-37-4-1-2-3-5">
<p>
手札から選んだ一枚を引き抜く
</p>
<ul class="org-ul">
<li>主体 ： 手札 hand
</li>
<li>操作 ： カードを引く draw
</li>
<li>対象物 ： 手札から，指定したカードを (Hand, どの手札か)
</li>
<li>結果 ： 一枚カードが引かれた手札 Hand
</li>
</ul>

<div class="org-src-container">

<pre class="src src-c">Hand hand_draw (Hand, int);
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-37-4-1-2-3-6" class="outline-7">
<h7 id="sec-37-4-1-2-3-6">hand_sort</h7>
<div class="outline-text-7" id="text-37-4-1-2-3-6">
<p>
手札の5枚のカードをソート
</p>
<ul class="org-ul">
<li>主体 ： 手札 hand
</li>
<li>操作 ： 手札の全カードをソート sort
</li>
<li>対象物 ： 手札 (Hand)
</li>
<li>結果 ： ソートされた手札 Hand
</li>
</ul>

<div class="org-src-container">

<pre class="src src-c">Hand hand_sort(Hand);
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-37-4-1-2-3-7" class="outline-7">
<h7 id="sec-37-4-1-2-3-7">hand_to_string</h7>
<div class="outline-text-7" id="text-37-4-1-2-3-7">
<p>
手札を文字列に
</p>
<ul class="org-ul">
<li>主体 ： 手札 hand
</li>
<li>操作 ： 手札を表す文字列を作る to_string
</li>
<li>対象物 ： 手札 (Hand)
</li>
<li>結果 ： 文字列 char *
</li>
</ul>

<div class="org-src-container">

<pre class="src src-c">char *hand_to_string(Hand);
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-37-4-1-2-3-8" class="outline-7">
<h7 id="sec-37-4-1-2-3-8">hand_calc</h7>
<div class="outline-text-7" id="text-37-4-1-2-3-8">
<p>
手札の役を計算する
</p>
<ul class="org-ul">
<li>主体 ： 手札 hand
</li>
<li>操作 ： 手札のソート sort
</li>
<li>対象物 ： 手札 (Hand)
</li>
<li>結果 ： 役 PokerHand
</li>
</ul>

<div class="org-src-container">

<pre class="src src-c">PokerHand hand_calc(Hand);
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-37-4-1-2-3-9" class="outline-7">
<h7 id="sec-37-4-1-2-3-9">PokerHand (物)</h7>
<div class="outline-text-7" id="text-37-4-1-2-3-9">
<p>
役(値)の集まり
</p>

<ul class="org-ul">
<li>HighCards, OnePair, TwoPairs, ThreeCards, Straight, Flush,
FullHouse, FourCards, StraightFlush
</li>
</ul>

<div class="org-src-container">

<pre class="src src-c">enum PokerHand { HighCards, OnePair, TwoPairs, ThreeCards, Straight, Flush,
		 FullHouse, FourCards, StraightFlush };
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-37-4-1-2-3-10" class="outline-7">
<h7 id="sec-37-4-1-2-3-10">poker_hand_to_string</h7>
<div class="outline-text-7" id="text-37-4-1-2-3-10">
<p>
役値を文字列に
</p>
<ul class="org-ul">
<li>主体 ： 手札 hand
</li>
<li>操作 ： 役を表す文字列を作る pokerhand_to_string
</li>
<li>対象物 ： 役 (PokerHand)
</li>
<li>結果 ： 文字列 char *
</li>
</ul>

<div class="org-src-container">

<pre class="src src-c">char *hand_pokerhand_to_string (PokerHand);
</pre>
</div>
</div>
</div>
</div>
</div>
</div>


<div id="outline-container-sec-37-4-2" class="outline-4">
<h4 id="sec-37-4-2">開発の決まり (deckとほぼ同じ)</h4>
<div class="outline-text-4" id="text-37-4-2">
</div><div id="outline-container-sec-37-4-2-1" class="outline-5">
<h5 id="sec-37-4-2-1">開発ディレクトリ</h5>
<div class="outline-text-5" id="text-37-4-2-1">
<p>
~/progs/game/hand/{./, src/, test/} が開発に必要なディレクトリです。
</p>
</div>
</div>


<div id="outline-container-sec-37-4-2-2" class="outline-5">
<h5 id="sec-37-4-2-2">開発リポジトリ</h5>
<div class="outline-text-5" id="text-37-4-2-2">
<p>
hand の内容は，来週の講義後，アップします。
</p>
</div>
</div>

<div id="outline-container-sec-37-4-2-3" class="outline-5">
<h5 id="sec-37-4-2-3">他のモジュールを利用するための決まり</h5>
<div class="outline-text-5" id="text-37-4-2-3">
<p>
deckと同じ
</p>
</div>
</div>

<div id="outline-container-sec-37-4-2-4" class="outline-5">
<h5 id="sec-37-4-2-4">Makefileの準備</h5>
<div class="outline-text-5" id="text-37-4-2-4">
<ul class="org-ul">
<li>hand/Makefile
<ul class="org-ul">
<li>deck/Makefile がそのまま使えるはずですよね。
</li>
</ul>
</li>

<li>hand/test/Makefile
<ul class="org-ul">
<li>deck/test/Makefile の deck を hand に置き換えれば，そのまま使え
そうです。
</li>
</ul>
</li>

<li>hand/src/Makefile
<ul class="org-ul">
<li>deck/src/Makefile の deck を hand に置き換えれば，そのまま使え
そうです。
</li>
</ul>
</li>
</ul>

<p>
確かめながら，それぞれの Makefile を作成してください。
</p>
</div>
</div>

<div id="outline-container-sec-37-4-2-5" class="outline-5">
<h5 id="sec-37-4-2-5">テスト駆動開発の一サイクルのテンプレート</h5>
<div class="outline-text-5" id="text-37-4-2-5">
<p>
deckとほぼ同じ
</p>
</div>
</div>
</div>


<div id="outline-container-sec-37-4-3" class="outline-4">
<h4 id="sec-37-4-3">手札のテスト駆動開発</h4>
<div class="outline-text-4" id="text-37-4-3">
<p>
deck モジュールを参考に，一つづつテスト駆動開発してみましょう。
</p>

<p>
一つづつ機能ができ，集まって hand の機能群 (モジュール)になり，
</p>

<p>
モジュール群の開発が徐々に行なわれ，手札の操作，役判定ができ，だんだ
んゲームができそうな雰囲気がでてくるはずです。
</p>

<p>
開発については，レポートにします。
</p>
</div>
</div>

<div id="outline-container-sec-37-4-4" class="outline-4">
<h4 id="sec-37-4-4">作成された手札モジュールの解説</h4>
</div>

<div id="outline-container-sec-37-4-5" class="outline-4">
<h4 id="sec-37-4-5">src/hand.h</h4>
<div class="outline-text-4" id="text-37-4-5">
</div><div id="outline-container-sec-37-4-5-1" class="outline-5">
<h5 id="sec-37-4-5-1">一回だけしか，include できなくする</h5>
<div class="outline-text-5" id="text-37-4-5-1">
<div class="org-src-container">

<pre class="src src-c"># pragma once
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-37-4-5-2" class="outline-5">
<h5 id="sec-37-4-5-2">依存するモジュールのインタフェースを読む</h5>
<div class="outline-text-5" id="text-37-4-5-2">
<div class="org-src-container">

<pre class="src src-c"># include &lt;card.h&gt;
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-37-4-5-3" class="outline-5">
<h5 id="sec-37-4-5-3">hand 型の定義</h5>
<div class="outline-text-5" id="text-37-4-5-3">
<p>
hand モジュールの主体 Hand型を定義する.
</p>

<ul class="org-ul">
<li>最大5枚のカード
</li>
<li>手札の枚数。出し入れがあるため。
</li>
</ul>

<p>
からなる構造体:
</p>

<div class="org-src-container">

<pre class="src src-c"># define CardsInHand 5 //02.01 added

struct _Hand {
  Card cards[5];
  int size;
};

typedef struct _Hand Hand;
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-37-4-5-4" class="outline-5">
<h5 id="sec-37-4-5-4">手札の作成と状態を知る機能</h5>
<div class="outline-text-5" id="text-37-4-5-4">
<div class="org-src-container">

<pre class="src src-c">Hand hand_new(void);
int hand_size(Hand);
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-37-4-5-5" class="outline-5">
<h5 id="sec-37-4-5-5">手札の出し入れ</h5>
<div class="outline-text-5" id="text-37-4-5-5">
<div class="org-src-container">

<pre class="src src-c">Hand hand_add(Hand, Card); // 手札に一枚カードを加える
Hand hand_draw(Hand, int); // 手札から一枚カードを抜く
Card hand_card(Hand, int); // 02.02 added 手札中のカードを見る
			   // 番号の指定は 1..5
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-37-4-5-6" class="outline-5">
<h5 id="sec-37-4-5-6">ソート</h5>
<div class="outline-text-5" id="text-37-4-5-6">
<div class="org-src-container">

<pre class="src src-c">Hand hand_sort(Hand); // 手札のソート
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-37-4-5-7" class="outline-5">
<h5 id="sec-37-4-5-7">手札の表示（用文字列の生成）</h5>
<div class="outline-text-5" id="text-37-4-5-7">
<div class="org-src-container">

<pre class="src src-c">// 手札の表示（用文字列の生成）
char *hand_to_string(Hand);
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-37-4-5-8" class="outline-5">
<h5 id="sec-37-4-5-8">役に関する定義</h5>
<div class="outline-text-5" id="text-37-4-5-8">
<div class="org-src-container">

<pre class="src src-c">// 役に関する定義
typedef 
 enum {
  HighCard = 1,
  OnePair,
  TwoPairs,
  ThreeCards,
  Straight,
  Flush,
  FullHouse,
  FourCards,
  StraightFlush
}
  PokerHand;
</pre>
</div>

<div class="org-src-container">

<pre class="src src-c">// 役の計算
PokerHand hand_judge(Hand);
// 役の名前
char *hand_pokerhand_to_string(PokerHand);
</pre>
</div>


<p>
// C-c C-v C-t :
</p>
</div>
</div>
</div>
<div id="outline-container-sec-37-4-6" class="outline-4">
<h4 id="sec-37-4-6">test_hand.c</h4>
<div class="outline-text-4" id="text-37-4-6">
</div><div id="outline-container-sec-37-4-6-1" class="outline-5">
<h5 id="sec-37-4-6-1">test_hand header</h5>
<div class="outline-text-5" id="text-37-4-6-1">
<div class="org-src-container">

<pre class="src src-c">//~/progs/game/hand/test/test_hand.c
# include &lt;cutter.h&gt;
# include &lt;hand.h&gt;
# include &lt;string.h&gt;
# include &lt;stdio.h&gt;
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-37-4-6-2" class="outline-5">
<h5 id="sec-37-4-6-2">手札の生成のテスト</h5>
<div class="outline-text-5" id="text-37-4-6-2">
<p>
テスト項目
</p>
<ul class="org-ul">
<li>手札ができ，枚数が0枚であること
</li>
</ul>

<div class="org-src-container">

<pre class="src src-c">void
test_hand_new(void)
{
  Hand h = hand_new();

  cut_set_message("hand_new");
  cut_assert(hand_size(h)==0);
}
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-37-4-6-3" class="outline-5">
<h5 id="sec-37-4-6-3">手札へのカードの追加</h5>
<div class="outline-text-5" id="text-37-4-6-3">
<p>
テスト項目
</p>
<ul class="org-ul">
<li>カードを2枚追加し，手札の枚数が1づつ増えること
</li>
</ul>

<div class="org-src-container">

<pre class="src src-c">void
test_hand_add(void)
{
  Hand h = hand_new();
  Card c1 = card_new(SPADE,ACE);
  Card c2 = card_new(HEART,KING);

  cut_set_message("hand_add");
  h = hand_add(h, c1);
  cut_assert(hand_size(h)==1);
  h = hand_add(h, c2);
  cut_assert(hand_size(h)==2);
}
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-37-4-6-4" class="outline-5">
<h5 id="sec-37-4-6-4">手札の no 番目のカードのテスト</h5>
<div class="outline-text-5" id="text-37-4-6-4">
<p>
テスト項目
</p>
<ul class="org-ul">
<li>手札にカードを加え，手札がそのカードからなっていること
</li>
</ul>

<div class="org-src-container">

<pre class="src src-c">void
test_hand_card(void)
{
  Hand h = hand_new();
  Card c1 = card_new(SPADE,ACE);
  Card c2 = card_new(HEART,KING);

  cut_set_message("hand_card");
  h = hand_add(h, c1);
  h = hand_add(h, c2);

  cut_assert(card_compare(c1, hand_card(h, 0))==0);
  cut_assert(card_compare(c2, hand_card(h, 1))==0);
}
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-37-4-6-5" class="outline-5">
<h5 id="sec-37-4-6-5">手札から1枚引く</h5>
<div class="outline-text-5" id="text-37-4-6-5">
<p>
テスト項目
</p>
<ul class="org-ul">
<li>手札にカードを加え，
</li>
<li>加えた順でカードの情報が得られること
</li>
</ul>

<div class="org-src-container">

<pre class="src src-c">void
test_hand_draw()
{
  Hand h = hand_new();
  Card c1 = card_new(SPADE, QUEEN);
  Card c2 = card_new(HEART, QUEEN);
  Card c3 = card_new(CLUB, QUEEN);
  Card c4 = card_new(DIAMOND, QUEEN);
  Card c5 = card_new(SPADE, JACK);

  cut_set_message("hand_draw");
  h = hand_add(h, c1);
  h = hand_add(h, c2);
  h = hand_add(h, c3);
  h = hand_add(h, c4); 
  h = hand_add(h, c5);

  cut_assert(hand_size(h)==5);
  Card d = hand_card(h, 1);
  h = hand_draw(h, 1);
  cut_assert(hand_size(h)==4);
  cut_assert(card_compare(d, c2)==0);
}
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-37-4-6-6" class="outline-5">
<h5 id="sec-37-4-6-6">手札のソート</h5>
<div class="outline-text-5" id="text-37-4-6-6">
<p>
テスト項目
</p>
<ul class="org-ul">
<li>手札に5枚のカードを加え，
</li>
<li>ソート後，昇順に並んでいること
</li>
</ul>

<div class="org-src-container">

<pre class="src src-c">void
test_hand_sort()
{
  Hand h = hand_new();
  Card c1 = card_new(SPADE, 2);
  Card c2 = card_new(HEART, 3);
  Card c3 = card_new(CLUB, 4);
  Card c4 = card_new(DIAMOND, 5);
  Card c5 = card_new(SPADE, 6);

  cut_set_message("hand_sort");

  h = hand_add(h, c2);
  h = hand_add(h, c1);
  h = hand_add(h, c3);
  h = hand_add(h, c4);
  h = hand_add(h, c5);

  h = hand_sort(h);

  cut_assert(card_compare(c1, hand_card(h, 0))==0);
  cut_assert(card_compare(c2, hand_card(h, 1))==0);
  cut_assert(card_compare(c3, hand_card(h, 2))==0);
  cut_assert(card_compare(c4, hand_card(h, 3))==0);
  cut_assert(card_compare(c5, hand_card(h, 4))==0);
}
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-37-4-6-7" class="outline-5">
<h5 id="sec-37-4-6-7">手札の文字列化のテスト</h5>
<div class="outline-text-5" id="text-37-4-6-7">
<p>
テスト項目
</p>
<ul class="org-ul">
<li>手札に5枚のカードを加え，
</li>
<li>その通りに文字列化されること
</li>
</ul>

<div class="org-src-container">

<pre class="src src-c">void
test_hand_to_string()
{
  Hand h = hand_new();
  Card c1 = card_new(SPADE, 2);
  Card c2 = card_new(HEART, 3);
  Card c3 = card_new(CLUB, 4);
  Card c4 = card_new(DIAMOND, 5);
  Card c5 = card_new(SPADE, 6);

  cut_set_message("hand_to_string");

  h = hand_add(h, c1);
  h = hand_add(h, c2);
  h = hand_add(h, c3);
  h = hand_add(h, c4);
  h = hand_add(h, c5);

  char *s = hand_to_string(h);
  cut_assert(strlen(s)==15);
  cut_assert(strcmp("S2.H3.C4.D5.S6.", s)==0);
}
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-sec-37-4-7" class="outline-4">
<h4 id="sec-37-4-7">hand/src/hand.c</h4>
<div class="outline-text-4" id="text-37-4-7">
</div><div id="outline-container-sec-37-4-7-1" class="outline-5">
<h5 id="sec-37-4-7-1">Cの標準ラブラリを使う</h5>
<div class="outline-text-5" id="text-37-4-7-1">
</div>
</div>

<div id="outline-container-sec-37-4-7-2" class="outline-5">
<h5 id="sec-37-4-7-2">hand のインタフェースを遵守</h5>
<div class="outline-text-5" id="text-37-4-7-2">
<div class="org-src-container">

<pre class="src src-c"># include &lt;hand.h&gt;
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-37-4-7-3" class="outline-5">
<h5 id="sec-37-4-7-3">hand_new, hand_size</h5>
<div class="outline-text-5" id="text-37-4-7-3">
<div class="org-src-container">

<pre class="src src-c">//新らしい手札を作る
Hand
hand_new(void)
{
  Hand h;  //** 手札を作る。size, cards[5]は初期化されていない。

  h.size=0; //** 枚数を0に初期化する。
  return h; //** 初期化された手札を値として返す。
}

// 手札の枚数を求める
int
hand_size(Hand h)
{
  return h.size; //自明
}
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-37-4-7-4" class="outline-5">
<h5 id="sec-37-4-7-4">hand_add</h5>
<div class="outline-text-5" id="text-37-4-7-4">
<p>
手札にカードを一枚加える。
</p>

<div class="org-src-container">

<pre class="src src-c">// 手札にカードを一枚加える
Hand hand_add(Hand h, Card c)
{
  h.cards[h.size++] = c; //** 自明
  return h;
}
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-37-4-7-5" class="outline-5">
<h5 id="sec-37-4-7-5">hand_card</h5>
<div class="outline-text-5" id="text-37-4-7-5">
<p>
手札の no 番目のカード情報を得る。no は 0~4。
</p>

<p>
手札から1枚カードを捨てる時，つぎのことが必要である:
</p>
<ul class="org-ul">
<li>そのカードを捨て山に積むためのカードの情報 (hand_cardの戻り値)
</li>
<li>一枚少なくなった手札自身 (hand_drawの戻り値)
</li>
</ul>

<div class="org-src-container">

<pre class="src src-c">Card hand_card(Hand h, int no)
{
  return h.cards[no];
}
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-37-4-7-6" class="outline-5">
<h5 id="sec-37-4-7-6">hand_draw</h5>
<div class="outline-text-5" id="text-37-4-7-6">
<p>
手札から， no 番目のカードを抜く。
</p>

<div class="org-src-container">

<pre class="src src-c">Hand hand_draw(Hand h, int no)
{
  int i;

  if (no&gt;h.size)
    return h;

  // no以降をつめる
  for(i=no; i&lt;h.size; i++) 
    {
      h.cards[i]=h.cards[i+1];
    }
  h.size--;
  return h;
}
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-37-4-7-7" class="outline-5">
<h5 id="sec-37-4-7-7">文字列化</h5>
<div class="outline-text-5" id="text-37-4-7-7">
<p>
カードの文字列化をもとに，手札を文字列化する。
</p>

<div class="org-src-container">

<pre class="src src-c">char *hand_to_string(Hand h)
{
  int i;
  char *s = (char *) malloc(CardsInHand*3+1); //** 文字列領域確保

  bzero(s,CardsInHand*3+1);   //** 領域の0クリア

  for(i=0; i&lt;hand_size(h); i++)
    {
      strcat(s, card_to_string(hand_card(h,i))); //** カード文字列を詰める
      strcat(s, "."); //** 区切りの . を詰める
    }
  return s;
}
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-37-4-7-8" class="outline-5">
<h5 id="sec-37-4-7-8">hand_sort</h5>
<div class="outline-text-5" id="text-37-4-7-8">
<p>
cardモジュールで作った cards_sort の機能がほぼそのまま使える:
</p>

<div class="org-src-container">

<pre class="src src-c">Hand hand_sort(Hand h)
{
  Card *cards = h.cards;

  cards = cards_sort(cards, hand_size(h));
  return h;
}
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-sec-37-4-8" class="outline-4">
<h4 id="sec-37-4-8">test/test_judge.c</h4>
<div class="outline-text-4" id="text-37-4-8">
</div><div id="outline-container-sec-37-4-8-1" class="outline-5">
<h5 id="sec-37-4-8-1">必要なライブラリのヘッ</h5>
<div class="outline-text-5" id="text-37-4-8-1">
<div class="org-src-container">

<pre class="src src-c"># include &lt;stdio.h&gt;
# include &lt;string.h&gt;
# include &lt;cutter.h&gt;
</pre>
</div>

<div class="org-src-container">

<pre class="src src-c"># include &lt;hand.h&gt;
# include &lt;hand_test.h&gt;

void
test_hand_judge(void)
{
  struct Hand_test *tests = hand_test_data;

  while ( tests-&gt;y != 0 )
    {
      Hand h = hand_test_hand_new(tests-&gt;h);
      PokerHand y = tests-&gt;y;;
      char *s = tests-&gt;s;

      h = hand_sort(h);

      {
	int hj = hand_judge(h);
	char *hs = hand_to_string(h);

	cut_set_message
	  ("test_judge: hand = %s, PokerHand = %s, y = %d, judge = %d",
	   hs, s, y, hj);
	cut_assert(hj==y);
	cut_assert(strcmp(hand_pokerhand_to_string(y), s)==0);
	tests++;
      }
    }
}
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-sec-37-4-9" class="outline-4">
<h4 id="sec-37-4-9">hand/src/judge.c</h4>
<div class="outline-text-4" id="text-37-4-9">
</div><div id="outline-container-sec-37-4-9-1" class="outline-5">
<h5 id="sec-37-4-9-1">必要なシステムライブラリのインタフェースを読む (定跡)</h5>
<div class="outline-text-5" id="text-37-4-9-1">
<div class="org-src-container">

<pre class="src src-c"># include &lt;stdio.h&gt;
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-37-4-9-2" class="outline-5">
<h5 id="sec-37-4-9-2">依存するモジュールのインタフェースを読む(定跡)</h5>
<div class="outline-text-5" id="text-37-4-9-2">
<div class="org-src-container">

<pre class="src src-c"># include &lt;card.h&gt;
# include &lt;hand.h&gt;
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-37-4-9-3" class="outline-5">
<h5 id="sec-37-4-9-3">定数の宣言 (定跡)</h5>
<div class="outline-text-5" id="text-37-4-9-3">
<div class="org-src-container">

<pre class="src src-c"># define TRUE 1
# define FALSE 0
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-37-4-9-4" class="outline-5">
<h5 id="sec-37-4-9-4">このファイル内でのみ有効な関数の宣言 (定跡)</h5>
<div class="outline-text-5" id="text-37-4-9-4">
<p>
hand_calc_pairs, hand_is_stright, hand_is_flush は hand_judge だけ
が知っていればいい。他には見せないようにする。
</p>

<div class="org-src-container">

<pre class="src src-c">// ペアかストレート、フラッシュを判定する

static int hand_calc_pairs(Hand); 
// 5: high card
// 7: one pair
// 9: two pair
// 11: three cards
// 13: full house
// 17: four cards
static int hand_is_straight(Hand);
static int hand_is_flush(Hand);
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-37-4-9-5" class="outline-5">
<h5 id="sec-37-4-9-5">役の計算</h5>
<div class="outline-text-5" id="text-37-4-9-5">
<div class="org-src-container">

<pre class="src src-c">//手札の役の計算
PokerHand hand_judge(Hand h)
{
  {
    int s, f;

    // ストレートとフラッシュの判定

    s = hand_is_straight(h);
    f = hand_is_flush(h);

    if (s)
      {
	if (f) 
	  {
	    return StraightFlush;
	  }
	else
	  {
	    return Straight;
	  }
      }
    if (f)
      {
	return Flush;
      }
  }
  // ペア系の判定
  {
    int p = hand_calc_pairs(h);
    switch(p)
      {
      case 5:
	return HighCard;
      case 7:
	return OnePair;
      case 9:
	return TwoPairs;
      case 11:
	return ThreeCards;
      case 13:
	return FullHouse;
      case 17:
	return FourCards;
      default:
	printf("No such pairs (%d)!\n", p);
      }
  }
  return 0;
}

int hand_calc_pairs(Hand h)
{
  int p=0;
  int i, j;

  for(i=0; i&lt;CardsInHand; i++) 
    {
      for(j=0; j&lt;CardsInHand; j++)
	{
	  if (card_no(hand_card(h, i))==card_no(hand_card(h, j)))
	    {
	      p++;
	    }
	}
    }
  return p;
}

int hand_is_straight(Hand h)
{
  int i;

  for (i=0; i&lt;4; i++)
    {
      if (card_no(hand_card(h, i))!=(card_no(hand_card(h, i+1))-1))
	{
	  return FALSE;
	}
    }
  return TRUE;
}

int hand_is_flush(Hand h)
{
  int i;

  for (i=0; i&lt;(CardsInHand-1); i++)
    {
      if (card_suit(hand_card(h, i))!=card_suit(hand_card(h, i+1)))
	{
	  return FALSE;
	}
    }
  return TRUE;
}

// 役を文字列で表す

// 役名文字列の配列
static char *PokerHandNames[] = 
  { "",
  "HighCard",
  "OnePair",
  "TwoPairs",
  "ThreeCards",
  "Straight",
  "Flush",
  "FullHouse",
  "FourCards",
  "StraightFlush"
  };

char *hand_pokerhand_to_string(PokerHand yaku)
{
  return PokerHandNames[yaku];
}
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-sec-37-4-10" class="outline-4">
<h4 id="sec-37-4-10">hand/test/hand_test.h</h4>
<div class="outline-text-4" id="text-37-4-10">
<p>
hand_test_data.c はテスト用の手札データを生成するための機能で，
hand_test.h はそのための宣言をおこなっています。
</p>


<div class="org-src-container">

<pre class="src src-c"># include &lt;hand.h&gt;
</pre>
</div>

<ul class="org-ul">
<li>hand のインタフェースを読みます。
</li>
</ul>

<div class="org-src-container">

<pre class="src src-c">// 役のテストの組を作るためのデータ構造と関数

// card
struct t_card {char *suit; char *no;} ;

// hand 
struct t_hand {struct t_card c[5];};
</pre>
</div>

<ul class="org-ul">
<li>card, hand の機能を使わず，テスト側で独自にカードや5枚のカードを
表現するための構造たいです。
</li>
</ul>

<div class="org-src-container">

<pre class="src src-c">// 手札と役と役の名前
struct Hand_test { PokerHand y; char *s; struct t_hand h; };
</pre>
</div>

<ul class="org-ul">
<li>手札 (h) に対し，期待される役 (y), と 手札文字列 (s) を構造体でまと
めたものです。
</li>
<li>テストデータをみやすく管理しやすくします。
</li>
</ul>

<div class="org-src-container">

<pre class="src src-c">extern struct Hand_test hand_test_data[];;
</pre>
</div>
<ul class="org-ul">
<li>テスト用の Hand_test の配列です。
</li>
<li>実際の値は，hand_test_data.c で与えられます。
</li>
</ul>

<div class="org-src-container">

<pre class="src src-c">Hand hand_test_hand_new(struct t_hand hs);
</pre>
</div>
<ul class="org-ul">
<li>5枚のカードから手札を作る関数です。
</li>
</ul>
</div>
</div>





<div id="outline-container-sec-37-4-11" class="outline-4">
<h4 id="sec-37-4-11">hand/test/hand_test_data.c</h4>
<div class="outline-text-4" id="text-37-4-11">
</div><div id="outline-container-sec-37-4-11-1" class="outline-5">
<h5 id="sec-37-4-11-1">利用ライブライのヘッダを読む</h5>
<div class="outline-text-5" id="text-37-4-11-1">
<div class="org-src-container">

<pre class="src src-c"># include &lt;string.h&gt;
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-37-4-11-2" class="outline-5">
<h5 id="sec-37-4-11-2">利用モジュールのヘッダを読む</h5>
<div class="outline-text-5" id="text-37-4-11-2">
<div class="org-src-container">

<pre class="src src-c"># include &lt;card.h&gt;
# include &lt;hand.h&gt;
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-37-4-11-3" class="outline-5">
<h5 id="sec-37-4-11-3">手札テストデータ操作用ヘッダを読む</h5>
<div class="outline-text-5" id="text-37-4-11-3">
<div class="org-src-container">

<pre class="src src-c"># include &lt;hand_test.h&gt;
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-37-4-11-4" class="outline-5">
<h5 id="sec-37-4-11-4">5枚のカードの組のデータ定義</h5>
<div class="outline-text-5" id="text-37-4-11-4">
<p>
5枚のカードの組の初期化データに名前をつける
</p>

<div class="org-src-container">

<pre class="src src-c"># define TEST_HIGHCARD \
  {{{"CLUB", "2"}, {"CLUB", "3"}, {"CLUB", "4"}, {"CLUB", "5"}, {"DIAMOND", "7"}}}

# define TEST_ONEPAIR                                                   \
  {{{"CLUB", "2"}, {"CLUB", "3"}, {"CLUB", "4"}, {"CLUB", "1"}, {"SPADE", "1"}}}

# define  TEST_TWOPAIRS \
  {{{"CLUB", "2"}, {"CLUB", "3"}, {"CLUB", "4"}, {"DIAMOND", "2"}, {"DIAMOND", "3"}}}

# define  TEST_THREECARDS \
  {{{"CLUB", "2"}, {"CLUB", "3"}, {"CLUB", "4"}, {"DIAMOND", "2"}, {"HEART", "2"}}}

# define  TEST_FULLHOUSE \
  {{{"CLUB", "2"}, {"DIAMOND", "2"}, {"HEART", "2"}, {"CLUB", "3"}, {"DIAMOND", "3"}}}

# define  TEST_FOURCARDS \
  {{{"CLUB", "2"}, {"CLUB", "3"}, {"DIAMOND", "2"}, {"HEART", "2"}, {"SPADE", "2"}}}

# define TEST_STRAIGHTFLUSH \
  {{{"CLUB", "2"}, {"CLUB", "3"}, {"CLUB", "4"}, {"CLUB", "5"}, {"CLUB", "6"}}}
</pre>
</div>
</div>
</div>


<div id="outline-container-sec-37-4-11-5" class="outline-5">
<h5 id="sec-37-4-11-5">テストデータの初期化</h5>
<div class="outline-text-5" id="text-37-4-11-5">
<p>
構造体の配列の初期化データを書く:
</p>

<div class="org-src-container">

<pre class="src src-c">struct Hand_test hand_test_data[10] = {
  { .y = HighCard, .s = "HighCard",   .h = TEST_HIGHCARD},
  { .y = OnePair, .s = "OnePair", .h = TEST_ONEPAIR},
  { .y = TwoPairs, .s = "TwoPairs",  .h = TEST_TWOPAIRS},
  { .y = ThreeCards, .s = "ThreeCards", .h = TEST_THREECARDS}, 
  { .y = FullHouse, .s =  "FullHouse", .h = TEST_FULLHOUSE}, 
  { .y = FourCards, .s = "FourCards", .h = TEST_FOURCARDS },
  { .y = StraightFlush, .s = "StraightFlush", .h = TEST_STRAIGHTFLUSH}
};
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-37-4-11-6" class="outline-5">
<h5 id="sec-37-4-11-6">テストデータから Hand型データを生成する機能</h5>
<div class="outline-text-5" id="text-37-4-11-6">
<div class="org-src-container">

<pre class="src src-c">Hand hand_test_hand_new(struct t_hand hs)
{
  int i;
  Hand h = hand_new();

  for(i=0;i&lt;CardsInHand;i++)
    {
      enum e_Suit s = card_suit_new_from_string(hs.c[i].suit);
      enum e_No n = card_no_new_from_string(hs.c[i].no);

      h = hand_add(h, card_new(s, n));
    }
  return h;
}
</pre>
</div>
</div>
</div>
</div>
</div>

<div id="outline-container-sec-37-5" class="outline-3">
<h3 id="sec-37-5"><span class="section-number-3">37.5</span> Pokerモジュールの開発</h3>
<div class="outline-text-3" id="text-37-5">
</div><div id="outline-container-sec-37-5-1" class="outline-4">
<h4 id="sec-37-5-1">ゲームモジュール</h4>
<div class="outline-text-4" id="text-37-5-1">
</div><div id="outline-container-sec-37-5-1-1" class="outline-5">
<h5 id="sec-37-5-1-1">機能、設計，実装</h5>
<div class="outline-text-5" id="text-37-5-1-1">
<p>
<a href="http://wiki.cis.iwate-u.ac.jp/~wiki/prog.cgi?%E3%82%B2%E3%83%BC%E3%83%A0%E3%83%A2%E3%82%B8%E3%83%A5%E3%83%BC%E3%83%AB">http://wiki.cis.iwate-u.ac.jp/~wiki/prog.cgi?%E3%82%B2%E3%83%BC%E3%83%A0%E3%83%A2%E3%82%B8%E3%83%A5%E3%83%BC%E3%83%AB</a>
</p>
</div>

<div id="outline-container-sec-37-5-1-1-1" class="outline-6">
<h6 id="sec-37-5-1-1-1">ゲームの説明からゲームに関する部分を取り出す</h6>
<div class="outline-text-6" id="text-37-5-1-1-1">
<ul class="org-ul">
<li>(5人のプレーヤーに) 手札を配り，
</li>

<li>2回までの，(5人のプレーヤーの)手札の交換後，
</li>

<li>(5人のプレーヤーの手札役を判定し)
</li>

<li>(5人のプレーヤーの)手札役の強い順に，プレーヤ名を表示する
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-37-5-1-1-2" class="outline-6">
<h6 id="sec-37-5-1-1-2">poker モジュールの機能</h6>
<div class="outline-text-6" id="text-37-5-1-1-2">
<ul class="org-ul">
<li>ゲームの流れを作る
<ul class="org-ul">
<li>手札を配る 
</li>
<li>手札の何枚かを交換する 
</li>
<li>役の判定 
</li>
<li>表示 
</li>
</ul>
</li>
<li>プレーヤーを管理する 
<ul class="org-ul">
<li>手札 
</li>
<li>名前 
</li>
</ul>
</li>
</ul>
</div>
</div>


<div id="outline-container-sec-37-5-1-1-3" class="outline-6">
<h6 id="sec-37-5-1-1-3">poker モジュールの機能の名前</h6>
<div class="outline-text-6" id="text-37-5-1-1-3">
<ul class="org-ul">
<li>ゲームの流れを作る poker()
<ul class="org-ul">
<li>手札を配る  poker_deal()
</li>
<li>手札の何枚かを交換する  poker_exchange()
</li>
<li>役の判定  poker_judge()
</li>
<li>表示  poker_display()
</li>
</ul>
</li>
<li>プレーヤーを管理する Player
<ul class="org-ul">
<li>手札 .hand
</li>
<li>名前 .name
</li>
</ul>
</li>
</ul>
</div>
</div>


<div id="outline-container-sec-37-5-1-1-4" class="outline-6">
<h6 id="sec-37-5-1-1-4">poker モジュールの機能のインタフェース</h6>
<div class="outline-text-6" id="text-37-5-1-1-4">
<ul class="org-ul">
<li>ゲームの流れを作る void poker(void)
<ul class="org-ul">
<li>手札を配る  void poker_deal(void)
</li>
<li>手札の何枚かを交換する  void poker_exchange(void)
</li>
<li>役の判定  poker_judge(void)
</li>
<li>表示  poker_display(void)
</li>
</ul>
</li>

<li>プレーヤーを管理する Player players[NO_PLAYERS]
<ul class="org-ul">
<li>手札 .hand
</li>
<li>名前 .name
</li>
</ul>
</li>
</ul>
</div>
</div>
</div>

<div id="outline-container-sec-37-5-1-2" class="outline-5">
<h5 id="sec-37-5-1-2">~/progs/game/poker が開発ディレクトリ</h5>
<div class="outline-text-5" id="text-37-5-1-2">
<p>
ここからは，テストを書かずに，実行プログラムを作っていきましょう。
</p>

<ul class="org-ul">
<li>game/poker/poker.h
<ul class="org-ul">
<li>Player の宣言
</li>
<li>pokerの機能を表す関数の宣言
</li>
</ul>
</li>

<li>game/poker/poker.c  
<ul class="org-ul">
<li>main
</li>
<li>poker_init
</li>
<li>poker_deal
</li>
<li>poker_exchange
</li>
<li>poker_judge
</li>
<li>poker_display
</li>
</ul>
</li>

<li>game/poker/Makefile
<ul class="org-ul">
<li>pokerプログラムを作成することが目的
</li>
</ul>
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-37-5-1-3" class="outline-5">
<h5 id="sec-37-5-1-3">~/progs/game/Makefile</h5>
<div class="outline-text-5" id="text-37-5-1-3">
<p>
各モジュールの管理方法を Makefile に書きましょう。
</p>
</div>
</div>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="author">Author: suzuki@cis.iwate-u.ac.jp</p>
<p class="date">Created: 2016-10-03 月 17:54</p>
<p class="creator"><a href="http://www.gnu.org/software/emacs/">Emacs</a> 24.5.1 (<a href="http://orgmode.org">Org</a> mode 8.2.10)</p>
<p class="validation"><a href="http://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
