<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"https://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="https://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<title>カード表示問題のテストによる開発</title>
<!-- 2017-01-10 火 15:24 -->
<meta  http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta  name="generator" content="Org-mode" />
<meta  name="author" content="Masayuki Suzuki" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center; }
  .todo   { font-family: monospace; color: red; }
  .done   { color: green; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  pre.src-sh:before    { content: 'sh'; }
  pre.src-bash:before  { content: 'sh'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-R:before     { content: 'R'; }
  pre.src-perl:before  { content: 'Perl'; }
  pre.src-java:before  { content: 'Java'; }
  pre.src-sql:before   { content: 'SQL'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.right  { text-align: center;  }
  th.left   { text-align: center;   }
  th.center { text-align: center; }
  td.right  { text-align: right;  }
  td.left   { text-align: left;   }
  td.center { text-align: center; }
  dt { font-weight: bold; }
  .footpara:nth-child(2) { display: inline; }
  .footpara { display: block; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  /*]]>*/-->
</style>
<link rel="stylesheet" type="text/css" href="styles/readtheorg/css/htmlize.css"/>
<link rel="stylesheet" type="text/css" href=".././styles/sos/css/sos.css">
<link rel="stylesheet" type="text/css" href=".././styles/bigblow/css/hideshow.css"/>
<script type="text/javascript" src=".././styles/bigblow/js/jquery-1.11.0.min.js"></script>
<script type="text/javascript" src=".././styles/bigblow/js/jquery-ui-1.10.2.min.js"></script>
<script type="text/javascript" src=".././styles/bigblow/js/jquery.localscroll-min.js"></script>
<script type="text/javascript" src=".././styles/bigblow/js/jquery.scrollTo-1.4.3.1-min.js"></script>
<script type="text/javascript" src=".././styles/bigblow/js/jquery.zclip.min.js"></script>
<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.4/js/bootstrap.min.js"></script>
<script type="text/javascript" src="styles/lib/js/jquery.stickytableheaders.min.js"></script>
<script type="text/javascript" src=".././styles/bigblow/js/hideshow.js"></script>
<script type="text/javascript" src=".././styles/lib/js/jquery.stickytableheaders.min.js"></script>
<script type="text/javascript" src=".././styles/sos/js/hideshow.js"></script>
<script type="text/javascript" src=".././styles/sos/js/sos.js"></script>
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2013 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="content">
<h1 class="title">カード表示問題のテストによる開発</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">1. はじめに</a></li>
<li><a href="#sec-2">2. ディレクトリ構成</a></li>
<li><a href="#sec-3">3. Makefileを作る</a></li>
<li><a href="#sec-4">4. 開発を機能に分ける</a></li>
<li><a href="#sec-5">5. 機能のテスト駆動開発 (概論)</a></li>
<li><a href="#sec-6">6. スーツを数値にする機能のテストと実装</a></li>
<li><a href="#sec-7">7. テスト作成</a></li>
<li><a href="#sec-8">8. test/Makefileの作成</a></li>
<li><a href="#sec-9">9. 最初の make</a></li>
<li><a href="#sec-10">10. cutterによるテスト</a></li>
<li><a href="#sec-11">11. テストのビルド</a></li>
<li><a href="#sec-12">12. card_suit_new_from_string の実装</a>
<ul>
<li><a href="#sec-12-1">12.1. src/card.h の作成 <code>card/card.h</code></a></li>
<li><a href="#sec-12-2">12.2. test/test_card.cの変更</a></li>
<li><a href="#sec-12-3">12.3. test/Makefileの変更</a></li>
<li><a href="#sec-12-4">12.4. src/card.c の作成</a></li>
<li><a href="#sec-12-5">12.5. src/Makefile</a></li>
<li><a href="#sec-12-6">12.6. テスト test/test_card.so のビルド</a></li>
</ul>
</li>
<li><a href="#sec-13">13. テスト</a></li>
<li><a href="#sec-14">14. テストと再設計</a></li>
<li><a href="#sec-15">15. トランプ番号を数値に</a></li>
<li><a href="#sec-16">16. トランプ番号を数値に</a>
<ul>
<li><a href="#sec-16-1">16.1. 機能とテストの追加</a>
<ul>
<li><a href="#sec-16-1-1">16.1.1. test/Makefileの更新</a></li>
<li><a href="#sec-16-1-2">16.1.2. test/test_card.o の更新</a></li>
<li><a href="#sec-16-1-3">16.1.3. テスト (test/test_card.so) のビルド</a></li>
</ul>
</li>
<li><a href="#sec-16-2">16.2. card_no_new_from_string の実装</a>
<ul>
<li><a href="#sec-16-2-1">16.2.1. src/card.h の更新</a></li>
<li><a href="#sec-16-2-2">16.2.2. test/test_card.cの変更</a></li>
<li><a href="#sec-16-2-3">16.2.3. card_no_new_from_string の実装 (src/card.c の更新)</a></li>
<li><a href="#sec-16-2-4">16.2.4. src/Makefile</a></li>
<li><a href="#sec-16-2-5">16.2.5. テスト test/test_card.so の再ビルド</a></li>
</ul>
</li>
<li><a href="#sec-16-3">16.3. テスト</a>
<ul>
<li><a href="#sec-16-3-1">16.3.1. テストと再設計</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#sec-17">17. トランプ・カードを作成</a></li>
<li><a href="#sec-18">18. 機能の追加とテストの作成</a>
<ul>
<li><a href="#sec-18-1">18.1. card_new のテストを書く</a></li>
<li><a href="#sec-18-2">18.2. card_new, card_suit, card_no のインタフェースを決める</a></li>
<li><a href="#sec-18-3">18.3. Card型を定義する</a></li>
<li><a href="#sec-18-4">18.4. テスト全体プログラムの確認</a></li>
<li><a href="#sec-18-5">18.5. test/Makefile の確認</a></li>
<li><a href="#sec-18-6">18.6. test/test_card.o の作成</a></li>
</ul>
</li>
<li><a href="#sec-19">19. card_new の実装</a>
<ul>
<li><a href="#sec-19-1">19.1. card/card.h の更新</a></li>
<li><a href="#sec-19-2">19.2. card_new の実装 (src/card.cの更新)</a></li>
<li><a href="#sec-19-3">19.3. card_suit の実装 (src/card.cの更新)</a></li>
<li><a href="#sec-19-4">19.4. card_no の実装 (src/card.cの更新)</a></li>
<li><a href="#sec-19-5">19.5. src/card.c 全体</a></li>
<li><a href="#sec-19-6">19.6. src/Makefile</a></li>
<li><a href="#sec-19-7">19.7. src/card.o の作成</a></li>
<li><a href="#sec-19-8">19.8. src/libcard.a の作成</a></li>
</ul>
</li>
<li><a href="#sec-20">20. テスト</a>
<ul>
<li><a href="#sec-20-1">20.1. test/test_card.so のビルド</a></li>
<li><a href="#sec-20-2">20.2. テストの実行</a></li>
<li><a href="#sec-20-3">20.3. テストと再設計</a></li>
</ul>
</li>
<li><a href="#sec-21">21. トランプ・カードを文字列に</a>
<ul>
<li><a href="#sec-21-1">21.1. 設計</a>
<ul>
<li><a href="#sec-21-1-1">21.1.1. 機能の名前と構造</a></li>
<li><a href="#sec-21-1-2">21.1.2. 関数の引数と戻り値の型 (APIの設計)</a></li>
</ul>
</li>
<li><a href="#sec-21-2">21.2. テストによる開発</a></li>
</ul>
</li>
<li><a href="#sec-22">22. トランプ・カードを文字列に</a></li>
<li><a href="#sec-23">23. 機能の追加とテストの作成</a>
<ul>
<li><a href="#sec-23-1">23.1. card_to_string のテストを書く</a></li>
<li><a href="#sec-23-2">23.2. card_to_string のインタフェースを決める</a></li>
<li><a href="#sec-23-3">23.3. テスト全体プログラムの確認</a></li>
<li><a href="#sec-23-4">23.4. test/Makefile の確認</a></li>
<li><a href="#sec-23-5">23.5. test/test_card.o の作成</a></li>
</ul>
</li>
<li><a href="#sec-24">24. card_to_string の実装</a>
<ul>
<li><a href="#sec-24-1">24.1. card/card.h の更新</a></li>
<li><a href="#sec-24-2">24.2. card_to_string の実装 (src/card.cの更新)</a></li>
<li><a href="#sec-24-3">24.3. src/card.c 全体</a></li>
<li><a href="#sec-24-4">24.4. src/Makefile</a></li>
<li><a href="#sec-24-5">24.5. src/card.o の作成</a></li>
<li><a href="#sec-24-6">24.6. src/libcard.a の作成</a></li>
</ul>
</li>
<li><a href="#sec-25">25. テスト</a>
<ul>
<li><a href="#sec-25-1">25.1. test/test_card.so のビルド</a></li>
<li><a href="#sec-25-2">25.2. テストの実行</a></li>
<li><a href="#sec-25-3">25.3. テストと再設計</a></li>
</ul>
</li>
<li><a href="#sec-26">26. card_display_simple 問題の解の作成</a></li>
<li><a href="#sec-27">27. card_display_multi</a></li>
<li><a href="#sec-28">28. card_display_sort</a></li>
<li><a href="#sec-29">29. 複数のカードをソートする機能</a></li>
<li><a href="#sec-30">30. 機能の追加とテストの作成</a>
<ul>
<li><a href="#sec-30-1">30.1. cards_sort のテストを書く</a></li>
<li><a href="#sec-30-2">30.2. テスト全体プログラムの確認</a></li>
<li><a href="#sec-30-3">30.3. test/Makefile の確認</a></li>
<li><a href="#sec-30-4">30.4. test/test_sort.o の作成</a></li>
</ul>
</li>
<li><a href="#sec-31">31. cards_sort，card_compare の実装</a>
<ul>
<li><a href="#sec-31-1">31.1. card/card.h の更新</a></li>
<li><a href="#sec-31-2">31.2. cards_sort の実装 (src/cards.cの作成)</a></li>
<li><a href="#sec-31-3">31.3. card_compare の実装</a></li>
<li><a href="#sec-31-4">31.4. cards.c の確認</a></li>
<li><a href="#sec-31-5">31.5. src/Makefile</a></li>
<li><a href="#sec-31-6">31.6. src/cards.o の作成</a></li>
<li><a href="#sec-31-7">31.7. src/libcard.a の作成</a></li>
</ul>
</li>
<li><a href="#sec-32">32. テスト</a>
<ul>
<li><a href="#sec-32-1">32.1. test/test_sort.so のビルド</a></li>
<li><a href="#sec-32-2">32.2. テストの実行</a></li>
<li><a href="#sec-32-3">32.3. テストと再設計</a></li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1"><span class="section-number-2">1</span> はじめに</h2>
<div class="outline-text-2" id="text-1">
<p>
テスト駆動開発の例として，card_display_simple問題を
テスト駆動開発してましょう。
</p>

<p>
その上で，わずかな変更を加えることで，card_display_multi 問題と，
card_display_sort 問題を，テスト駆動開発してましょう。
</p>

<p>
そして，その開発を通して，カードモジュールが出来上がることを実感して
みましょう。
</p>
</div>
</div>

<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2"><span class="section-number-2">2</span> ディレクトリ構成</h2>
<div class="outline-text-2" id="text-2">
<p>
まず、プログラムを作成するためのディレクトリを用意する。ディレクトリは
simple/ とする。
</p>

<div class="org-src-container">

<pre class="src src-sh"># ~/
mkdir -p ~/progs/card_display/simple
cd ~/progs/card_display/simple
pwd
</pre>
</div>

<p>
続いて、simple/ ディレクトリ以下に，プログラム用ディレクトリ src/，テストプログラム用
ディレクトリ test/ を作成する。
</p>

<div class="org-src-container">

<pre class="src src-sh"># ~/progs/card_display/simple
mkdir -p src test
</pre>
</div>

<p>
つまり、ディレクトリ構成は以下のようになる。
</p>

<pre class="example">
simple/ --+- src/  ソースファイル用ディレクトリ
          |
          +- test/ テストプログラム用ディレクトリ
</pre>
</div>
</div>

<div id="outline-container-sec-3" class="outline-2">
<h2 id="sec-3"><span class="section-number-2">3</span> Makefileを作る</h2>
<div class="outline-text-2" id="text-3">
<p>
simple/ ディレクトリに Makefileを作成します。
目的は二つ，カードのテストをすることと，ディレクトリ配下をきれいにするこ
とです。
</p>

<div class="org-src-container">

<pre class="src src-makefile"># ~/progs/card_display/simple/Makefile
.PHONY: clean card_test

card_test:
	(cd src; make)
	(cd test; make) 
	cutter -v v test/

clean:
	(cd src; make clean)
	(cd test; make clean)
	rm -f *.o *.so *~ \#* .gch
</pre>
</div>

<p>
src/Makefileを作ります。まずの目的は，src/ディレクトリをきれいにすることで
す:
</p>

<div class="org-src-container">

<pre class="src src-makefile"># src/Makefile
.PHONY: clean 

clean:
	rm -f *.o *.so *~ \#* *.gch
</pre>
</div>

<p>
test/Makefileを作ります: 同様にまずの目的は，test/ディレクトリをきれ
いにすることです:
</p>

<div class="org-src-container">

<pre class="src src-makefile"># test/Makefile
.PHONY: clean 

clean:
	rm -f *.o *.so *~ \#* *.gch
</pre>
</div>

<p>
では，Makefile が正しく書けているか確かめるために make してみましょう。
</p>

<div class="org-src-container">

<pre class="src src-sh"># ~/progs/card_display/simple/
make
</pre>
</div>

<p>
それぞれのディレクトリで make clean して，空のテストをします:
</p>

<p>
最初のテストは，成功です。開発とテストに必要なディレクトリ，Makefile を
作成し，空のテストを行いました。
</p>
</div>
</div>

<div id="outline-container-sec-4" class="outline-2">
<h2 id="sec-4"><span class="section-number-2">4</span> 開発を機能に分ける</h2>
<div class="outline-text-2" id="text-4">
<p>
さて次は，card_display_simpleを，機能に分け，機能をテストしな
がら開発します。(<a href="card-display/">card-display/</a>)
</p>

<p>
下記の機能に分けてみます:
</p>

<ol class="org-ol">
<li>スーツを数値にする機能，
</li>
<li>トランプ番号を数値にする機能，
</li>
<li>トランプ・カード型を表す機能，
</li>
<li>スーツと番号からトランプカードを作成する機能
</li>
<li>トランプ・カードを文字列で表す機能。
</li>
</ol>


<p>
これらの機能を組み合わせてcard_display_simpleプログラムが開発できま
す。
</p>

<p>
実は，この機能分けが一番重要かもしれません。最初から全ての機能が取り
出せなくてもいいと思います。必要そうな機能を一つづつためしてもいいで
す。自分で丁度いいと思うことが大切です。
</p>
</div>
</div>

<div id="outline-container-sec-5" class="outline-2">
<h2 id="sec-5"><span class="section-number-2">5</span> 機能のテスト駆動開発 (概論)</h2>
<div class="outline-text-2" id="text-5">
<p>
これらの機能をひとつづつ確かめながら開発を進めるのが，テスト駆動開
発です。具体的な開発を進める前に，おおまかな流れを説明します。
</p>

<p>
進め方は:
</p>

<dl class="org-dl">
<dt> Makefileの作成 </dt><dd>テストと実装をビルドし，テストを実行するための
Makefile を書く。

<p>
./Makefile には src/, test/ でビルドするルールを書き，
cutter によりテストを実行する規則を書く。
</p>
</dd>

<dt> test/Makefileの作成 </dt><dd>テストをビルドするための規則を書く。

<p>
test/Makefile に test_card.c から test_card.so を作成し，
cutter によるテストの実行するための規則を書く。
</p>
</dd>

<dt> 機能テストの作成 </dt><dd>機能が正しく働くことを確かめるテスト (プログラム) を書く。このこ
とにより，*機能の使い方*を決める。

<p>
test/test_card.c に上の5つの機能テストを作成していく。
</p>
</dd>

<dt> テスト(のみ)のビルド </dt><dd>ビルドし，コンパイル・エラーが取れ，確かめ
る機能の関数のみが未定義の状態にする。
</dd>

<dt> src/Makefile </dt><dd>機能の実装をビルドするための規則を書く。

<p>
src/Makefile に card.c, card.h から libcard.a を
作成する規則を書く。
</p>
</dd>

<dt> インタフェースの決定 </dt><dd>確かめる機能の関数を使うために必要最小限
のインタフェースを決める。

<p>
test/test_card.c から取り出し，src/card.h に書く。
</p>
</dd>

<dt> 機能の実装 </dt><dd>インタフェースに従がい，機能を関数として実装する。

<p>
src/card.c を作成する。
</p>
</dd>

<dt> 機能の提供 </dt><dd>実装をビルドし，ライブラリとヘッダファイルで機能を提
供する。

<p>
src/Makefile にルールを書き，
src/libcard.aを作成する。
</p>
</dd>

<dt> テストのビルドと実行 </dt><dd></dd>
</dl>

<p>
では，続く節で，5つの機能のテスト駆動開発をおこないます。
</p>
</div>
</div>

<div id="outline-container-sec-6" class="outline-2">
<h2 id="sec-6"><span class="section-number-2">6</span> スーツを数値にする機能のテストと実装</h2>
<div class="outline-text-2" id="text-6">
<p>
まず最初は，文字列で表されたスーツを，プログラム内部での数値に変換す
る機能のテストです。
</p>

<p>
あわせてテスト等のビルドのためMakefileを作成していきます。
</p>
</div>
</div>

<div id="outline-container-sec-7" class="outline-2">
<h2 id="sec-7"><span class="section-number-2">7</span> テスト作成</h2>
<div class="outline-text-2" id="text-7">
<p>
テストは，test/test_card.c に作成します。
</p>

<p>
機能の名前を card_suit_new_from_string とし,
card_suit_new_from_string のAPIを決めるため，
card_suit_new_from_string が満たすテストを書きます:
</p>

<div class="org-src-container">

<pre class="src src-c">// test/test_card.c
  cut_assert(card_suit_new_from_string("SPADE")==SPADE);
</pre>
</div>

<p>
cut_assert は引数の値が真ならばテスト成功，偽ならばテスト失敗
とする cutter の機能です。失敗のときは，情報を提供してくれます。
</p>

<p>
card_suit_new_from_stringを関数の形で書けたので，関数の型を決めま
す。
</p>

<p>
戻り値の型は int，与える引数はスーツを示す文字列なので:
</p>

<div class="org-src-container">

<pre class="src src-c">int card_suit_new_from_string(char *);
</pre>
</div>

<p>
そして，cutterが提供する機能を使うためのインタフェースをインクルー
ドします:
</p>

<div class="org-src-container">

<pre class="src src-c"># include &lt;cutter.h&gt;
</pre>
</div>

<p>
テストに使う定数は，列挙型 (<a href="https://ja.wikipedia.org/wiki/%E5%88%97%E6%8C%99%E5%9E%8B">列挙型 - Wikipedia</a>) で書いてみます:
</p>

<div class="org-src-container">

<pre class="src src-c" id="suit_new_e_suit">enum e_Suit {CLUB=1, DIAMOND, HEART, SPADE};
</pre>
</div>
<p>
まだ列挙型を使かったことがないかもしれませんが，便利なので憶えましょ
う。これは，define で定義する次のコードと似ています:
</p>
<div class="org-src-container">

<pre class="src src-c"># define SPADE 4
# define HEART 3
# define DIAMOND 2
# define CLUB 1
</pre>
</div>

<p>
次に，テストに必要なことを記述します:
</p>

<ul class="org-ul">
<li>テスト・フレームワークとして cutter を使うので，必要な宣言をインク
ルードする:
</li>
</ul>

<div class="org-src-container">

<pre class="src src-c">// test/test_card.c
# include &lt;cutter.h&gt;
</pre>
</div>

<ul class="org-ul">
<li>テストを関数にする。cutterからの要請で，関数名は test_ で始まる
名前で，型は，void (void) です:
</li>
</ul>

<div class="org-src-container">

<pre class="src src-c">// test/test_card.c
void
test_card_suit_new_from_string(void)
{
  cut_set_message("文字列からスーツを作成する。");
  cut_assert_true(card_suit_new_from_string("SPADE")==SPADE);
}
</pre>
</div>

<p>
これだけです。
</p>

<p>
ここまでで，test/test_card.c の中身は:
</p>

<div class="org-src-container">

<pre class="src src-c">// test/test_card.c
# include &lt;cutter.h&gt;

enum e_Suit {CLUB=1, DIAMOND, HEART, SPADE};

enum e_Suit card_suit_new_from_string(char *);

void
test_card_suit_new_from_string(void)
{
  cut_set_message("文字列からスーツを作成する。");
  cut_assert_true(card_suit_new_from_string("SPADE")==SPADE);
}
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-8" class="outline-2">
<h2 id="sec-8"><span class="section-number-2">8</span> test/Makefileの作成</h2>
<div class="outline-text-2" id="text-8">
<p>
test/Makefile は，とりあえず，test_card.c をコンパイルするこ
とです:
</p>

<p>
Makefileに次のように規則を書き加えます:
</p>

<div class="org-src-container">

<pre class="src src-makefile"># test/Makefile
test_card.o: test_card.c
	gcc -c $&lt;
</pre>
</div>

<p>
test_card.c がインクルードしている cutter.h がどこにあるのかは，次
のコマンドを実行するとわかります:
</p>

<div class="org-src-container">

<pre class="src src-sh"># ~/progs/CardDisplay/simple/
pkg-config cutter --cflags
</pre>
</div>

<pre class="example">
-I/usr/include/cutter  
</pre>


<p>
cutter.hをインクルードするためのコンパイラへの指示が出力されていま
す。
</p>

<p>
これをMakefileに記述します:
</p>

<div class="org-src-container">

<pre class="src src-makefile"># test/Makefile
.PHONY: clean 
CFLAGS = -fPIC `pkg-config cutter --cflags`

test_card.o: test_card.c
	gcc -c $&lt; $(CFLAGS)

clean:
	rm -f *.o *.so *~ \#* *.gch
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-9" class="outline-2">
<h2 id="sec-9"><span class="section-number-2">9</span> 最初の make</h2>
<div class="outline-text-2" id="text-9">
<p>
test/{test_card.c, Makefile}ができたので，make してみましょう:
</p>

<div class="org-src-container">

<pre class="src src-sh"># ~/progs/card_display/simple/test
make clean
make test_card.o
</pre>
</div>

<pre class="example">
rm -f *.o *.so *~ \#* *.gch
gcc -c test_card.c -fPIC -I../src `pkg-config cutter --cflags`
</pre>

<p>
コンパイルが成功し，test/test_card.o ができていれば，
test/test_card.o の中身を見てみましょう:
</p>

<div class="org-src-container">

<pre class="src src-sh"># ~/progs/card_display/simple/test
nm test_card.o
</pre>
</div>

<pre class="example">
                 U _GLOBAL_OFFSET_TABLE_
0000000000000200 r __PRETTY_FUNCTION__.3239
                 U _setjmp
                 U card_suit_new_from_string
                 U cut_assert_helper
                 U cut_test_context_current_peek
                 U cut_test_context_finish_user_message_jump
                 U cut_test_context_get_have_current_result
                 U cut_test_context_get_jump_buffer
                 U cut_test_context_in_user_message_jump
                 U cut_test_context_long_jump
                 U cut_test_context_pop_backtrace
                 U cut_test_context_process_current_result
                 U cut_test_context_push_backtrace
                 U cut_test_context_set_jump_buffer
                 U cut_test_context_set_user_message
                 U cut_test_context_start_user_message_jump
0000000000000000 T test_card_suit_new_from_string
</pre>

<p>
card_suit_from_string, cut_assert が未定義で，
test_card_suit_new_from_string が定義されているのがわかります。
</p>
</div>
</div>

<div id="outline-container-sec-10" class="outline-2">
<h2 id="sec-10"><span class="section-number-2">10</span> cutterによるテスト</h2>
<div class="outline-text-2" id="text-10">
<p>
cutter でテストしてみましょう:
</p>

<div class="org-src-container">

<pre class="src src-sh">cutter -v v test
</pre>
</div>

<pre class="example">
Finished in 0.000062 seconds (total: 0.000000 seconds)

0 test(s), 0 assertion(s), 0 failure(s), 0 error(s), 0 pending(s), 0 omission(s), 0 notification(s)
0% passed
</pre>

<p>
test(s)が0と表示されているので， test_card.oはテストとして認識され
ていないことが分かります。
</p>
</div>
</div>

<div id="outline-container-sec-11" class="outline-2">
<h2 id="sec-11"><span class="section-number-2">11</span> テストのビルド</h2>
<div class="outline-text-2" id="text-11">
<p>
cutter は，test_ で始まる動的ライブラリをテストと認めます。なので動的ライ
ブラリを作ります。そのために test/Makefileに規則を追加します:
</p>

<div class="org-src-container">

<pre class="src src-Makefile"># test/Makefile

CFLAGS = -fPIC `pkg-config cutter --cflags` 
LDFLAGS = `pkg-config --libs cutter`

test_card.so: test_card.o
	gcc -o $@ --shared $^ $(LDFLAGS)
</pre>
</div>

<p>
gcc に対するオプション -fPIC とか &#x2013;shared は動的ライブラリを作る
ためのものです。
</p>

<p>
ここまでで test/Makefile 全体は下記のようになります:
</p>

<div class="org-src-container">

<pre class="src src-makefile"># test/Makefile (2)
.PHONY: clean
CFLAGS = -fPIC `pkg-config cutter --cflags` 
LDFLAGS = `pkg-config --libs cutter`

test_card.so: test_card.o       
	gcc -o $@ --shared $^ $(LDFLAGS)

test_card.o: test_card.c
	gcc -c $&lt; $(CFLAGS)

clean:
	rm -f *.o *.so *~ \#* *.gch
</pre>
</div>

<p>
.soは動的ライブラリを示す拡張子で，gccへのオプション &#x2013;shared が動
的ライブラリの作成を意味しています。
</p>

<p>
変数LDFLAGSに，ローダへの指示を格納します。pkg-configは，システム
に組み込まれたパッケージの設定を見るためのコマンドで，&#x2013;libs は，
ライブラリとして使う場合のローダへの指示を出力してくれます:
</p>

<div class="org-src-container">

<pre class="src src-sh">pkg-config --libs cutter
</pre>
</div>

<p>
シェルコマンド中では，コマンドを``で括ることで，そのコマンドの実行
結果をその場所に埋め込むことを意味します。
</p>

<p>
変数LDFLAGS中の `pkg-config &#x2013;libs cutter`は，gcc コマンド 
中で参照されることで，cutterライブラリをリンクするため指示を埋め込
むことができます。
</p>

<p>
では，makeしてテストをビルドしてみましょう:
</p>

<p>
card_suit_new_from_string関数がまだ実装されていないため，みつから
ない旨のエラーが出て，test_card.so を作るための make は失敗します。
が，前進しています。cutterが提供する関数への参照は全て解決され，ま
だ未実装の card_suit_new_from_string のみ未解決となっていることを
理解してください。
</p>
</div>
</div>

<div id="outline-container-sec-12" class="outline-2">
<h2 id="sec-12"><span class="section-number-2">12</span> card_suit_new_from_string の実装</h2>
<div class="outline-text-2" id="text-12">
<p>
さて次は，機能 card_suit_new_from_string の実装です。
以下のように実装しましょう:
</p>
<ul class="org-ul">
<li>test/test_card.c を作成するときに決めたインタフェースをとりだし，
src/card.hを作成する。
</li>
<li>test/test_card.c の対応部分は # include &lt;card.h&gt; とする。
<ul class="org-ul">
<li>test/Makefile も変更する
</li>
</ul>
</li>
<li>src/card.hを遵守し，src/card.c を作成する。
</li>
<li>提供する機能を入れた src/libcard.a を作成する，Makefileを作成す
る
</li>
</ul>

<p>
<b>src/{card.h，libcard.a} で機能を提供します</b>
</p>
</div>

<div id="outline-container-sec-12-1" class="outline-3">
<h3 id="sec-12-1"><span class="section-number-3">12.1</span> src/card.h の作成 <code>card/card.h</code></h3>
<div class="outline-text-3" id="text-12-1">
<p>
test/test_card.c から card_suit_new_from_string に関する宣言を取り出し， 
src/card.h にします。
</p>

<div class="org-src-container">

<pre class="src src-c">// src/card.h
enum e_Suit {CLUB=1,DIAMOND,HEART,SPADE};

enum e_Suit card_suit_new_from_string(char *);
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-12-2" class="outline-3">
<h3 id="sec-12-2"><span class="section-number-3">12.2</span> test/test_card.cの変更</h3>
<div class="outline-text-3" id="text-12-2">
<p>
インタフェースの定義を，src/card.h に移し，定義の責任を src/ に移
します。test/ は，責任者の定義に従うという意味で，ヘッダファイル
をインクルードします:
</p>

<div class="org-src-container">

<pre class="src src-c">// test/test_card.c
# include &lt;card.h&gt;
</pre>
</div>

<p>
&lt;card.h&gt; は， コンパイラのインクルード・パス上の card.h という名前
のファイルを意味します。今 test/test_card.c にとって，&lt;card.h&gt; は
../src/card.h を意味します。ですが，次のように書いてはいけません:
</p>

<div class="org-src-container">

<pre class="src src-c"># include "../src/card.h"
</pre>
</div>

<p>
test/test_card.c は，下記のようになります:
</p>

<div class="org-src-container">

<pre class="src src-c">// test/test_card.c
# include &lt;cutter.h&gt;
# include &lt;card.h&gt;

void
test_card_suit_new_from_string(void)
{
  cut_set_message("文字列からスーツを作成する。");
  cut_assert(card_suit_new_from_string("SPADE")==SPADE);
  cut_assert(card_suit_new_from_string("HEART")==HEART);
  cut_assert(card_suit_new_from_string("DIAMOND")==DIAMOND);
  cut_assert(card_suit_new_from_string("CLUB")==CLUB);
}
</pre>
</div>

<p>
ここで，説明を簡略化するため，HEART, DIAMOND, CLUB のテストも追加してしま
いましたが，本来はひとつテストが通ってから，増やしていくべきです。
</p>
</div>
</div>

<div id="outline-container-sec-12-3" class="outline-3">
<h3 id="sec-12-3"><span class="section-number-3">12.3</span> test/Makefileの変更</h3>
<div class="outline-text-3" id="text-12-3">
<p>
src/card.hがインクルードできるようにインクルードパスをコンパイラに
指示します。具体的には，CFLAGSを以下のように書き換えます:
</p>

<div class="org-src-container">

<pre class="src src-make">CFLAGS = -fPIC -I../src `pkg-config cutter --cflags`
</pre>
</div>

<p>
変更後，makeして，以前と同じ状態であることを確かめておきましょう。
</p>
</div>
</div>

<div id="outline-container-sec-12-4" class="outline-3">
<h3 id="sec-12-4"><span class="section-number-3">12.4</span> src/card.c の作成</h3>
<div class="outline-text-3" id="text-12-4">
<p>
src/card.h に書かれている API を守って，card_suit_new_from_string
関数を実装します。
</p>

<p>
取り敢えず，与えられた文字列 suit_str と，スーツ文字列を比較して判
定することにします。
</p>

<div class="org-src-container">

<pre class="src src-c">// src/card.c
# include &lt;string.h&gt;
# include &lt;card.h&gt;

enum e_Suit
card_suit_new_from_string(char *suit_str)
{
  if (strcmp("CLUB", suit_str)==0)
    return CLUB;
  if (strcmp("DIAMOND", suit_str)==0)
    return DIAMOND;
  if (strcmp("HEART", suit_str)==0)
    return HEART;
  if (strcmp("SPADE", suit_str)==0)
    return SPADE;
  return 0;
}
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-12-5" class="outline-3">
<h3 id="sec-12-5"><span class="section-number-3">12.5</span> src/Makefile</h3>
<div class="outline-text-3" id="text-12-5">
<p>
src/card.c をコンパイルし，src/libcard.a を作成する規則を追加しま
しょう:
</p>

<div class="org-src-container">

<pre class="src src-makefile"># src/Makefile 
.PHONY: clean
CFLAGS = -g -c -fPIC -I. 
LDFLAGS = -lc

libcard.a: card.o
	rm -f $@
	ar r $@ $^

card.o: card.c card.h
	gcc $&lt; $(CFLAGS)

clean: 
	rm -f *.o *.so *~ \#* *.gch
</pre>
</div>

<p>
ビルドしてみましょう:
</p>

<div class="org-src-container">

<pre class="src src-sh"># ~/progs/card_display/simple/src
make clean
make libcard.a
</pre>
</div>

<pre class="example">
rm -f *.o *.so *~ \#* *.gch
gcc card.c -g -c -fPIC -I. 
rm -f libcard.a
ar r libcard.a card.o
</pre>

<p>
src/card.h と src/card.c に文法上のエラーや宣言上の食い違いがなけれ
あば，card.o ができているはずです。
</p>

<p>
card.o ができて，Makefile に間違いがなければ libcard.a もできている
はずです。
</p>

<p>
libcard.a の中身を確かめて，card_suit_new_from_string 関数が入ってい
るか，確かめてみましょう:
</p>

<div class="org-src-container">

<pre class="src src-sh"># ~/progs/card_display/simple/src
nm libcard.a
</pre>
</div>

<pre class="example">
card.o:
                 U _GLOBAL_OFFSET_TABLE_
0000000000000000 T card_suit_new_from_string
                 U strcmp
</pre>
</div>
</div>

<div id="outline-container-sec-12-6" class="outline-3">
<h3 id="sec-12-6"><span class="section-number-3">12.6</span> テスト test/test_card.so のビルド</h3>
<div class="outline-text-3" id="text-12-6">
<p>
src/libcard.a ができたので，次は test/test_card.so に libcard.a を取り
込むようにmakeの規則を書き換えます:
</p>

<div class="org-src-container">

<pre class="src src-makefile">LDFLAGS = -L../src/ -lcard `pkg-config cutter --libs`
</pre>
</div>

<p>
test/Makefileは下記のようになります:
</p>

<div class="org-src-container">

<pre class="src src-makefile"># test/Makefile (3) 
.PHONY: clean
CFLAGS = -fPIC -I../src `pkg-config cutter --cflags`
LDFLAGS = -L../src/ -lcard `pkg-config cutter --libs`

test_card.so: test_card.o
	gcc -o $@ --shared $^ $(LDFLAGS)

test_card.o: test_card.c
	gcc -c $&lt; $(CFLAGS)

clean:
	rm -f *.o *.so *~ \#* *.gch
</pre>
</div>

<p>
make し，src/libcard.a を取り込んだ test/test_card.so を作成します:
</p>

<div class="org-src-container">

<pre class="src src-sh"># ~/progs/card_display/simple/test/
make clean
make test_card.so
</pre>
</div>

<p>
make の結果中の下記ライン出力中に，
</p>
<pre class="example">
gcc -o test_card.so --shared test_card.o -L../src/ -lcard `pkg-config cutter --libs`
</pre>

<p>
-L../src/ -lcard `pkg-config cutter &#x2013;libs`　が含まれていれば，
test/test_card.so はできあがるはずです。
</p>
</div>
</div>
</div>

<div id="outline-container-sec-13" class="outline-2">
<h2 id="sec-13"><span class="section-number-2">13</span> テスト</h2>
<div class="outline-text-2" id="text-13">
<p>
テストと実装が終わり，テストをビルドするためのMakefileは完成してい
ます。テストするために simple/ で make してみましょう:
</p>

<div class="org-src-container">

<pre class="src src-sh"># ~/progs/card_display/simple
make
</pre>
</div>

<pre class="example">
(cd src; make)
make[1]: ディレクトリ `/home/staff/suzuki/COMM/Lects/prog/site/org-docs/tdd-card-display-simple/babel/simple/suit_new/src' に入ります
make[1]: `libcard.a' は更新済みです
make[1]: ディレクトリ `/home/staff/suzuki/COMM/Lects/prog/site/org-docs/tdd-card-display-simple/babel/simple/suit_new/src' から出ます
(cd test; make)	
make[1]: ディレクトリ `/home/staff/suzuki/COMM/Lects/prog/site/org-docs/tdd-card-display-simple/babel/simple/suit_new/test' に入ります
make[1]: `test_card.so' は更新済みです
make[1]: ディレクトリ `/home/staff/suzuki/COMM/Lects/prog/site/org-docs/tdd-card-display-simple/babel/simple/suit_new/test' から出ます
cutter -v v test/
test_card:
  test_card_suit_new_from_string:			.: (0.000066)

Finished in 0.000464 seconds (total: 0.000066 seconds)

1 test(s), 4 assertion(s), 0 failure(s), 0 error(s), 0 pending(s), 0 omission(s), 0 notification(s)
100% passed
</pre>

<p>
これからは，機能が要求を満たすことを確かめるためにテストし，テスト
が失敗した場合は，test/test_card.c, src/{card.h, card.c} を修正
していくことになります。
</p>
</div>
</div>

<div id="outline-container-sec-14" class="outline-2">
<h2 id="sec-14"><span class="section-number-2">14</span> テストと再設計</h2>
<div class="outline-text-2" id="text-14">
<p>
テストが通らなかった時，下記の場合が考えられます：
</p>
<ul class="org-ul">
<li>要求自体が間違っていた
</li>
<li>要求に対する設計が間違っていた
</li>
<li>要求・設計に対する実装が間違っていた
</li>
</ul>

<p>
それぞれどの箇所を見直すか考えてみましょう:
</p>

<ul class="org-ul">
<li>要求が間違っている場合 (テストの作り直し)
<ul class="org-ul">
<li>test/test_card.c の変更
</li>
<li>src/card.h の変更，それに伴ない
<ul class="org-ul">
<li>test/test_card.c, src/card.c の変更
</li>
</ul>
</li>
</ul>
</li>

<li>設計が間違っている場合 (インタフェースの見直し)
<ul class="org-ul">
<li>src/card.h の変更，それに伴ない
<ul class="org-ul">
<li>test/test_card.c, src/card.c の変更
</li>
</ul>
</li>
</ul>
</li>

<li>実装が間違っている場合 (実装のみの見直し)
<ul class="org-ul">
<li>src/card.c のみの変更
</li>
</ul>
</li>
</ul>

<p>
適切に対処しましょう。
</p>
</div>
</div>

<div id="outline-container-sec-15" class="outline-2">
<h2 id="sec-15"><span class="section-number-2">15</span> トランプ番号を数値に</h2>
</div>
<div id="outline-container-sec-16" class="outline-2">
<h2 id="sec-16"><span class="section-number-2">16</span> トランプ番号を数値に</h2>
<div class="outline-text-2" id="text-16">
<p>
次は，文字列で表された番号を，プログラム内部での数値に変換す
る機能のテストです。
</p>
</div>

<div id="outline-container-sec-16-1" class="outline-3">
<h3 id="sec-16-1"><span class="section-number-3">16.1</span> 機能とテストの追加</h3>
<div class="outline-text-3" id="text-16-1">
<p>
番号のテストは，test/test_card.c に追加作成することにします。
</p>

<p>
機能の名前を card_no_new_from_string とし,
card_no_new_from_string を呼び出してみます：
</p>

<div class="org-src-container">

<pre class="src src-c">// test/test_card.c

  card_no_new_from_string("13")==KING;
</pre>
</div>

<p>
よさそうです。card_no_new_from_stringを関数の形で書けたので，テス
トを書きます:
</p>

<div class="org-src-container">

<pre class="src src-c">// test/test_card.c

  cut_set_message("番号から数値への変換のテスト");
  cut_assert(card_no_new_from_string("1")==ACE);
  cut_assert(card_no_new_from_string("13")==KING);
  cut_assert(card_no_new_from_string("12")==QUEEN);
  cut_assert(card_no_new_from_string("11")==JACK);
  cut_assert(card_no_new_from_string("10")==10);
</pre>
</div>

<p>
card_no_new_from_string 関数の型を決めます。
</p>

<p>
戻り値の型は enum e_No，与える引数は番号を示す文字列なので:
</p>

<div class="org-src-container">

<pre class="src src-c">// test/test_card.c

  enum e_No card_no_new_from_string(char *);
</pre>
</div>

<p>
テストに使う定数は，列挙型で書いてみます:
</p>

<div class="org-src-container">

<pre class="src src-c">// test/test_card.c

  enum e_No {JACK=11, QUEEN, KING, ACE};
</pre>
</div>

<p>
テストを関数にします。
</p>

<div class="org-src-container">

<pre class="src src-c">// test/test_card.c

void
test_card_suit_no_from_string(void)
{
  cut_set_message("番号から数値への変換のテスト");
  cut_assert(card_no_new_from_string("1")==ACE);
  cut_assert(card_no_new_from_string("13")==KING);
  cut_assert(card_no_new_from_string("12")==QUEEN);
  cut_assert(card_no_new_from_string("11")==JACK);
  cut_assert(card_no_new_from_string("10")==10);
}
</pre>
</div>

<p>
ここまでで，test/test_card.c の中身は:
</p>

<div class="org-src-container">

<pre class="src src-c">// test/test_card.c
# include &lt;cutter.h&gt;
# include &lt;card.h&gt;

enum e_No {JACK=11, QUEEN, KING, ACE};
enum e_No card_no_new_from_string(char *);

void
test_card_suit_new_from_string(void)
{
  cut_set_message("スーツから数値への変換のテスト");
  cut_assert_true(card_suit_new_from_string("SPADE")==SPADE);
  cut_assert(card_suit_new_from_string("HEART")==HEART);
  cut_assert(card_suit_new_from_string("DIAMOND")==DIAMOND);
  cut_assert(card_suit_new_from_string("CLUB")==CLUB);
}

void
test_card_no_new_from_string(void)
{
  cut_set_message("番号から数値への変換のテスト");
  cut_assert(card_no_new_from_string("1")==ACE);
  cut_assert(card_no_new_from_string("13")==KING);
  cut_assert(card_no_new_from_string("12")==QUEEN);
  cut_assert(card_no_new_from_string("11")==JACK);
  cut_assert(card_no_new_from_string("10")==10);
}
</pre>
</div>
</div>

<div id="outline-container-sec-16-1-1" class="outline-4">
<h4 id="sec-16-1-1"><span class="section-number-4">16.1.1</span> test/Makefileの更新</h4>
<div class="outline-text-4" id="text-16-1-1">
<p>
test/Makefile の目的は変わっていませんので，更新の必要はありません。
</p>
</div>
</div>

<div id="outline-container-sec-16-1-2" class="outline-4">
<h4 id="sec-16-1-2"><span class="section-number-4">16.1.2</span> test/test_card.o の更新</h4>
<div class="outline-text-4" id="text-16-1-2">
<p>
test/ で makeしてみましょう。
</p>

<p>
まずは，test/test_card.o の作成です:
</p>

<div class="org-src-container">

<pre class="src src-sh"># ~/progs/card_display/simple/test
make test_card.o
</pre>
</div>

<pre class="example">
gcc -c test_card.c -fPIC -I../src `pkg-config cutter --cflags`
</pre>

<p>
test_card.o ができれば，ひとまず，成功です。
</p>

<p>
できない時は，test_card.c に間違いがあるか，Makefile に間違いがあり
ます。エラーメッセージからどちらの間違いなのか特定し，修正しましょ
う。
</p>

<p>
成功したら，test/test_card.o の中身を見て確認しましょう:
</p>

<div class="org-src-container">

<pre class="src src-sh"># ~/progs/card_display/simple/test
nm test_card.o
</pre>
</div>

<pre class="example">
                 U _GLOBAL_OFFSET_TABLE_
0000000000000200 r __PRETTY_FUNCTION__.3239
                 U _setjmp
                 U card_suit_new_from_string
                 U cut_assert_helper
                 U cut_test_context_current_peek
                 U cut_test_context_finish_user_message_jump
\\                 U cut_test_context_get_have_current_result
                 U cut_test_context_get_jump_buffer
                 U cut_test_context_in_user_message_jump
                 U cut_test_context_long_jump
                 U cut_test_context_pop_backtrace
                 U cut_test_context_process_current_result
                 U cut_test_context_push_backtrace
                 U cut_test_context_set_jump_buffer
                 U cut_test_context_set_user_message
                 U cut_test_context_start_user_message_jump
0000000000000000 T test_card_suit_new_from_string
</pre>

<p>
card_no_from_stringが未定義で，
test_card_no_new_from_string が定義されているのがわかります。
</p>
</div>
</div>

<div id="outline-container-sec-16-1-3" class="outline-4">
<h4 id="sec-16-1-3"><span class="section-number-4">16.1.3</span> テスト (test/test_card.so) のビルド</h4>
<div class="outline-text-4" id="text-16-1-3">
<p>
つづいて，test/test_card.so を作りましょう:
</p>

<div class="org-src-container">

<pre class="src src-sh"># ~/progs/card_display/simple/test
make test_card.so
</pre>
</div>

<pre class="example">
gcc -o test_card.so --shared test_card.o -L../src/ -lcard `pkg-config cutter --libs`
</pre>
</div>
</div>
</div>


<div id="outline-container-sec-16-2" class="outline-3">
<h3 id="sec-16-2"><span class="section-number-3">16.2</span> card_no_new_from_string の実装</h3>
<div class="outline-text-3" id="text-16-2">
<p>
さて次は，機能 card_no_new_from_string の実装です。
以下のように実装しましょう:
</p>

<ul class="org-ul">
<li>test/test_card.c を作成するときに決めたインタフェースをとりだし，
src/card.hに追加する。
</li>

<li>test/test_card.c の対応部分は # include &lt;card.h&gt; に含まれることに
なる。
</li>

<li>src/card.hを遵守し，src/card.c に機能(関数)を追加する。
</li>

<li>提供する機能を入れた src/libcard.a を作成する，Makefileを作成す
る
</li>
</ul>

<p>
<b>src/{card.h，libcard.a} で機能を提供します</b>
</p>
</div>

<div id="outline-container-sec-16-2-1" class="outline-4">
<h4 id="sec-16-2-1"><span class="section-number-4">16.2.1</span> src/card.h の更新</h4>
<div class="outline-text-4" id="text-16-2-1">
<p>
test/test_card.c で宣言した card_no_new_from_string に関する
インタフェースの定義を，src/card.h に移し，定義の責任を src/ に移
します。
</p>

<p>
enum e_No の値も TWO~ACEまでにします.
</p>

<div class="org-src-container">

<pre class="src src-c">// src/card.h (追加)

enum e_Suit {CLUB=1,DIAMOND,HEART,SPADE};
enum e_Suit card_suit_new_from_string(char *);

enum e_No { TWO=2, THREE, FOUR, FIVE,
	    SIX, SEVEN, EIGHT, NINE, TEN,
	    JACK, QUEEN, KING, ACE};

enum e_No card_no_new_from_string(char *);
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-16-2-2" class="outline-4">
<h4 id="sec-16-2-2"><span class="section-number-4">16.2.2</span> test/test_card.cの変更</h4>
<div class="outline-text-4" id="text-16-2-2">
<p>
test/test_card.c から card_no_new_from_string に関する宣言を消しま
す。
</p>

<div class="org-src-container">

<pre class="src src-c">// test/test_card.c.1
# include &lt;cutter.h&gt;
# include &lt;card.h&gt;

void
test_card_suit_new_from_string(void)
{
  cut_set_message("文字列からスーツを作成する。");
  cut_assert_true(card_suit_new_from_string("SPADE")==SPADE);
  cut_assert_true(card_suit_new_from_string("HEART")==HEART);
  cut_assert_true(card_suit_new_from_string("DIAMOND")==DIAMOND);
  cut_assert_true(card_suit_new_from_string("CLUB")==CLUB);
}

void
test_card_no_new_from_string(void)
{
  cut_set_message("番号から数値への変換のテスト");
  cut_assert(card_no_new_from_string("1")==ACE);
  cut_assert(card_no_new_from_string("13")==KING);
  cut_assert(card_no_new_from_string("12")==QUEEN);
  cut_assert(card_no_new_from_string("11")==JACK);
  cut_assert(card_no_new_from_string("10")==10);
}
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-16-2-3" class="outline-4">
<h4 id="sec-16-2-3"><span class="section-number-4">16.2.3</span> card_no_new_from_string の実装 (src/card.c の更新)</h4>
<div class="outline-text-4" id="text-16-2-3">
<p>
番号を表す文字列から，内部番号にする関数 card_no_new_from_string
を実装します.
</p>

<ul class="org-ul">
<li>src/card.h 中の，下記インタフェースの宣言
</li>
</ul>

<div class="org-src-container">

<pre class="src src-C">// src/card.h
enum e_No card_no_new_from_string(char *);
</pre>
</div>

<p>
から入口と出口コードを書きます.
</p>

<p>
引数に名前をつけ， 戻り値の型を指定し，戻り値をリターンするコード
を書きます:
</p>

<div class="org-src-container">

<pre class="src src-c">enum e_No
card_no_new_from_string(char *no_str)
{
  int no;

  return (enum e_No) no;
}
</pre>
</div>

<p>
番号を表す文字列から数値を計算するコードは，例えば，つぎのように
なります。
</p>

<ul class="org-ul">
<li>整数値文字列を整数にするためのライブラリ関数 int atoi(char *) を使
います:
</li>
</ul>

<div class="org-src-container">

<pre class="src src-c">int no = atoi(no_str);
</pre>
</div>

<ul class="org-ul">
<li>1~13 の数値を，2~14 の数値に変換し，おかしな値がないかチェックし
ます
</li>
</ul>

<div class="org-src-container">

<pre class="src src-c">if (no==1)  no = ACE;

if ( no &lt; TWO || ACE &lt; no )
  {
    fprintf(stderr, "不適な数値 (%s)!\n", no_str);
  };
</pre>
</div>

<p>
全体を合わせて:
</p>

<div class="org-src-container">

<pre class="src src-c">// src/card.c
# include &lt;stdio.h&gt;
# include &lt;string.h&gt;
# include &lt;card.h&gt;

enum e_Suit
card_suit_new_from_string(char *suit_str)
{
  if (strcmp("CLUB",suit_str)==0)
    return CLUB;
  if (strcmp("DIAMOND",suit_str)==0)
    return DIAMOND;
  if (strcmp("HEART",suit_str)==0)
    return HEART;
  if (strcmp("SPADE",suit_str)==0)
    return SPADE;
  return 0;
}

enum e_No
card_no_new_from_string(char *no_str)
{
  int no = atoi(no_str);

  if (no==1)  no = ACE;

  if ( no &lt; TWO || ACE &lt; no )
    {
      fprintf(stderr, "不適な数値 (%s)!\n", no_str);
    };
  return (enum e_No) no;
}
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-16-2-4" class="outline-4">
<h4 id="sec-16-2-4"><span class="section-number-4">16.2.4</span> src/Makefile</h4>
<div class="outline-text-4" id="text-16-2-4">
<p>
src/card.h と src/card.c から src/card.o を作成し，src/card.o から
src/libcard.a を作成するルールに変更はありません。
</p>

<p>
なので，Makefileにルール変更はありません。
</p>


<div class="org-src-container">

<pre class="src src-sh"># ~/progs/card_display/simple/src
make card.o
</pre>
</div>

<pre class="example">
gcc card.c -g -c -fPIC -I. 
</pre>

<p>
実装コードに間違いがなければ， src/card.o ができて成功します。
</p>

<p>
src/card.o ができない場合，src/card.c に間違いあるか，Makefile に
間違いがあります。エラー箇所を特定し，エラーを取り除いてください。
</p>

<p>
src/card.o ができれば， src/libcard.a を作成します:
</p>

<div class="org-src-container">

<pre class="src src-sh"># ~/progs/CardDisplay/simple/src
make libcard.a
</pre>
</div>

<p>
Makefileが正しければ，これは成功します。libcard.a の中身を確かめてみましょう:
</p>

<div class="org-src-container">

<pre class="src src-sh"># ~/progs/CardDisplay/simple/src
nm libcard.a
</pre>
</div>

<pre class="example">
card.o:
                 U _GLOBAL_OFFSET_TABLE_
                 U atoi
000000000000008b T card_no_new_from_string
0000000000000000 T card_suit_new_from_string
                 U fprintf
                 U stderr
                 U strcmp
</pre>


<p>
T card_no_new_from_string， T card_suit_new_from_string で関数が定
義されているのがわかります。
</p>
</div>
</div>

<div id="outline-container-sec-16-2-5" class="outline-4">
<h4 id="sec-16-2-5"><span class="section-number-4">16.2.5</span> テスト test/test_card.so の再ビルド</h4>
<div class="outline-text-4" id="text-16-2-5">
<p>
src/libcard.a が更新できたので，次は libcard.a をリンクし直して，
test/test_card.so を更新します。
</p>

<div class="org-src-container">

<pre class="src src-sh"># ~/progs/card_display/simple/test/
make clean
make test_card.so
</pre>
</div>

<p>
rm -f <b>.o *.so *~ \#</b> *.gch
gcc -c test_card.c -fPIC -I../src `pkg-config cutter &#x2013;cflags`
gcc -o test_card.so &#x2013;shared test_card.o -L../src/ -lcard `pkg-config cutter &#x2013;libs`
</p>
</div>
</div>
</div>


<div id="outline-container-sec-16-3" class="outline-3">
<h3 id="sec-16-3"><span class="section-number-3">16.3</span> テスト</h3>
<div class="outline-text-3" id="text-16-3">
<p>
機能の実装が終り，テストもビルドできました。
</p>

<p>
これからは，機能が要求を満たすことを確かめるためにテストし，テスト
が失敗した場合は，test/test_card.c, src/{card.h, card.c} を修正
していくことになります。
</p>

<div class="org-src-container">

<pre class="src src-sh"># ~/progs/card_display/simple
make
</pre>
</div>

<pre class="example">
(cd src; make)
make[1]: ディレクトリ `/home/staff/suzuki/COMM/Lects/prog/site/org-docs/tdd-card-display-simple/babel/simple/no_new/src' に入ります
make[1]: `libcard.a' は更新済みです
make[1]: ディレクトリ `/home/staff/suzuki/COMM/Lects/prog/site/org-docs/tdd-card-display-simple/babel/simple/no_new/src' から出ます
(cd test; make)	
make[1]: ディレクトリ `/home/staff/suzuki/COMM/Lects/prog/site/org-docs/tdd-card-display-simple/babel/simple/no_new/test' に入ります
make[1]: `test_card.so' は更新済みです
make[1]: ディレクトリ `/home/staff/suzuki/COMM/Lects/prog/site/org-docs/tdd-card-display-simple/babel/simple/no_new/test' から出ます
cutter -v v test/
test_card:
  test_card_no_new_from_string:				.: (0.000075)
  test_card_suit_new_from_string:			.: (0.000038)

Finished in 0.000531 seconds (total: 0.000113 seconds)

2 test(s), 9 assertion(s), 0 failure(s), 0 error(s), 0 pending(s), 0 omission(s), 0 notification(s)
100% passed
</pre>

<p>
となればテスト成功です。
</p>

<p>
失敗した場合，失敗した関数を特定し，原因がテスト側
(test/test_card.c) なのか， 実装側 (src/card.c) なのか，
インタフェース (src/card.h) なのか，特定してし，
失敗の原因を取り 除いてください。
</p>
</div>


<div id="outline-container-sec-16-3-1" class="outline-4">
<h4 id="sec-16-3-1"><span class="section-number-4">16.3.1</span> テストと再設計</h4>
<div class="outline-text-4" id="text-16-3-1">
<p>
この節でおこなったこと:
</p>

<ul class="org-ul">
<li>新たな機能の要求 card_no_new_from_string があり，
</li>
<li>test/test_card.c に新らしいテスト関数を作成し，
</li>
<li>src/card.h に新たな機能のインターフェイス宣言を付け加え，
</li>
<li>src/card.c にその機能の実装を付け加えた
</li>
</ul>
</div>
</div>
</div>
</div>

<div id="outline-container-sec-17" class="outline-2">
<h2 id="sec-17"><span class="section-number-2">17</span> トランプ・カードを作成</h2>
<div class="outline-text-2" id="text-17">
</div>
</div>
<div id="outline-container-sec-18" class="outline-2">
<h2 id="sec-18"><span class="section-number-2">18</span> 機能の追加とテストの作成</h2>
<div class="outline-text-2" id="text-18">
<p>
カードを作る機能のテストは，test/test_card.c に追加作成します。
</p>

<p>
設計については，<a href="https://wiki.cis.iwate-u.ac.jp/~suzuki/lects/prog/org-docs/card-display/#outline-container-sec-2">card_display_simple問題への解法</a> も参考にしてくださ
い。
</p>
</div>

<div id="outline-container-sec-18-1" class="outline-3">
<h3 id="sec-18-1"><span class="section-number-3">18.1</span> card_new のテストを書く</h3>
<div class="outline-text-3" id="text-18-1">
<p>
機能の名前を card_new とし, card_newが満たすテストを書きます:
</p>

<div class="org-src-container">

<pre class="src src-c">Card sa = card_new(SPADE, ACE);
</pre>
</div>

<p>
次のような事が分かります:
</p>
<ul class="org-ul">
<li>Card型が必要である，
</li>
<li>スーツと番号を与え，
</li>
<li>Card型の値が返る。
</li>
</ul>

<p>
これだけではテストにならないので，スーツと番号を取り出す機能を合わ
せて，追加します。
</p>

<div class="org-src-container">

<pre class="src src-c">enum e_Suit card_suit(Card);
enum e_No card_no(Card);
</pre>
</div>

<p>
これにより，テストが書けます:
</p>

<div class="org-src-container">

<pre class="src src-c">Card sa = card_new(SPADE, ACE);
cut_assert( card_suit(sa)==SPADE );
cut_assert( card_no(sa)==ACE );
</pre>
</div>

<p>
スペードのACEを作り，つくられたカードのスーツと番号が正しいか，確
かめています。
</p>

<p>
Card型が定義できれば，これでよさそうです。
</p>

<div class="org-src-container">

<pre class="src src-c">void
test_card_new(void)
{
  cut_set_message("スーツと番号からカードを作成");
  {
    Card sa = card_new(SPADE,ACE);
    cut_assert( card_suit(sa)==SPADE );
    cut_assert( card_no(sa)==ACE );
  }
}
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-18-2" class="outline-3">
<h3 id="sec-18-2"><span class="section-number-3">18.2</span> card_new, card_suit, card_no のインタフェースを決める</h3>
<div class="outline-text-3" id="text-18-2">
<p>
card_new を関数の形で書けたので，関数の型を決めます。
</p>

<p>
戻り値の型は Card，与える引数はスーツと番号の内部表現なので:
</p>

<div class="org-src-container">

<pre class="src src-c">enum e_Suit card_suit(Card);
enum e_No card_no(Card);
Card card_new(enum e_Suit, enum e_No);
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-18-3" class="outline-3">
<h3 id="sec-18-3"><span class="section-number-3">18.3</span> Card型を定義する</h3>
<div class="outline-text-3" id="text-18-3">
<p>
Card 型を定義しましょう。Card型は次の情報を持ちます:
</p>

<ul class="org-ul">
<li>スーツを表す enum e_Suit 型の数値
</li>
<li>番号を表す enum e_No 型の数値
</li>
</ul>

<p>
これを構造体で表します:
</p>

<div class="org-src-container">

<pre class="src src-c">struct _Card {
  enum e_Suit suit;
  enum e_No no;
};
</pre>
</div>

<p>
ですね。
</p>

<p>
これを型にします。
</p>

<div class="org-src-container">

<pre class="src src-c">typdef struct _Card Card;
</pre>
</div>

<p>
struct _Card 型を Card 型として定義し，Card が
構造体であることを意識せずに使うことができます。
</p>
</div>
</div>

<div id="outline-container-sec-18-4" class="outline-3">
<h3 id="sec-18-4"><span class="section-number-3">18.4</span> テスト全体プログラムの確認</h3>
<div class="outline-text-3" id="text-18-4">
<p>
test/test_card.cは次のようになります:
</p>

<div class="org-src-container">

<pre class="src src-c">// test/test_card.c
# include &lt;cutter.h&gt;
# include &lt;card.h&gt;
// test/test_card.c
# include &lt;cutter.h&gt;
# include &lt;card.h&gt;

void
test_card_suit_new_from_string(void)
{
  cut_set_message("文字列からスーツを作成する。");
  cut_assert_true(card_suit_new_from_string("SPADE")==SPADE);
  cut_assert_true(card_suit_new_from_string("HEART")==HEART);
  cut_assert_true(card_suit_new_from_string("DIAMOND")==DIAMOND);
  cut_assert_true(card_suit_new_from_string("CLUB")==CLUB);
}
void
test_card_suit_new_from_string(void)
{
  cut_set_message("文字列からスーツを作成する。");
  cut_assert_true(card_suit_new_from_string("SPADE")==SPADE);
  cut_assert_true(card_suit_new_from_string("HEART")==HEART);
  cut_assert_true(card_suit_new_from_string("DIAMOND")==DIAMOND);
  cut_assert_true(card_suit_new_from_string("CLUB")==CLUB);
}

void
test_card_no_new_from_string(void)
{
  cut_set_message("番号から数値への変換のテスト");
  cut_assert(card_no_new_from_string("1")==ACE);
  cut_assert(card_no_new_from_string("13")==KING);
  cut_assert(card_no_new_from_string("12")==QUEEN);
  cut_assert(card_no_new_from_string("11")==JACK);
  cut_assert(card_no_new_from_string("10")==10);
}
void
test_card_no_new_from_string(void)
{
  cut_set_message("番号から数値への変換のテスト");
  cut_assert(card_no_new_from_string("1")==ACE);
  cut_assert(card_no_new_from_string("13")==KING);
  cut_assert(card_no_new_from_string("12")==QUEEN);
  cut_assert(card_no_new_from_string("11")==JACK);
  cut_assert(card_no_new_from_string("10")==10);
}

struct _Card {
  enum e_Suit suit;
  enum e_No no;
};
struct _Card {
  enum e_Suit suit;
  enum e_No no;
};

typedef struct _Card Card;

enum e_Suit card_suit(Card);
enum e_No card_no(Card);
Card card_new(enum e_Suit, enum e_No);
typedef struct _Card Card;

enum e_Suit card_suit(Card);
enum e_No card_no(Card);
Card card_new(enum e_Suit, enum e_No);

void
test_card_new(void)
{
   cut_set_message("スーツと番号からカードを作成");
  {
    Card sa = card_new(SPADE,ACE);
    cut_assert(card_suit(sa)==SPADE);
    cut_assert(card_no(sa)==ACE);
  }
}
void
test_card_new(void)
{
   cut_set_message("スーツと番号からカードを作成");
  {
    Card sa = card_new(SPADE,ACE);
    cut_assert(card_suit(sa)==SPADE);
    cut_assert(card_no(sa)==ACE);
  }
}
</pre>
</div>

<div class="org-src-container">

<pre class="src src-c">// src/card.h
# include &lt;string.h&gt;
// src/card.h
# include &lt;string.h&gt;

enum e_Suit {CLUB=1,DIAMOND,HEART,SPADE};
enum e_Suit card_suit_new_from_string(char *);
enum e_Suit {CLUB=1,DIAMOND,HEART,SPADE};
enum e_Suit card_suit_new_from_string(char *);

enum e_No { TWO=2, THREE, FOUR, FIVE,
	    SIX, SEVEN, EIGHT, NINE, TEN,
	    JACK, QUEEN, KING, ACE};
enum e_No card_no_new_from_string(char *);
enum e_No { TWO=2, THREE, FOUR, FIVE,
	    SIX, SEVEN, EIGHT, NINE, TEN,
	    JACK, QUEEN, KING, ACE};
enum e_No card_no_new_from_string(char *);

// src/card.h
# include &lt;string.h&gt;
// src/card.h
# include &lt;string.h&gt;

enum e_Suit {CLUB=1,DIAMOND,HEART,SPADE};
enum e_Suit card_suit_new_from_string(char *);
enum e_Suit {CLUB=1,DIAMOND,HEART,SPADE};
enum e_Suit card_suit_new_from_string(char *);

enum e_No { TWO=2, THREE, FOUR, FIVE,
	    SIX, SEVEN, EIGHT, NINE, TEN,
	    JACK, QUEEN, KING, ACE};
enum e_No card_no_new_from_string(char *);
enum e_No { TWO=2, THREE, FOUR, FIVE,
	    SIX, SEVEN, EIGHT, NINE, TEN,
	    JACK, QUEEN, KING, ACE};
enum e_No card_no_new_from_string(char *);
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-18-5" class="outline-3">
<h3 id="sec-18-5"><span class="section-number-3">18.5</span> test/Makefile の確認</h3>
<div class="outline-text-3" id="text-18-5">
<p>
test/Makefile の目的は変わっていませんので，Makefile の更新の必要はありません。
</p>

<div class="org-src-container">

<pre class="src src-c"># test/Makefile
.PHONY: clean
CFLAGS = -fPIC -I../src `pkg-config cutter --cflags`
LDFLAGS = -L../src/ -lcard `pkg-config cutter --libs`

test_card.so: test_card.o
	gcc -o $@ --shared $^ $(LDFLAGS)

test_card.o: test_card.c
	gcc -c $&lt; $(CFLAGS)

clean:
	rm -f *.o *.so *~ \#* *.gch
# test/Makefile
.PHONY: clean
CFLAGS = -fPIC -I../src `pkg-config cutter --cflags`
LDFLAGS = -L../src/ -lcard `pkg-config cutter --libs`

test_card.so: test_card.o
	gcc -o $@ --shared $^ $(LDFLAGS)

test_card.o: test_card.c
	gcc -c $&lt; $(CFLAGS)

clean:
	rm -f *.o *.so *~ \#* *.gch
</pre>
</div>

<p>
test/test_card.c には card_new に関するテスト関数が加わっています。
card_new はまだ未実装ですが，test/test_card.o は作成できます。
</p>
</div>
</div>

<div id="outline-container-sec-18-6" class="outline-3">
<h3 id="sec-18-6"><span class="section-number-3">18.6</span> test/test_card.o の作成</h3>
<div class="outline-text-3" id="text-18-6">
<div class="org-src-container">

<pre class="src src-sh"># ~/progs/card_display/simple/test
make test_card.o
</pre>
</div>

<pre class="example">
gcc -c test_card.c -fPIC -I../src `pkg-config cutter --cflags`
</pre>

<p>
test_card.o ができれば，ひとまず，成功です。
</p>

<p>
できない時は，test_card.c に間違いがあるか，Makefile に間違いがあ
ります。エラーメッセージからどちらの間違いなのか特定し，修正しましょ
う。
</p>

<p>
成功したら，test/test_card.o の中身を見てみましょう:
</p>

<div class="org-src-container">

<pre class="src src-sh"># ~/progs/card_display/simple/test
nm test_card.o
</pre>
</div>

<pre class="example">
		 U _GLOBAL_OFFSET_TABLE_
00000000000004c0 r __PRETTY_FUNCTION__.3255
00000000000004e0 r __PRETTY_FUNCTION__.3271
00000000000004fd r __PRETTY_FUNCTION__.3302
		 U _setjmp
		 U card_new
		 U card_no
		 U card_no_new_from_string
		 U card_suit
		 U card_suit_new_from_string
		 U cut_assert_helper
		 U cut_assert_true_helper
		 U cut_test_context_current_peek
		 U cut_test_context_finish_user_message_jump
		 U cut_test_context_get_have_current_result
		 U cut_test_context_get_jump_buffer
		 U cut_test_context_in_user_message_jump
		 U cut_test_context_long_jump
		 U cut_test_context_pop_backtrace
		 U cut_test_context_process_current_result
		 U cut_test_context_push_backtrace
		 U cut_test_context_set_jump_buffer
		 U cut_test_context_set_user_message
		 U cut_test_context_start_user_message_jump
0000000000000a1b T test_card_new
0000000000000482 T test_card_no_new_from_string
0000000000000000 T test_card_suit_new_from_string
</pre>


<p>
card_newが未定義で，
test_card_new が定義されているのがわかります。
</p>
</div>
</div>
</div>

<div id="outline-container-sec-19" class="outline-2">
<h2 id="sec-19"><span class="section-number-2">19</span> card_new の実装</h2>
<div class="outline-text-2" id="text-19">
<p>
さて次は，機能 card_new の実装です。
手順は，card_no_new_from_string を実装したときと同様です:
</p>

<ul class="org-ul">
<li>test/test_card.c を作成するときに決めたインタフェースをとりだし，
src/card.h に移す。
</li>
<li>src/card.hを遵守し，src/card.c に機能を追加実装する。
</li>
<li>提供する機能を入れた src/libcard.a を作成する
</li>
</ul>

<p>
src/{card.h，libcard.a} で機能を提供する
</p>
</div>

<div id="outline-container-sec-19-1" class="outline-3">
<h3 id="sec-19-1"><span class="section-number-3">19.1</span> card/card.h の更新</h3>
<div class="outline-text-3" id="text-19-1">
<p>
test/test_card.c から card_new等に関するインタフェース宣言を，
src/card.h に移します。
</p>

<p>
ここまでで，src/card.h は次のようになります:
</p>

<div class="org-src-container">

<pre class="src src-c">// src/card.h
# include &lt;string.h&gt;
// src/card.h
# include &lt;string.h&gt;

enum e_Suit {CLUB=1,DIAMOND,HEART,SPADE};
enum e_Suit card_suit_new_from_string(char *);
enum e_Suit {CLUB=1,DIAMOND,HEART,SPADE};
enum e_Suit card_suit_new_from_string(char *);

enum e_No { TWO=2, THREE, FOUR, FIVE,
	    SIX, SEVEN, EIGHT, NINE, TEN,
	    JACK, QUEEN, KING, ACE};
enum e_No card_no_new_from_string(char *);
enum e_No { TWO=2, THREE, FOUR, FIVE,
	    SIX, SEVEN, EIGHT, NINE, TEN,
	    JACK, QUEEN, KING, ACE};
enum e_No card_no_new_from_string(char *);

struct _Card {
  enum e_Suit suit;
  enum e_No no;
};
struct _Card {
  enum e_Suit suit;
  enum e_No no;
};

typedef struct _Card Card;

enum e_Suit card_suit(Card);
enum e_No card_no(Card);
Card card_new(enum e_Suit, enum e_No);
typedef struct _Card Card;

enum e_Suit card_suit(Card);
enum e_No card_no(Card);
Card card_new(enum e_Suit, enum e_No);
// src/card.h
# include &lt;string.h&gt;
// src/card.h
# include &lt;string.h&gt;

enum e_Suit {CLUB=1,DIAMOND,HEART,SPADE};
enum e_Suit card_suit_new_from_string(char *);
enum e_Suit {CLUB=1,DIAMOND,HEART,SPADE};
enum e_Suit card_suit_new_from_string(char *);

enum e_No { TWO=2, THREE, FOUR, FIVE,
	    SIX, SEVEN, EIGHT, NINE, TEN,
	    JACK, QUEEN, KING, ACE};
enum e_No card_no_new_from_string(char *);
enum e_No { TWO=2, THREE, FOUR, FIVE,
	    SIX, SEVEN, EIGHT, NINE, TEN,
	    JACK, QUEEN, KING, ACE};
enum e_No card_no_new_from_string(char *);

struct _Card {
  enum e_Suit suit;
  enum e_No no;
};
struct _Card {
  enum e_Suit suit;
  enum e_No no;
};

typedef struct _Card Card;

enum e_Suit card_suit(Card);
enum e_No card_no(Card);
Card card_new(enum e_Suit, enum e_No);
typedef struct _Card Card;

enum e_Suit card_suit(Card);
enum e_No card_no(Card);
Card card_new(enum e_Suit, enum e_No);
</pre>
</div>
<p>
test/test_card.c は次のようになります：
</p>

<div class="org-src-container">

<pre class="src src-c">// test/test_card.c
# include &lt;cutter.h&gt;
# include &lt;card.h&gt;
// test/test_card.c
# include &lt;cutter.h&gt;
# include &lt;card.h&gt;

void
test_card_suit_new_from_string(void)
{
  cut_set_message("文字列からスーツを作成する。");
  cut_assert_true(card_suit_new_from_string("SPADE")==SPADE);
  cut_assert_true(card_suit_new_from_string("HEART")==HEART);
  cut_assert_true(card_suit_new_from_string("DIAMOND")==DIAMOND);
  cut_assert_true(card_suit_new_from_string("CLUB")==CLUB);
}
void
test_card_suit_new_from_string(void)
{
  cut_set_message("文字列からスーツを作成する。");
  cut_assert_true(card_suit_new_from_string("SPADE")==SPADE);
  cut_assert_true(card_suit_new_from_string("HEART")==HEART);
  cut_assert_true(card_suit_new_from_string("DIAMOND")==DIAMOND);
  cut_assert_true(card_suit_new_from_string("CLUB")==CLUB);
}

void
test_card_no_new_from_string(void)
{
  cut_set_message("番号から数値への変換のテスト");
  cut_assert(card_no_new_from_string("1")==ACE);
  cut_assert(card_no_new_from_string("13")==KING);
  cut_assert(card_no_new_from_string("12")==QUEEN);
  cut_assert(card_no_new_from_string("11")==JACK);
  cut_assert(card_no_new_from_string("10")==10);
}
void
test_card_no_new_from_string(void)
{
  cut_set_message("番号から数値への変換のテスト");
  cut_assert(card_no_new_from_string("1")==ACE);
  cut_assert(card_no_new_from_string("13")==KING);
  cut_assert(card_no_new_from_string("12")==QUEEN);
  cut_assert(card_no_new_from_string("11")==JACK);
  cut_assert(card_no_new_from_string("10")==10);
}

void
test_card_new(void)
{
   cut_set_message("スーツと番号からカードを作成");
  {
    Card sa = card_new(SPADE,ACE);
    cut_assert(card_suit(sa)==SPADE);
    cut_assert(card_no(sa)==ACE);
  }
}
void
test_card_new(void)
{
   cut_set_message("スーツと番号からカードを作成");
  {
    Card sa = card_new(SPADE,ACE);
    cut_assert(card_suit(sa)==SPADE);
    cut_assert(card_no(sa)==ACE);
  }
}
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-19-2" class="outline-3">
<h3 id="sec-19-2"><span class="section-number-3">19.2</span> card_new の実装 (src/card.cの更新)</h3>
<div class="outline-text-3" id="text-19-2">
<p>
card_new関数への要求は
</p>
<ul class="org-ul">
<li>スーツの内部表現と数字の内部表現から，
</li>
<li>カードを表すデータを作る
</li>
</ul>

<p>
ことでしたから，実装は次のようになるでしょう:
</p>

<div class="org-src-container">

<pre class="src src-c">Card
card_new(enum e_Suit suit, enum e_No no)
{
  Card new;

  new.suit = suit;
  new.no = no;
  return new;
}
Card
card_new(enum e_Suit suit, enum e_No no)
{
  Card new;

  new.suit = suit;
  new.no = no;
  return new;
}
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-19-3" class="outline-3">
<h3 id="sec-19-3"><span class="section-number-3">19.3</span> card_suit の実装 (src/card.cの更新)</h3>
<div class="outline-text-3" id="text-19-3">
<p>
要求は：
</p>
<ul class="org-ul">
<li>カードデータからそのスーツが分かること
</li>
</ul>

<p>
でしたから，
</p>

<div class="org-src-container">

<pre class="src src-c">enum e_Suit
card_suit(Card c)
{
  return c.suit;
}
enum e_Suit
card_suit(Card c)
{
  return c.suit;
}
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-19-4" class="outline-3">
<h3 id="sec-19-4"><span class="section-number-3">19.4</span> card_no の実装 (src/card.cの更新)</h3>
<div class="outline-text-3" id="text-19-4">
<p>
要求は：
</p>
<ul class="org-ul">
<li>カードデータからその数字が分かること
</li>
</ul>

<p>
でしたから，
</p>
<div class="org-src-container">

<pre class="src src-c">enum e_No
card_no(Card c)
{
  return c.no;
}
enum e_No
card_no(Card c)
{
  return c.no;
}
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-19-5" class="outline-3">
<h3 id="sec-19-5"><span class="section-number-3">19.5</span> src/card.c 全体</h3>
<div class="outline-text-3" id="text-19-5">
<p>
ここまでの，src/card.c を示しておきます:
</p>

<div class="org-src-container">

<pre class="src src-c">// src/card.c
# include &lt;stdio.h&gt;
# include &lt;string.h&gt;
# include &lt;stdlib.h&gt;
# include &lt;card.h&gt;
// src/card.c
# include &lt;stdio.h&gt;
# include &lt;string.h&gt;
# include &lt;stdlib.h&gt;
# include &lt;card.h&gt;

enum e_Suit
card_suit_new_from_string(char *suit_str)
{
  if (strcmp("CLUB",suit_str)==0)
    return CLUB;
  if (strcmp("DIAMOND",suit_str)==0)
    return DIAMOND;
  if (strcmp("HEART",suit_str)==0)
    return HEART;
  if (strcmp("SPADE",suit_str)==0)
    return SPADE;
  return 0;
}
enum e_Suit
card_suit_new_from_string(char *suit_str)
{
  if (strcmp("CLUB",suit_str)==0)
    return CLUB;
  if (strcmp("DIAMOND",suit_str)==0)
    return DIAMOND;
  if (strcmp("HEART",suit_str)==0)
    return HEART;
  if (strcmp("SPADE",suit_str)==0)
    return SPADE;
  return 0;
}

enum e_No
card_no_new_from_string(char *no_str)
{
  int no = atoi(no_str);

  if (no==1)  no = ACE;

  if ( no &lt; TWO &amp;&amp; ACE &lt; no )
    {
      fprintf(stderr, "不適な数値 (%s)!\n", no_str);
    };
  return (enum e_No)no;
}
enum e_No
card_no_new_from_string(char *no_str)
{
  int no = atoi(no_str);

  if (no==1)  no = ACE;

  if ( no &lt; TWO &amp;&amp; ACE &lt; no )
    {
      fprintf(stderr, "不適な数値 (%s)!\n", no_str);
    };
  return (enum e_No)no;
}

Card
card_new(enum e_Suit suit, enum e_No no)
{
  Card new;

  new.suit = suit;
  new.no = no;
  return new;
}
Card
card_new(enum e_Suit suit, enum e_No no)
{
  Card new;

  new.suit = suit;
  new.no = no;
  return new;
}

enum e_Suit
card_suit(Card c)
{
  return c.suit;
}
enum e_Suit
card_suit(Card c)
{
  return c.suit;
}

enum e_No
card_no(Card c)
{
  return c.no;
}
enum e_No
card_no(Card c)
{
  return c.no;
}
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-19-6" class="outline-3">
<h3 id="sec-19-6"><span class="section-number-3">19.6</span> src/Makefile</h3>
<div class="outline-text-3" id="text-19-6">
<p>
src/Makefileに変更はありません。
</p>
<div class="org-src-container">

<pre class="src src-c"># src/Makefile 
.PHONY: clean
CFLAGS = -g -c -fPIC -I. 
LDFLAGS = -lc

libcard.a: card.o
	rm -f $@
	ar r $@ $^

card.o: card.c card.h
	gcc $&lt; $(CFLAGS)

clean: 
	rm -f *.o *.so *~ \#* *.gch

# src/Makefile 
.PHONY: clean
CFLAGS = -g -c -fPIC -I. 
LDFLAGS = -lc

libcard.a: card.o
	rm -f $@
	ar r $@ $^

card.o: card.c card.h
	gcc $&lt; $(CFLAGS)

clean: 
	rm -f *.o *.so *~ \#* *.gch
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-19-7" class="outline-3">
<h3 id="sec-19-7"><span class="section-number-3">19.7</span> src/card.o の作成</h3>
<div class="outline-text-3" id="text-19-7">
<p>
src/card.o を make し, ソースコードにエラーがないか確かめます:
</p>

<div class="org-src-container">

<pre class="src src-sh"># ~/progs/card_display/simple/src
make card.o
</pre>
</div>

<pre class="example">
gcc card.c -g -c -fPIC -I. 
</pre>

<p>
src/card.o ができれば文法や宣言の食い違いはなくなったことになりま
す。
</p>
</div>
</div>

<div id="outline-container-sec-19-8" class="outline-3">
<h3 id="sec-19-8"><span class="section-number-3">19.8</span> src/libcard.a の作成</h3>
<div class="outline-text-3" id="text-19-8">
<p>
src/card.o ができれば，次は， src/libcard.a を make します。
</p>

<div class="org-src-container">

<pre class="src src-sh"># ~/progs/card_display/simple/src
make libcard.a
</pre>
</div>

<pre class="example">
rm -f libcard.a
ar r libcard.a card.o
</pre>

<p>
Makefile が正しければ，これは成功するはずです。
</p>

<p>
libcard.a の中身を確かめてみましょう:
</p>

<div class="org-src-container">

<pre class="src src-sh"># ~/progs/card_display/simple/src
nm libcard.a
</pre>
</div>

<pre class="example">
card.o:
                 U _GLOBAL_OFFSET_TABLE_
                 U atoi
00000000000000e6 T card_new
000000000000010f T card_no
000000000000008b T card_no_new_from_string
0000000000000102 T card_suit
0000000000000000 T card_suit_new_from_string
                 U fprintf
                 U stderr
                 U strcmp
</pre>

<p>
src/libcard.a が更新できたので，次はtest_card.so を更新します。    
</p>
</div>
</div>
</div>

<div id="outline-container-sec-20" class="outline-2">
<h2 id="sec-20"><span class="section-number-2">20</span> テスト</h2>
<div class="outline-text-2" id="text-20">
</div><div id="outline-container-sec-20-1" class="outline-3">
<h3 id="sec-20-1"><span class="section-number-3">20.1</span> test/test_card.so のビルド</h3>
<div class="outline-text-3" id="text-20-1">
<p>
src/libcard.a が更新されているので，test/test_card.so を作り直しま
す。
</p>

<div class="org-src-container">

<pre class="src src-sh"># ~/progs/card_display/simple/test/
make clean
make test_card.so
</pre>
</div>

<pre class="example">
rm -f *.o *.so *~ \#* *.gch
gcc -c test_card.c -fPIC -I../src `pkg-config cutter --cflags`
gcc -o test_card.so --shared test_card.o -L../src/ -lcard `pkg-config cutter --libs`
</pre>

<p>
test/test_card.so ができればテストの実行に移ります。
</p>

<p>
できない時は，多分，Makefile に間違いがあります。Makefile を修正してください。
</p>
</div>
</div>

<div id="outline-container-sec-20-2" class="outline-3">
<h3 id="sec-20-2"><span class="section-number-3">20.2</span> テストの実行</h3>
<div class="outline-text-3" id="text-20-2">
<p>
テストの作成と機能の実装が終ったので，機能が要求を満たすことを確か
めるためにテストする:
</p>

<div class="org-src-container">

<pre class="src src-sh"># ~/progs/card_display/simple
cutter -v v test
</pre>
</div>

<pre class="example">
test_card:
  test_card_no_new_from_string:                         .: (0.000136)
  test_card_suit_new_from_string:                       .: (0.000079)
  test_card_new:                                        .: (0.000044)

Finished in 0.001173 seconds (total: 0.000259 seconds)

3 test(s), 11 assertion(s), 0 failure(s), 0 error(s), 0 pending(s), 0 omission(s), 0 notification(s)
100% passed
</pre>
</div>
</div>

<div id="outline-container-sec-20-3" class="outline-3">
<h3 id="sec-20-3"><span class="section-number-3">20.3</span> テストと再設計</h3>
<div class="outline-text-3" id="text-20-3">
<p>
テストが成功すれば，テストによる開発の1サイクルが完結したことにな
ります。
</p>

<p>
テストが失敗した場合は，test/test_card.c, src/{card.h, card.c} を
修正していくことになります。
</p>

<p>
ソースコードを修正した後は，Makefileに間違いがなけれ
ば，~/progs/card_display/simpleで make すれば，全自動でテストまで
実行してくれます。テストが成功するまで繰り返してください。
</p>
</div>
</div>
</div>

<div id="outline-container-sec-21" class="outline-2">
<h2 id="sec-21"><span class="section-number-2">21</span> トランプ・カードを文字列に</h2>
<div class="outline-text-2" id="text-21">
<p>
自分でやってみましょう。
</p>
</div>

<div id="outline-container-sec-21-1" class="outline-3">
<h3 id="sec-21-1"><span class="section-number-3">21.1</span> 設計</h3>
<div class="outline-text-3" id="text-21-1">
<p>
要求は，カードの内部表現を文字列にすること
</p>

<ul class="org-ul">
<li>2文字からなるの文字列とする
</li>
<li>スーツは 'S', 'H', 'D', 'C',  1文字
</li>
<li>数は 'A','K','Q','J','0','9','8','7','6','5','4','3','2'，1文字
</li>
</ul>

<p>
処理
</p>
<ul class="org-ul">
<li>スーツや番号を添字に配列を参照するのも一つの方法
</li>
</ul>
</div>

<div id="outline-container-sec-21-1-1" class="outline-4">
<h4 id="sec-21-1-1"><span class="section-number-4">21.1.1</span> 機能の名前と構造</h4>
<div class="outline-text-4" id="text-21-1-1">
<p>
card_to_string カードを文字列にする機能
</p>
<ul class="org-ul">
<li>card_suit_to_string  スーツを1文字にする機能
</li>
<li>card_no_to_string 番号を1文字にする機能
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-21-1-2" class="outline-4">
<h4 id="sec-21-1-2"><span class="section-number-4">21.1.2</span> 関数の引数と戻り値の型 (APIの設計)</h4>
<div class="outline-text-4" id="text-21-1-2">
<ul class="org-ul">
<li>char *card_to_string(Card);
<ul class="org-ul">
<li>char *card_suit_to_string(int suit);
</li>
<li>char *card_no_to_string(int no);
</li>
</ul>
</li>
</ul>
</div>
</div>
</div>

<div id="outline-container-sec-21-2" class="outline-3">
<h3 id="sec-21-2"><span class="section-number-3">21.2</span> テストによる開発</h3>
<div class="outline-text-3" id="text-21-2">
<p>
card_no_new_from_string や card_new の開発をまねして，
テストによる開発を行って下さい。
</p>

<p>
<code>開発の過程をドキュメントとしてまとめ</code> <code>レポート提出してください</code> 。
</p>
</div>
</div>
</div>

<div id="outline-container-sec-22" class="outline-2">
<h2 id="sec-22"><span class="section-number-2">22</span> トランプ・カードを文字列に</h2>
<div class="outline-text-2" id="text-22">
</div>
</div>

<div id="outline-container-sec-23" class="outline-2">
<h2 id="sec-23"><span class="section-number-2">23</span> 機能の追加とテストの作成</h2>
<div class="outline-text-2" id="text-23">
<p>
テストは，test/test_card.c に追加作成します。
</p>

<p>
設計については，<a href="https://wiki.cis.iwate-u.ac.jp/~suzuki/lects/prog/org-docs/card-display/#outline-container-sec-2">card_display_simple問題への解法</a> も参考にしてくださ
い。
</p>
</div>

<div id="outline-container-sec-23-1" class="outline-3">
<h3 id="sec-23-1"><span class="section-number-3">23.1</span> card_to_string のテストを書く</h3>
<div class="outline-text-3" id="text-23-1">
<p>
機能の名前を card_to_string とし, card_to_stringが満たすテストを書きます:
</p>

<div class="org-src-container">

<pre class="src src-c">Card sa = card_new(SPADE, ACE);

strcmp(card_to_string(sa), "SA")==0;
</pre>
</div>

<p>
テスト関数にします。
</p>

<div class="org-src-container">

<pre class="src src-c">void
test_card_to_string(void)
{
  cut_set_message("カードを文字列にする");
  {
    Card sa = card_new(SPADE,ACE);

    cut_assert(strcmp(card_to_string(sa), "SA")==0);
  }
}


void
test_card_to_string(void)
{
  cut_set_message("カードを文字列にする");
  {
    Card sa = card_new(SPADE,ACE);

    cut_assert(strcmp(card_to_string(sa), "SA")==0);
  }
}
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-23-2" class="outline-3">
<h3 id="sec-23-2"><span class="section-number-3">23.2</span> card_to_string のインタフェースを決める</h3>
<div class="outline-text-3" id="text-23-2">
<p>
card_to_string を関数の形で書けたので，関数の型を決めます。
</p>

<p>
戻り値の型は char *，与える引数はカードなので:
</p>

<div class="org-src-container">

<pre class="src src-c">char *card_to_string(Card);
char *card_to_string(Card);
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-23-3" class="outline-3">
<h3 id="sec-23-3"><span class="section-number-3">23.3</span> テスト全体プログラムの確認</h3>
<div class="outline-text-3" id="text-23-3">
<p>
test/test_card.cは次のようになります:
</p>

<div class="org-src-container">

<pre class="src src-c">// test/test_card.c
# include &lt;cutter.h&gt;
# include &lt;card.h&gt;
// test/test_card.c
# include &lt;cutter.h&gt;
# include &lt;card.h&gt;

void
test_card_suit_new_from_string(void)
{
  cut_set_message("文字列からスーツを作成する。");
  cut_assert_true(card_suit_new_from_string("SPADE")==SPADE);
  cut_assert_true(card_suit_new_from_string("HEART")==HEART);
  cut_assert_true(card_suit_new_from_string("DIAMOND")==DIAMOND);
  cut_assert_true(card_suit_new_from_string("CLUB")==CLUB);
}
void
test_card_suit_new_from_string(void)
{
  cut_set_message("文字列からスーツを作成する。");
  cut_assert_true(card_suit_new_from_string("SPADE")==SPADE);
  cut_assert_true(card_suit_new_from_string("HEART")==HEART);
  cut_assert_true(card_suit_new_from_string("DIAMOND")==DIAMOND);
  cut_assert_true(card_suit_new_from_string("CLUB")==CLUB);
}

void
test_card_no_new_from_string(void)
{
  cut_set_message("番号から数値への変換のテスト");
  cut_assert(card_no_new_from_string("1")==ACE);
  cut_assert(card_no_new_from_string("13")==KING);
  cut_assert(card_no_new_from_string("12")==QUEEN);
  cut_assert(card_no_new_from_string("11")==JACK);
  cut_assert(card_no_new_from_string("10")==10);
}
void
test_card_no_new_from_string(void)
{
  cut_set_message("番号から数値への変換のテスト");
  cut_assert(card_no_new_from_string("1")==ACE);
  cut_assert(card_no_new_from_string("13")==KING);
  cut_assert(card_no_new_from_string("12")==QUEEN);
  cut_assert(card_no_new_from_string("11")==JACK);
  cut_assert(card_no_new_from_string("10")==10);
}

void
test_card_new(void)
{
   cut_set_message("スーツと番号からカードを作成");
  {
    Card sa = card_new(SPADE,ACE);
    cut_assert(card_suit(sa)==SPADE);
    cut_assert(card_no(sa)==ACE);
  }
}
void
test_card_new(void)
{
   cut_set_message("スーツと番号からカードを作成");
  {
    Card sa = card_new(SPADE,ACE);
    cut_assert(card_suit(sa)==SPADE);
    cut_assert(card_no(sa)==ACE);
  }
}

char *card_to_string(Card);
char *card_to_string(Card);


void
test_card_to_string(void)
{
  cut_set_message("カードを文字列にする");
  {
    Card sa = card_new(SPADE,ACE);

    cut_assert(strcmp(card_to_string(sa), "SA")==0);
  }
}


void
test_card_to_string(void)
{
  cut_set_message("カードを文字列にする");
  {
    Card sa = card_new(SPADE,ACE);

    cut_assert(strcmp(card_to_string(sa), "SA")==0);
  }
}
</pre>
</div>

<div class="org-src-container">

<pre class="src src-c">// src/card.h
# include &lt;string.h&gt;
// src/card.h
# include &lt;string.h&gt;

enum e_Suit {CLUB=1,DIAMOND,HEART,SPADE};
enum e_Suit card_suit_new_from_string(char *);
enum e_Suit {CLUB=1,DIAMOND,HEART,SPADE};
enum e_Suit card_suit_new_from_string(char *);

enum e_No { TWO=2, THREE, FOUR, FIVE,
	    SIX, SEVEN, EIGHT, NINE, TEN,
	    JACK, QUEEN, KING, ACE};
enum e_No card_no_new_from_string(char *);
enum e_No { TWO=2, THREE, FOUR, FIVE,
	    SIX, SEVEN, EIGHT, NINE, TEN,
	    JACK, QUEEN, KING, ACE};
enum e_No card_no_new_from_string(char *);

struct _Card {
  enum e_Suit suit;
  enum e_No no;
};
struct _Card {
  enum e_Suit suit;
  enum e_No no;
};

typedef struct _Card Card;

enum e_Suit card_suit(Card);
enum e_No card_no(Card);
Card card_new(enum e_Suit, enum e_No);
typedef struct _Card Card;

enum e_Suit card_suit(Card);
enum e_No card_no(Card);
Card card_new(enum e_Suit, enum e_No);
// src/card.h
# include &lt;string.h&gt;
// src/card.h
# include &lt;string.h&gt;

enum e_Suit {CLUB=1,DIAMOND,HEART,SPADE};
enum e_Suit card_suit_new_from_string(char *);
enum e_Suit {CLUB=1,DIAMOND,HEART,SPADE};
enum e_Suit card_suit_new_from_string(char *);

enum e_No { TWO=2, THREE, FOUR, FIVE,
	    SIX, SEVEN, EIGHT, NINE, TEN,
	    JACK, QUEEN, KING, ACE};
enum e_No card_no_new_from_string(char *);
enum e_No { TWO=2, THREE, FOUR, FIVE,
	    SIX, SEVEN, EIGHT, NINE, TEN,
	    JACK, QUEEN, KING, ACE};
enum e_No card_no_new_from_string(char *);

struct _Card {
  enum e_Suit suit;
  enum e_No no;
};
struct _Card {
  enum e_Suit suit;
  enum e_No no;
};

typedef struct _Card Card;

enum e_Suit card_suit(Card);
enum e_No card_no(Card);
Card card_new(enum e_Suit, enum e_No);
typedef struct _Card Card;

enum e_Suit card_suit(Card);
enum e_No card_no(Card);
Card card_new(enum e_Suit, enum e_No);
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-23-4" class="outline-3">
<h3 id="sec-23-4"><span class="section-number-3">23.4</span> test/Makefile の確認</h3>
<div class="outline-text-3" id="text-23-4">
<p>
test/Makefile の目的は変わっていませんので，Makefile の更新の必要はありません。
</p>

<div class="org-src-container">

<pre class="src src-c"># test/Makefile
.PHONY: clean
CFLAGS = -fPIC -I../src `pkg-config cutter --cflags`
LDFLAGS = -L../src/ -lcard `pkg-config cutter --libs`

test_card.so: test_card.o
	gcc -o $@ --shared $^ $(LDFLAGS)

test_card.o: test_card.c
	gcc -c $&lt; $(CFLAGS)

clean:
	rm -f *.o *.so *~ \#* *.gch
# test/Makefile
.PHONY: clean
CFLAGS = -fPIC -I../src `pkg-config cutter --cflags`
LDFLAGS = -L../src/ -lcard `pkg-config cutter --libs`

test_card.so: test_card.o
	gcc -o $@ --shared $^ $(LDFLAGS)

test_card.o: test_card.c
	gcc -c $&lt; $(CFLAGS)

clean:
	rm -f *.o *.so *~ \#* *.gch
</pre>
</div>

<p>
test/test_card.c には card_to_string に関するテスト関数が加わっています。
card_to_string はまだ未実装ですが，test/test_card.o は作成できます。
</p>
</div>
</div>

<div id="outline-container-sec-23-5" class="outline-3">
<h3 id="sec-23-5"><span class="section-number-3">23.5</span> test/test_card.o の作成</h3>
<div class="outline-text-3" id="text-23-5">
<div class="org-src-container">

<pre class="src src-sh"># ~/progs/card_display/simple/test
make test_card.o
</pre>
</div>

<p>
test_card.o ができれば，ひとまず，成功です。
</p>

<p>
できない時は，test_card.c に間違いがあるか，Makefile に間違いがあ
ります。エラーメッセージからどちらの間違いなのか特定し，修正しましょ
う。
</p>

<p>
成功したら，test/test_card.o の中身を見てみましょう:
</p>

<div class="org-src-container">

<pre class="src src-sh"># ~/progs/card_display/simple/test
nm test_card.o
</pre>
</div>

<p>
card_to_stringが未定義で，
test_card_to_string が定義されているのがわかります。
</p>
</div>
</div>
</div>

<div id="outline-container-sec-24" class="outline-2">
<h2 id="sec-24"><span class="section-number-2">24</span> card_to_string の実装</h2>
<div class="outline-text-2" id="text-24">
<p>
さて次は，機能 card_to_string の実装です。
手順は，card_newを実装したときと同様です:
</p>

<ul class="org-ul">
<li>test/test_card.c を作成するときに決めたインタフェースをとりだし，
src/card.h に移す。
</li>
<li>src/card.hを遵守し，src/card.c に機能を追加実装する。
</li>
<li>提供する機能を入れた src/libcard.a を作成する
</li>
</ul>

<p>
src/{card.h，libcard.a} で機能を提供する
</p>
</div>

<div id="outline-container-sec-24-1" class="outline-3">
<h3 id="sec-24-1"><span class="section-number-3">24.1</span> card/card.h の更新</h3>
<div class="outline-text-3" id="text-24-1">
<p>
test/test_card.c から card_to_string等に関するインタフェース宣言を，
src/card.h に移します。
</p>

<p>
ここまでで，src/card.h は次のようになります:
</p>

<div class="org-src-container">

<pre class="src src-c">// src/card.h
# include &lt;string.h&gt;
// src/card.h
# include &lt;string.h&gt;

enum e_Suit {CLUB=1,DIAMOND,HEART,SPADE};
enum e_Suit card_suit_new_from_string(char *);
enum e_Suit {CLUB=1,DIAMOND,HEART,SPADE};
enum e_Suit card_suit_new_from_string(char *);

enum e_No { TWO=2, THREE, FOUR, FIVE,
	    SIX, SEVEN, EIGHT, NINE, TEN,
	    JACK, QUEEN, KING, ACE};
enum e_No card_no_new_from_string(char *);
enum e_No { TWO=2, THREE, FOUR, FIVE,
	    SIX, SEVEN, EIGHT, NINE, TEN,
	    JACK, QUEEN, KING, ACE};
enum e_No card_no_new_from_string(char *);

struct _Card {
  enum e_Suit suit;
  enum e_No no;
};
struct _Card {
  enum e_Suit suit;
  enum e_No no;
};

typedef struct _Card Card;

enum e_Suit card_suit(Card);
enum e_No card_no(Card);
Card card_new(enum e_Suit, enum e_No);
typedef struct _Card Card;

enum e_Suit card_suit(Card);
enum e_No card_no(Card);
Card card_new(enum e_Suit, enum e_No);

char *card_to_string(Card);
char *card_to_string(Card);
// src/card.h
# include &lt;string.h&gt;
// src/card.h
# include &lt;string.h&gt;

enum e_Suit {CLUB=1,DIAMOND,HEART,SPADE};
enum e_Suit card_suit_new_from_string(char *);
enum e_Suit {CLUB=1,DIAMOND,HEART,SPADE};
enum e_Suit card_suit_new_from_string(char *);

enum e_No { TWO=2, THREE, FOUR, FIVE,
	    SIX, SEVEN, EIGHT, NINE, TEN,
	    JACK, QUEEN, KING, ACE};
enum e_No card_no_new_from_string(char *);
enum e_No { TWO=2, THREE, FOUR, FIVE,
	    SIX, SEVEN, EIGHT, NINE, TEN,
	    JACK, QUEEN, KING, ACE};
enum e_No card_no_new_from_string(char *);

struct _Card {
  enum e_Suit suit;
  enum e_No no;
};
struct _Card {
  enum e_Suit suit;
  enum e_No no;
};

typedef struct _Card Card;

enum e_Suit card_suit(Card);
enum e_No card_no(Card);
Card card_new(enum e_Suit, enum e_No);
typedef struct _Card Card;

enum e_Suit card_suit(Card);
enum e_No card_no(Card);
Card card_new(enum e_Suit, enum e_No);

char *card_to_string(Card);
char *card_to_string(Card);
</pre>
</div>
<p>
test/test_card.c は次のようになります：
</p>

<div class="org-src-container">

<pre class="src src-c">// test/test_card.c
# include &lt;cutter.h&gt;
# include &lt;card.h&gt;
// test/test_card.c
# include &lt;cutter.h&gt;
# include &lt;card.h&gt;

void
test_card_suit_new_from_string(void)
{
  cut_set_message("文字列からスーツを作成する。");
  cut_assert_true(card_suit_new_from_string("SPADE")==SPADE);
  cut_assert_true(card_suit_new_from_string("HEART")==HEART);
  cut_assert_true(card_suit_new_from_string("DIAMOND")==DIAMOND);
  cut_assert_true(card_suit_new_from_string("CLUB")==CLUB);
}
void
test_card_suit_new_from_string(void)
{
  cut_set_message("文字列からスーツを作成する。");
  cut_assert_true(card_suit_new_from_string("SPADE")==SPADE);
  cut_assert_true(card_suit_new_from_string("HEART")==HEART);
  cut_assert_true(card_suit_new_from_string("DIAMOND")==DIAMOND);
  cut_assert_true(card_suit_new_from_string("CLUB")==CLUB);
}

void
test_card_no_new_from_string(void)
{
  cut_set_message("番号から数値への変換のテスト");
  cut_assert(card_no_new_from_string("1")==ACE);
  cut_assert(card_no_new_from_string("13")==KING);
  cut_assert(card_no_new_from_string("12")==QUEEN);
  cut_assert(card_no_new_from_string("11")==JACK);
  cut_assert(card_no_new_from_string("10")==10);
}
void
test_card_no_new_from_string(void)
{
  cut_set_message("番号から数値への変換のテスト");
  cut_assert(card_no_new_from_string("1")==ACE);
  cut_assert(card_no_new_from_string("13")==KING);
  cut_assert(card_no_new_from_string("12")==QUEEN);
  cut_assert(card_no_new_from_string("11")==JACK);
  cut_assert(card_no_new_from_string("10")==10);
}

void
test_card_new(void)
{
   cut_set_message("スーツと番号からカードを作成");
  {
    Card sa = card_new(SPADE,ACE);
    cut_assert(card_suit(sa)==SPADE);
    cut_assert(card_no(sa)==ACE);
  }
}
void
test_card_new(void)
{
   cut_set_message("スーツと番号からカードを作成");
  {
    Card sa = card_new(SPADE,ACE);
    cut_assert(card_suit(sa)==SPADE);
    cut_assert(card_no(sa)==ACE);
  }
}


void
test_card_to_string(void)
{
  cut_set_message("カードを文字列にする");
  {
    Card sa = card_new(SPADE,ACE);

    cut_assert(strcmp(card_to_string(sa), "SA")==0);
  }
}


void
test_card_to_string(void)
{
  cut_set_message("カードを文字列にする");
  {
    Card sa = card_new(SPADE,ACE);

    cut_assert(strcmp(card_to_string(sa), "SA")==0);
  }
}
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-24-2" class="outline-3">
<h3 id="sec-24-2"><span class="section-number-3">24.2</span> card_to_string の実装 (src/card.cの更新)</h3>
<div class="outline-text-3" id="text-24-2">
<p>
card_to_string関数への要求を下記のように分解します:
</p>

<ul class="org-ul">
<li>スーツの内部表現を 'C', 'D', 'H', 'S' の文字へ

<p>
この機能を card_suit_to_char という関数で表します.
</p>

<ul class="org-ul">
<li>型は，char card_suit_to_char(enum e_Suit)

<p>
実装は，
</p>
</li>
</ul>
</li>
</ul>

<div class="org-src-container">

<pre class="src src-c">static char SuitChars[] =
  {'*', 'C', 'D', 'H', 'S'};
char 
card_suit_to_char(enum e_Suit suit)
{
  return SuitChars[suit];
}

static char SuitChars[] =
  {'*', 'C', 'D', 'H', 'S'};
char 
card_suit_to_char(enum e_Suit suit)
{
  return SuitChars[suit];
}
</pre>
</div>

<p>
スーツの文字型の配列を定義しています。0に相当するスーツ文字はな
いので，'*' にしています。
</p>

<ul class="org-ul">
<li>番号の内部表現を，2~9 の間に数値は，'2'~'9'へ，
10~14 は '0','J','Q','K','A' 
</li>
</ul>

<p>
この機能を card_no_to_char という関数で表します.
</p>

<ul class="org-ul">
<li>型は，char card_no_to_char(enum e_No)。
実装は，
</li>
</ul>

<div class="org-src-container">

<pre class="src src-c">static char NoChars[] =
  {'.', '*', '2', '3', '4', '5', '6', '7', '8', '9',
   '0', 'J', 'Q', 'K', 'A'};
char
card_no_to_char(enum e_No no)
{
  return NoChars[no];
}


static char NoChars[] =
  {'.', '*', '2', '3', '4', '5', '6', '7', '8', '9',
   '0', 'J', 'Q', 'K', 'A'};
char
card_no_to_char(enum e_No no)
{
  return NoChars[no];
}
</pre>
</div>

<ul class="org-ul">
<li>スーツを表す文字と番号を表す文字をあわせて，2文字からなる文字列
にする
</li>
</ul>

<p>
実装は次のようになるでしょう:
</p>

<div class="org-src-container">

<pre class="src src-c">char card_suit_to_char(enum e_Suit);
char card_no_to_char(enum e_No);
char *
card_to_string(Card c)
{
  char suit = card_suit_to_char(card_suit(c));
  char no = card_no_to_char(card_no(c));
  char *s = (char *) malloc(3);

  s[0] = suit;
  s[1] = no;
  s[2] = '\0';

  return s;
}

char card_suit_to_char(enum e_Suit);
char card_no_to_char(enum e_No);
char *
card_to_string(Card c)
{
  char suit = card_suit_to_char(card_suit(c));
  char no = card_no_to_char(card_no(c));
  char *s = (char *) malloc(3);

  s[0] = suit;
  s[1] = no;
  s[2] = '\0';

  return s;
}
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-24-3" class="outline-3">
<h3 id="sec-24-3"><span class="section-number-3">24.3</span> src/card.c 全体</h3>
<div class="outline-text-3" id="text-24-3">
<p>
ここまでの，src/card.c を示しておきます:
</p>

<div class="org-src-container">

<pre class="src src-c">// src/card.c
# include &lt;stdio.h&gt;
# include &lt;string.h&gt;
# include &lt;stdlib.h&gt;
# include &lt;card.h&gt;
// src/card.c
# include &lt;stdio.h&gt;
# include &lt;string.h&gt;
# include &lt;stdlib.h&gt;
# include &lt;card.h&gt;

enum e_Suit
card_suit_new_from_string(char *suit_str)
{
  if (strcmp("CLUB",suit_str)==0)
    return CLUB;
  if (strcmp("DIAMOND",suit_str)==0)
    return DIAMOND;
  if (strcmp("HEART",suit_str)==0)
    return HEART;
  if (strcmp("SPADE",suit_str)==0)
    return SPADE;
  return 0;
}
enum e_Suit
card_suit_new_from_string(char *suit_str)
{
  if (strcmp("CLUB",suit_str)==0)
    return CLUB;
  if (strcmp("DIAMOND",suit_str)==0)
    return DIAMOND;
  if (strcmp("HEART",suit_str)==0)
    return HEART;
  if (strcmp("SPADE",suit_str)==0)
    return SPADE;
  return 0;
}

enum e_No
card_no_new_from_string(char *no_str)
{
  int no = atoi(no_str);

  if (no==1)  no = ACE;

  if ( no &lt; TWO &amp;&amp; ACE &lt; no )
    {
      fprintf(stderr, "不適な数値 (%s)!\n", no_str);
    };
  return (enum e_No)no;
}
enum e_No
card_no_new_from_string(char *no_str)
{
  int no = atoi(no_str);

  if (no==1)  no = ACE;

  if ( no &lt; TWO &amp;&amp; ACE &lt; no )
    {
      fprintf(stderr, "不適な数値 (%s)!\n", no_str);
    };
  return (enum e_No)no;
}

Card
card_new(enum e_Suit suit, enum e_No no)
{
  Card new;

  new.suit = suit;
  new.no = no;
  return new;
}
Card
card_new(enum e_Suit suit, enum e_No no)
{
  Card new;

  new.suit = suit;
  new.no = no;
  return new;
}

enum e_Suit
card_suit(Card c)
{
  return c.suit;
}
enum e_Suit
card_suit(Card c)
{
  return c.suit;
}

enum e_No
card_no(Card c)
{
  return c.no;
}
enum e_No
card_no(Card c)
{
  return c.no;
}


char card_suit_to_char(enum e_Suit);
char card_no_to_char(enum e_No);
char *
card_to_string(Card c)
{
  char suit = card_suit_to_char(card_suit(c));
  char no = card_no_to_char(card_no(c));
  char *s = (char *) malloc(3);

  s[0] = suit;
  s[1] = no;
  s[2] = '\0';

  return s;
}

char card_suit_to_char(enum e_Suit);
char card_no_to_char(enum e_No);
char *
card_to_string(Card c)
{
  char suit = card_suit_to_char(card_suit(c));
  char no = card_no_to_char(card_no(c));
  char *s = (char *) malloc(3);

  s[0] = suit;
  s[1] = no;
  s[2] = '\0';

  return s;
}


static char SuitChars[] =
  {'*', 'C', 'D', 'H', 'S'};
char 
card_suit_to_char(enum e_Suit suit)
{
  return SuitChars[suit];
}

static char SuitChars[] =
  {'*', 'C', 'D', 'H', 'S'};
char 
card_suit_to_char(enum e_Suit suit)
{
  return SuitChars[suit];
}


static char NoChars[] =
  {'.', '*', '2', '3', '4', '5', '6', '7', '8', '9',
   '0', 'J', 'Q', 'K', 'A'};
char
card_no_to_char(enum e_No no)
{
  return NoChars[no];
}


static char NoChars[] =
  {'.', '*', '2', '3', '4', '5', '6', '7', '8', '9',
   '0', 'J', 'Q', 'K', 'A'};
char
card_no_to_char(enum e_No no)
{
  return NoChars[no];
}
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-24-4" class="outline-3">
<h3 id="sec-24-4"><span class="section-number-3">24.4</span> src/Makefile</h3>
<div class="outline-text-3" id="text-24-4">
<p>
src/Makefileに変更はありません。
</p>
<div class="org-src-container">

<pre class="src src-c"># src/Makefile 
.PHONY: clean
CFLAGS = -g -c -fPIC -I. 
LDFLAGS = -lc

libcard.a: card.o
	rm -f $@
	ar r $@ $^

card.o: card.c card.h
	gcc $&lt; $(CFLAGS)

clean: 
	rm -f *.o *.so *~ \#* *.gch

# src/Makefile 
.PHONY: clean
CFLAGS = -g -c -fPIC -I. 
LDFLAGS = -lc

libcard.a: card.o
	rm -f $@
	ar r $@ $^

card.o: card.c card.h
	gcc $&lt; $(CFLAGS)

clean: 
	rm -f *.o *.so *~ \#* *.gch
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-24-5" class="outline-3">
<h3 id="sec-24-5"><span class="section-number-3">24.5</span> src/card.o の作成</h3>
<div class="outline-text-3" id="text-24-5">
<p>
src/card.o を make し, ソースコードにエラーがないか確かめます:
</p>

<div class="org-src-container">

<pre class="src src-sh"># ~/progs/card_display/simple/src
make card.o
</pre>
</div>

<pre class="example">
gcc card.c -g -c -fPIC -I. 
</pre>

<p>
src/card.o ができれば文法や宣言の食い違いはなくなったことになりま
す。
</p>
</div>
</div>

<div id="outline-container-sec-24-6" class="outline-3">
<h3 id="sec-24-6"><span class="section-number-3">24.6</span> src/libcard.a の作成</h3>
<div class="outline-text-3" id="text-24-6">
<p>
src/card.o ができれば，次は， src/libcard.a を make します。
</p>

<div class="org-src-container">

<pre class="src src-sh"># ~/progs/card_display/simple/src
make libcard.a
</pre>
</div>

<pre class="example">
rm -f libcard.a
ar r libcard.a card.o
</pre>

<p>
Makefile が正しければ，これは成功するはずです。
</p>

<p>
libcard.a の中身を確かめてみましょう:
</p>

<div class="org-src-container">

<pre class="src src-sh"># ~/progs/card_display/simple/src
nm libcard.a
</pre>
</div>

<pre class="example">
card.o:
                 U _GLOBAL_OFFSET_TABLE_
                 U atoi
00000000000000e6 T card_new
000000000000010f T card_no
000000000000008b T card_no_new_from_string
0000000000000102 T card_suit
0000000000000000 T card_suit_new_from_string
                 U fprintf
                 U stderr
                 U strcmp
</pre>

<p>
src/libcard.a が更新できたので，次はtest_card.so を更新します。    
</p>
</div>
</div>
</div>

<div id="outline-container-sec-25" class="outline-2">
<h2 id="sec-25"><span class="section-number-2">25</span> テスト</h2>
<div class="outline-text-2" id="text-25">
</div><div id="outline-container-sec-25-1" class="outline-3">
<h3 id="sec-25-1"><span class="section-number-3">25.1</span> test/test_card.so のビルド</h3>
<div class="outline-text-3" id="text-25-1">
<p>
src/libcard.a が更新されているので，test/test_card.so を作り直しま
す。
</p>

<div class="org-src-container">

<pre class="src src-sh"># ~/progs/card_display/simple/test/
make clean
make test_card.so
</pre>
</div>


<p>
test/test_card.so ができればテストの実行に移ります。
</p>

<p>
できない時は，多分，Makefile に間違いがあります。Makefile を修正してください。
</p>
</div>
</div>

<div id="outline-container-sec-25-2" class="outline-3">
<h3 id="sec-25-2"><span class="section-number-3">25.2</span> テストの実行</h3>
<div class="outline-text-3" id="text-25-2">
<p>
テストの作成と機能の実装が終ったので，機能が要求を満たすことを確か
めるためにテストする:
</p>

<div class="org-src-container">

<pre class="src src-sh"># ~/progs/card_display/simple
cutter -v v test
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-25-3" class="outline-3">
<h3 id="sec-25-3"><span class="section-number-3">25.3</span> テストと再設計</h3>
<div class="outline-text-3" id="text-25-3">
<p>
テストが成功すれば，テストによる開発の1サイクルが完結したことにな
ります。
</p>

<p>
テストが失敗した場合は，test/test_card.c, src/{card.h, card.c} を
修正していくことになります。
</p>

<p>
ソースコードを修正した後は，Makefileに間違いがなけれ
ば，~/progs/card_display/simpleで make すれば，全自動でテストまで
実行してくれます。テストが成功するまで繰り返してください。
</p>
</div>
</div>
</div>

<div id="outline-container-sec-26" class="outline-2">
<h2 id="sec-26"><span class="section-number-2">26</span> card_display_simple 問題の解の作成</h2>
<div class="outline-text-2" id="text-26">
<ul class="org-ul">
<li>~/progs/card_display/simple/ <code>に，</code> 
</li>

<li>作成した src/libcard.a <code>を利用し，</code> 
    の中で提供した関数を利用し，
</li>

<li>card_display_simple.c を作成し，
</li>

<li>Makefile を書き換えて, card_display_simple をビルドできるように，
してください。
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-27" class="outline-2">
<h2 id="sec-27"><span class="section-number-2">27</span> card_display_multi</h2>
<div class="outline-text-2" id="text-27">
<p>
<code>Card cards[5];</code> を使って, card_display_simple.c
を書き換えてみましょう。ごく自然にできるはずです。
</p>
</div>
</div>

<div id="outline-container-sec-28" class="outline-2">
<h2 id="sec-28"><span class="section-number-2">28</span> card_display_sort</h2>
<div class="outline-text-2" id="text-28">
</div>
</div>

<div id="outline-container-sec-29" class="outline-2">
<h2 id="sec-29"><span class="section-number-2">29</span> 複数のカードをソートする機能</h2>
<div class="outline-text-2" id="text-29">
<p>
複数のカードを <b>Card型配列へのポインタ</b> で表すことにする:
</p>

<div class="org-src-container">

<pre class="src src-c">Card *cards;
</pre>
</div>

<p>
Card * が型で，cards が変数名。
</p>

<p>
ソートの機能は，関数で表す。
</p>

<p>
名前を cards_sort とする。cards_ は複数のカードを扱う関数の接頭詞と
した。
</p>

<p>
次に，関数 cards_sort の型を決める。cards_sort へ何を与え，
cards_sort が何を返すかを考える:
</p>


<ul class="org-ul">
<li>cards_sort は関数である:

<pre class="example">
cards_sort()
</pre>
</li>

<li>複数のカードをもらう:

<pre class="example">
cards_sort(Card *)
</pre>
</li>

<li>複数のカードの枚数ももらう:

<pre class="example">
cards_sort(Card *, int)
</pre>
</li>

<li>返す値は， (ソートした) 複数のカード:

<pre class="example">
Card *cards_sort(Card *, int)
</pre>
</li>
</ul>

<p>
ということで，関数の宣言全体は下記となります:
</p>

<div class="org-src-container">

<pre class="src src-c">Card *cards_sort(Card *, int);
Card *cards_sort(Card *, int);
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-30" class="outline-2">
<h2 id="sec-30"><span class="section-number-2">30</span> 機能の追加とテストの作成</h2>
<div class="outline-text-2" id="text-30">
<p>
カードを作る機能のテストは，test/test_sort.c を新たに作成することにします。
</p>
</div>

<div id="outline-container-sec-30-1" class="outline-3">
<h3 id="sec-30-1"><span class="section-number-3">30.1</span> cards_sort のテストを書く</h3>
<div class="outline-text-3" id="text-30-1">
<p>
機能の名前を cards_sort とし, cards_sortが満たすテストを書きます。
</p>

<p>
まずは，試し書きしてみます:
</p>

<div class="org-src-container">

<pre class="src src-c">// test/test_sort.c

Card *cards, *sorted_cards;

sorted_cards = cards_sort(cards, 5);
</pre>
</div>

<p>
関数として書けますね。
</p>

<p>
まだテストにはなっていません。まず，テストのためのデータを用意して
みます:
</p>

<div class="org-src-container">

<pre class="src src-c">Card test_cards[5];
{
  test_cards[0] = card_new(SPADE,ACE);
  test_cards[1] = card_new(HEART,ACE);
  test_cards[2] = card_new(CLUB,2);
  test_cards[3] = card_new(DIAMOND,10);
  test_cards[4] = card_new(SPADE,2);
}
</pre>
</div>

<p>
よさそうです。
</p>

<p>
テストにするために，期待されるデータを用意し，ソート後のデータと比
較し，等しいことでテストにすることにします。
</p>

<p>
期待されるデータを用意します:
</p>

<div class="org-src-container">

<pre class="src src-c">Card expected_cards[5];
{
  expected_cards[4] = card_new(SPADE,ACE);
  expected_cards[3] = card_new(HEART,ACE);
  expected_cards[2] = card_new(DIAMOND,10);
  expected_cards[1] = card_new(SPADE,2);
  expected_cards[0] = card_new(CLUB,2);
}
</pre>
</div>


<p>
つぎにテストを書きます。テストの基本は，2枚のカードが等しいかです。
</p>

<p>
2枚のカードが等しいかを次のように書きたいところです:
</p>

<div class="org-src-container">

<pre class="src src-c">expected_cards[0]==sorted_cards[0]
</pre>
</div>

<p>
Card型の比較は == ではできません。関数で行なうことします:
</p>

<div class="org-src-container">

<pre class="src src-c">card_compare(expected_cards[0], sorted_cards[0])
</pre>
</div>


<p>
二枚のカードの比較を関数 card_compare で書けたので，
card_compare のインタフェースと機能を決めましょう：
</p>

<ul class="org-ul">
<li>card_compare は，2枚のカードを与え，それが等しいか大きいか小さい
かを0，1，-1で返す関数とします：
</li>

<li>card_compare は関数:

<pre class="example">
card_compare()
</pre>
</li>

<li>二枚のカードをもらって:

<pre class="example">
card_compare(Card, Card)
</pre>
</li>

<li>1,0,-1 の整数値を返す

<pre class="example">
int card_compare(Card, Card)
</pre>
</li>
</ul>

<p>
card_compare の宣言は次となります:
</p>

<div class="org-src-container">

<pre class="src src-c">int card_compare(Card, Card);
int card_compare(Card, Card);
</pre>
</div>

<p>
では，表明にしてみましょう:
</p>

<div class="org-src-container">

<pre class="src src-c">cut_assert(card_compare(expected_cards[0], sorted_cards[0])==0 );
</pre>
</div>

<p>
よさそうですね。
</p>

<p>
5枚のカードをテストする表明にして，全体を合わせて，関数にします。
</p>
</div>
</div>

<div id="outline-container-sec-30-2" class="outline-3">
<h3 id="sec-30-2"><span class="section-number-3">30.2</span> テスト全体プログラムの確認</h3>
<div class="outline-text-3" id="text-30-2">
<p>
test/test_sort.cは次のようになります:
</p>

<div class="org-src-container">

<pre class="src src-c">// test/test_sort.c
# include &lt;cutter.h&gt;
# include &lt;card.h&gt;
int card_compare(Card, Card);
int card_compare(Card, Card);
Card *cards_sort(Card *, int);
Card *cards_sort(Card *, int);
void
test_cards_sort(void)
{
  Card test_cards[5];
  {
    test_cards[0] = card_new(SPADE,ACE);
    test_cards[1] = card_new(HEART,ACE);
    test_cards[2] = card_new(CLUB,2);
    test_cards[3] = card_new(DIAMOND,10);
    test_cards[4] = card_new(SPADE,2);
  }

  Card expected_cards[5];
  {
    expected_cards[4] = card_new(SPADE,ACE);
    expected_cards[3] = card_new(HEART,ACE);
    expected_cards[2] = card_new(DIAMOND,10);
    expected_cards[1] = card_new(SPADE,2);
    expected_cards[0] = card_new(CLUB,2);
  }

  Card *cards, *sorted_cards;
  {
    cards = test_cards; // 2015.12.08 fixed
    sorted_cards = cards_sort(cards, 5);
  }

  int i;
  for (i=0; i&lt;5; i++)
    {
      cut_assert(card_compare(expected_cards[i], sorted_cards[i])==0 );
    }
}
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-30-3" class="outline-3">
<h3 id="sec-30-3"><span class="section-number-3">30.3</span> test/Makefile の確認</h3>
<div class="outline-text-3" id="text-30-3">
<p>
test_sort.c を用意したことで，
test/Makefile の目的は変わりました。Makefile を更新します:
</p>

<div class="org-src-container">

<pre class="src src-c"># test/Makefile
.PHONY: clean
CFLAGS = -fPIC -I../src `pkg-config cutter --cflags`
LDFLAGS = -L../src/ -lcard `pkg-config cutter --libs`

all: test_card.so test_sort.so

test_card.so: test_card.o 
	gcc -o $@ --shared $^ $(LDFLAGS)

test_card.o: test_card.c
	gcc -c $&lt; $(CFLAGS)

test_sort.so: test_sort.o 
	gcc -o $@ --shared $^ $(LDFLAGS)

test_sort.o: test_sort.c
	gcc -c $&lt; $(CFLAGS)

clean:
	rm -f *.o *.so *~ \#* *.gch
# test/Makefile
.PHONY: clean
CFLAGS = -fPIC -I../src `pkg-config cutter --cflags`
LDFLAGS = -L../src/ -lcard `pkg-config cutter --libs`

all: test_card.so test_sort.so

test_card.so: test_card.o 
	gcc -o $@ --shared $^ $(LDFLAGS)

test_card.o: test_card.c
	gcc -c $&lt; $(CFLAGS)

test_sort.so: test_sort.o 
	gcc -o $@ --shared $^ $(LDFLAGS)

test_sort.o: test_sort.c
	gcc -c $&lt; $(CFLAGS)

clean:
	rm -f *.o *.so *~ \#* *.gch
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-30-4" class="outline-3">
<h3 id="sec-30-4"><span class="section-number-3">30.4</span> test/test_sort.o の作成</h3>
<div class="outline-text-3" id="text-30-4">
<div class="org-src-container">

<pre class="src src-sh"># ~/progs/card_display/simple/test
make test_sort.o
</pre>
</div>

<p>
test_sort.o ができれば，ひとまず，成功です。
</p>

<p>
できない時は，test_sort.c に間違いがあるか，Makefile に間違いがあ
ります。エラーメッセージからどちらの間違いなのか特定し，修正しましょ
う。
</p>

<p>
成功したら，test/test_sort.o の中身を見てみましょう:
</p>

<div class="org-src-container">

<pre class="src src-sh"># ~/progs/card_display/simple/test
nm test_sort.o
</pre>
</div>

<p>
cards_sortが未定義で，test_cards_sort が定義されているのがわかるは
ずです。
</p>
</div>
</div>
</div>

<div id="outline-container-sec-31" class="outline-2">
<h2 id="sec-31"><span class="section-number-2">31</span> cards_sort，card_compare の実装</h2>
<div class="outline-text-2" id="text-31">
<p>
さて次は，機能 cards_sort, card_compare の実装です。
</p>

<p>
お決まりの手順です:
</p>

<ul class="org-ul">
<li>test/test_sort.c を作成するときに決めたインタフェースをとりだし，
src/card.h に移す。
</li>
<li>src/card.hを遵守し，*src/cards.c* に機能を追加実装する。
</li>
<li>提供する機能を入れた src/libcard.a を作成する
</li>
</ul>

<p>
src/{card.h，libcard.a} で機能を提供する
</p>
</div>

<div id="outline-container-sec-31-1" class="outline-3">
<h3 id="sec-31-1"><span class="section-number-3">31.1</span> card/card.h の更新</h3>
<div class="outline-text-3" id="text-31-1">
<p>
test/test_card.c から cards_sort等に関するインタフェース宣言を，
src/card.h に移します。
</p>

<p>
ここまでで，src/card.h は次のようになります:
</p>

<div class="org-src-container">

<pre class="src src-c">// src/card.h
# include &lt;string.h&gt;
// src/card.h
# include &lt;string.h&gt;

enum e_Suit {CLUB=1,DIAMOND,HEART,SPADE};
enum e_Suit card_suit_new_from_string(char *);
enum e_Suit {CLUB=1,DIAMOND,HEART,SPADE};
enum e_Suit card_suit_new_from_string(char *);

enum e_No { TWO=2, THREE, FOUR, FIVE,
	    SIX, SEVEN, EIGHT, NINE, TEN,
	    JACK, QUEEN, KING, ACE};
enum e_No card_no_new_from_string(char *);
enum e_No { TWO=2, THREE, FOUR, FIVE,
	    SIX, SEVEN, EIGHT, NINE, TEN,
	    JACK, QUEEN, KING, ACE};
enum e_No card_no_new_from_string(char *);

struct _Card {
  enum e_Suit suit;
  enum e_No no;
};
struct _Card {
  enum e_Suit suit;
  enum e_No no;
};

typedef struct _Card Card;

enum e_Suit card_suit(Card);
enum e_No card_no(Card);
Card card_new(enum e_Suit, enum e_No);
typedef struct _Card Card;

enum e_Suit card_suit(Card);
enum e_No card_no(Card);
Card card_new(enum e_Suit, enum e_No);

char *card_to_string(Card);
char *card_to_string(Card);

int card_compare(Card, Card);
int card_compare(Card, Card);
Card *cards_sort(Card *, int);
Card *cards_sort(Card *, int);
// src/card.h
# include &lt;string.h&gt;
// src/card.h
# include &lt;string.h&gt;

enum e_Suit {CLUB=1,DIAMOND,HEART,SPADE};
enum e_Suit card_suit_new_from_string(char *);
enum e_Suit {CLUB=1,DIAMOND,HEART,SPADE};
enum e_Suit card_suit_new_from_string(char *);

enum e_No { TWO=2, THREE, FOUR, FIVE,
	    SIX, SEVEN, EIGHT, NINE, TEN,
	    JACK, QUEEN, KING, ACE};
enum e_No card_no_new_from_string(char *);
enum e_No { TWO=2, THREE, FOUR, FIVE,
	    SIX, SEVEN, EIGHT, NINE, TEN,
	    JACK, QUEEN, KING, ACE};
enum e_No card_no_new_from_string(char *);

struct _Card {
  enum e_Suit suit;
  enum e_No no;
};
struct _Card {
  enum e_Suit suit;
  enum e_No no;
};

typedef struct _Card Card;

enum e_Suit card_suit(Card);
enum e_No card_no(Card);
Card card_new(enum e_Suit, enum e_No);
typedef struct _Card Card;

enum e_Suit card_suit(Card);
enum e_No card_no(Card);
Card card_new(enum e_Suit, enum e_No);

char *card_to_string(Card);
char *card_to_string(Card);

int card_compare(Card, Card);
int card_compare(Card, Card);
Card *cards_sort(Card *, int);
Card *cards_sort(Card *, int);
</pre>
</div>

<p>
test/test_sort.c からは削除してください。
</p>
</div>
</div>

<div id="outline-container-sec-31-2" class="outline-3">
<h3 id="sec-31-2"><span class="section-number-3">31.2</span> cards_sort の実装 (src/cards.cの作成)</h3>
<div class="outline-text-3" id="text-31-2">
<p>
cards_sort関数の使い方は決まっています。
</p>

<div class="org-src-container">

<pre class="src src-c">Card *cards_sort(Card *, int);
Card *cards_sort(Card *, int);
</pre>
</div>

<p>
ことでした。ソートのプログラムを書いた経験をもとにします。
</p>

<p>
単純ソートは，選択範囲中で，最も小さいものを見付け範囲の先頭に動か
すことを，範囲をせばめながら行いことで，ソートを行います。
</p>

<p>
実装は次のようになるでしょう:
</p>

<div class="org-src-container">

<pre class="src src-c">Card *                                                                                         
cards_sort(Card *cards, int no_of_cards)
{
  int i;
  Card *pos;

  for(pos=cards, i=0; i&lt;no_of_cards; i++, pos++)
    {
      Card *cur;
      int j;

      for(j=i+1,cur=pos+1; j&lt;no_of_cards; j++, cur++)
	{
//        if (card_compare(*pos,*cur)&lt;=0)  2015.12.08 fixed
	  if (card_compare(*pos,*cur)&gt;=0)
	    {
	      Card temp = *pos;
	      *pos = *cur;
	      *cur = temp;
	    }
	}
    }
  return cards;
}
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-31-3" class="outline-3">
<h3 id="sec-31-3"><span class="section-number-3">31.3</span> card_compare の実装</h3>
<div class="outline-text-3" id="text-31-3">
<p>
card_compare の使い方も決まっています:
</p>

<div class="org-src-container">

<pre class="src src-c">int card_compare(Card, Card);
int card_compare(Card, Card);
</pre>
</div>

<p>
カードの番号の大小，スーツの大小をから，カードの大小を決めます:
</p>

<div class="org-src-container">

<pre class="src src-c">int
card_compare(Card a, Card b)
{
  if (card_no(a)&gt;card_no(b))
    return 1;
  if (card_no(a)&lt;card_no(b))
    return -1;
  if (card_suit(a)&gt;card_suit(b))
    return 1;
  if (card_suit(a)&lt;card_suit(b))
    return -1;
  return 0;
}
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-31-4" class="outline-3">
<h3 id="sec-31-4"><span class="section-number-3">31.4</span> cards.c の確認</h3>
<div class="outline-text-3" id="text-31-4">
<div class="org-src-container">

<pre class="src src-c">// src/card.c
# include &lt;stdio.h&gt;
# include &lt;string.h&gt;
# include &lt;stdlib.h&gt;
# include &lt;card.h&gt;
// src/card.c
# include &lt;stdio.h&gt;
# include &lt;string.h&gt;
# include &lt;stdlib.h&gt;
# include &lt;card.h&gt;

int
card_compare(Card a, Card b)
{
  if (card_no(a)&gt;card_no(b))
    return 1;
  if (card_no(a)&lt;card_no(b))
    return -1;
  if (card_suit(a)&gt;card_suit(b))
    return 1;
  if (card_suit(a)&lt;card_suit(b))
    return -1;
  return 0;
}

Card *                                                                                         
cards_sort(Card *cards, int no_of_cards)
{
  int i;
  Card *pos;

  for(pos=cards, i=0; i&lt;no_of_cards; i++, pos++)
    {
      Card *cur;
      int j;

      for(j=i+1,cur=pos+1; j&lt;no_of_cards; j++, cur++)
	{
//        if (card_compare(*pos,*cur)&lt;=0)  2015.12.08 fixed
	  if (card_compare(*pos,*cur)&gt;=0)
	    {
	      Card temp = *pos;
	      *pos = *cur;
	      *cur = temp;
	    }
	}
    }
  return cards;
}
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-31-5" class="outline-3">
<h3 id="sec-31-5"><span class="section-number-3">31.5</span> src/Makefile</h3>
<div class="outline-text-3" id="text-31-5">
<p>
src/Makefileには，src/cards.o を作成する規則が追加になり，
libcard.a を作る時，cards.o も取り込むように規則を変更します:
</p>

<div class="org-src-container">

<pre class="src src-c"># src/Makefile 
.PHONY: clean
CFLAGS = -g -c -fPIC -I. 
LDFLAGS = -lc

libcard.a: card.o cards.o
	rm -f $@
	ar r $@ $^

card.o: card.c card.h
	gcc $&lt; $(CFLAGS)

# (2015.12.08) cards.o: cards.o card.h 
cards.o: cards.c card.h 
	gcc $&lt; $(CFLAGS)

clean: 
	rm -f *.o *.so *~ \#* *.gch

# src/Makefile 
.PHONY: clean
CFLAGS = -g -c -fPIC -I. 
LDFLAGS = -lc

libcard.a: card.o cards.o
	rm -f $@
	ar r $@ $^

card.o: card.c card.h
	gcc $&lt; $(CFLAGS)

# (2015.12.08) cards.o: cards.o card.h 
cards.o: cards.c card.h 
	gcc $&lt; $(CFLAGS)

clean: 
	rm -f *.o *.so *~ \#* *.gch
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-31-6" class="outline-3">
<h3 id="sec-31-6"><span class="section-number-3">31.6</span> src/cards.o の作成</h3>
<div class="outline-text-3" id="text-31-6">
<p>
src/cards.o を make し, ソースコードにエラーがないか確かめます:
</p>

<div class="org-src-container">

<pre class="src src-sh"># ~/progs/card_display/simple/src
make cards.o
</pre>
</div>

<p>
src/cards.o ができれば文法や宣言の食い違いはなくなったことになりま
す。
</p>
</div>
</div>

<div id="outline-container-sec-31-7" class="outline-3">
<h3 id="sec-31-7"><span class="section-number-3">31.7</span> src/libcard.a の作成</h3>
<div class="outline-text-3" id="text-31-7">
<p>
src/cards.o ができれば，次は， src/libcard.a を make します。
</p>

<div class="org-src-container">

<pre class="src src-sh"># ~/progs/card_display/simple/src
make libcard.a
</pre>
</div>

<p>
Makefile が正しければ，これは成功するはずです。
</p>

<p>
libcard.a の中身を確かめてみましょう:
</p>

<div class="org-src-container">

<pre class="src src-sh"># ~/progs/card_display/simple/src
nm libcard.a
</pre>
</div>

<p>
src/libcard.a が更新できたので，次はtest_card.so を更新します。    
</p>
</div>
</div>
</div>

<div id="outline-container-sec-32" class="outline-2">
<h2 id="sec-32"><span class="section-number-2">32</span> テスト</h2>
<div class="outline-text-2" id="text-32">
</div><div id="outline-container-sec-32-1" class="outline-3">
<h3 id="sec-32-1"><span class="section-number-3">32.1</span> test/test_sort.so のビルド</h3>
<div class="outline-text-3" id="text-32-1">
<p>
test/test_sort.so を作り直します。
</p>

<div class="org-src-container">

<pre class="src src-sh"># ~/progs/card_display/simple/test/
make clean
make test_card.so
</pre>
</div>

<p>
test/test_card.so ができればテストの実行に移ります。
</p>

<p>
できない時は，多分，Makefile に間違いがあります。Makefile を修正してください。
</p>
</div>
</div>

<div id="outline-container-sec-32-2" class="outline-3">
<h3 id="sec-32-2"><span class="section-number-3">32.2</span> テストの実行</h3>
<div class="outline-text-3" id="text-32-2">
<p>
テストの作成と機能の実装が終ったので，機能が要求を満たすことを確か
めるためにテストする:
</p>

<div class="org-src-container">

<pre class="src src-sh"># ~/progs/card_display/simple
cutter -v v test
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-32-3" class="outline-3">
<h3 id="sec-32-3"><span class="section-number-3">32.3</span> テストと再設計</h3>
<div class="outline-text-3" id="text-32-3">
<p>
テストが成功すれば，テストによる開発の1サイクルが完結したことにな
ります。
</p>

<p>
テストが失敗した場合は，test/test_sort.c, src/{card.h, cards.c} を
修正していくことになります。
</p>

<p>
ソースコードを修正した後は，Makefileに間違いがなけれ
ば，~/progs/card_display/simpleで make すれば，全自動でテストまで
実行してくれます。テストが成功するまで繰り返してください。
</p>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="author">Author: Masayuki Suzuki</p>
<p class="date">Created: 2017-01-10 火 15:24</p>
<p class="creator"><a href="https://www.gnu.org/software/emacs/">Emacs</a> 25.1.1 (<a href="https://orgmode.org">Org</a> mode 8.2.10)</p>
<p class="validation"><a href="https://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
