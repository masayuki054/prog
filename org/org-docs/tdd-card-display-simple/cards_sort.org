# * カードのソート

#+name: Makefile
#+BEGIN_SRC Makefile :exports none
# ~/progs/card_display/simple/Makefile
.PHONY: clean card_test

card_test:
	(cd src; make)
	(cd test; make)	
	cutter -v v test/

clean:
	(cd src; make clean)
	(cd test; make clean)
	rm -f *.o *.so *~ \#* *.gch
#+END_SRC

#+name: src/Makefile
#+BEGIN_SRC Makefile :exports none 

# src/Makefile 
.PHONY: clean
CFLAGS = -g -c -fPIC -I. 
LDFLAGS = -lc

libcard.a: card.o
	rm -f $@
	ar r $@ $^

card.o: card.c card.h
	gcc $< $(CFLAGS)

clean: 
	rm -f *.o *.so *~ \#* *.gch
#+END_SRC

#+name: src/Makefile#cards
#+BEGIN_SRC Makefile :exports none 

# src/Makefile 
.PHONY: clean
CFLAGS = -g -c -fPIC -I. 
LDFLAGS = -lc

libcard.a: card.o cards.o
	rm -f $@
	ar r $@ $^

card.o: card.c card.h
	gcc $< $(CFLAGS)

# (2015.12.08) cards.o: cards.o card.h 
cards.o: cards.c card.h 
	gcc $< $(CFLAGS)

clean: 
	rm -f *.o *.so *~ \#* *.gch
#+END_SRC

#+name: test/Makefile
#+BEGIN_SRC Makefile :exports none
# test/Makefile
.PHONY: clean
CFLAGS = -fPIC -I../src `pkg-config cutter --cflags`
LDFLAGS = -L../src/ -lcard `pkg-config cutter --libs`

test_card.so: test_card.o
	gcc -o $@ --shared $^ $(LDFLAGS)

test_card.o: test_card.c
	gcc -c $< $(CFLAGS)

clean:
	rm -f *.o *.so *~ \#* *.gch
#+END_SRC

#+name: test/Makefile#test_sort
#+BEGIN_SRC Makefile :exports none
# test/Makefile
.PHONY: clean
CFLAGS = -fPIC -I../src `pkg-config cutter --cflags`
LDFLAGS = -L../src/ -lcard `pkg-config cutter --libs`

all: test_card.so test_sort.so

test_card.so: test_card.o 
	gcc -o $@ --shared $^ $(LDFLAGS)

test_card.o: test_card.c
	gcc -c $< $(CFLAGS)

test_sort.so: test_sort.o 
	gcc -o $@ --shared $^ $(LDFLAGS)

test_sort.o: test_sort.c
	gcc -c $< $(CFLAGS)

clean:
	rm -f *.o *.so *~ \#* *.gch
#+END_SRC
#+name: card.h#include
#+BEGIN_SRC c :exports none
// src/card.h
# include <string.h>
#+END_SRC

#+name: card.h#e_Suit
#+BEGIN_SRC c :exports none
enum e_Suit {CLUB=1,DIAMOND,HEART,SPADE};
enum e_Suit card_suit_new_from_string(char *);
#+END_SRC

#+name: card.h#e_No
#+BEGIN_SRC c :exports none
enum e_No { TWO=2, THREE, FOUR, FIVE,
	    SIX, SEVEN, EIGHT, NINE, TEN,
	    JACK, QUEEN, KING, ACE};
enum e_No card_no_new_from_string(char *);
#+END_SRC

#+name: card.h#card_struct 
#+BEGIN_SRC c :exports none
struct _Card {
  enum e_Suit suit;
  enum e_No no;
};
#+END_SRC

#+name: card.h#Card
#+BEGIN_SRC c :exports none
typedef struct _Card Card;

enum e_Suit card_suit(Card);
enum e_No card_no(Card);
Card card_new(enum e_Suit, enum e_No);
#+END_SRC

#+name: card.h#card_to_string
#+BEGIN_SRC c :exports none
char *card_to_string(Card);
#+END_SRC

#+name: card.h-suit_new
#+BEGIN_SRC c :exports none :noweb yes
<<card.h#include>>

<<card.h#e_Suit>>
#+END_SRC


#+name: card.h-no_new
#+BEGIN_SRC c :exports none :noweb yes
<<card.h#include>>

<<card.h#e_Suit>>

<<card.h#e_No>>

#+END_SRC

#+name: card.h-card_new
#+BEGIN_SRC c  :exports none :noweb yes
<<card.h#include>>

<<card.h#e_Suit>>

<<card.h#e_No>>

<<card.h#card_struct>>

<<card.h#Card>>
#+END_SRC

#+name: card.h-card_to_string
#+BEGIN_SRC c  :exports none :noweb yes
<<card.h#include>>

<<card.h#e_Suit>>

<<card.h#e_No>>

<<card.h#card_struct>>

<<card.h#Card>>

<<card.h#card_to_string>>
#+END_SRC

#+name:card.h#cards_sort
#+BEGIN_SRC C :exports none
Card *cards_sort(Card *, int);
#+END_SRC

#+name:card.h#card_compare
#+BEGIN_SRC C :exports none
int card_compare(Card, Card);
#+END_SRC

#+name: card.h-cards_sort
#+BEGIN_SRC c  :exports none :noweb yes
<<card.h#include>>

<<card.h#e_Suit>>

<<card.h#e_No>>

<<card.h#card_struct>>

<<card.h#Card>>

<<card.h#card_to_string>>

<<card.h#card_compare>>
<<card.h#cards_sort>>
#+END_SRC
#+name: test_card.c#include
#+BEGIN_SRC c :exports none
// test/test_card.c
# include <cutter.h>
# include <card.h>
#+END_SRC

#+name: test_card.c#suit_new
#+BEGIN_SRC c :exports none
void
test_card_suit_new_from_string(void)
{
  cut_set_message("文字列からスーツを作成する。");
  cut_assert_true(card_suit_new_from_string("SPADE")==SPADE);
  cut_assert_true(card_suit_new_from_string("HEART")==HEART);
  cut_assert_true(card_suit_new_from_string("DIAMOND")==DIAMOND);
  cut_assert_true(card_suit_new_from_string("CLUB")==CLUB);
}
#+END_SRC

#+name: test_card.c#no_new
#+BEGIN_SRC c :exports none
void
test_card_no_new_from_string(void)
{
  cut_set_message("番号から数値への変換のテスト");
  cut_assert(card_no_new_from_string("1")==ACE);
  cut_assert(card_no_new_from_string("13")==KING);
  cut_assert(card_no_new_from_string("12")==QUEEN);
  cut_assert(card_no_new_from_string("11")==JACK);
  cut_assert(card_no_new_from_string("10")==10);
}
#+END_SRC

#+name: test_card.c#card_new
#+BEGIN_SRC c :exports none
void
test_card_new(void)
{
   cut_set_message("スーツと番号からカードを作成");
  {
    Card sa = card_new(SPADE,ACE);
    cut_assert(card_suit(sa)==SPADE);
    cut_assert(card_no(sa)==ACE);
  }
}
#+END_SRC

#+name: test_card.c#card_to_string
#+BEGIN_SRC c :exports none

void
test_card_to_string(void)
{
  cut_set_message("カードを文字列にする");
  {
    Card sa = card_new(SPADE,ACE);

    cut_assert(strcmp(card_to_string(sa), "SA")==0);
  }
}

#+END_SRC
#+name: test_sort.c#include
#+BEGIN_SRC c :exports none
// test/test_sort.c
# include <cutter.h>
# include <card.h>
#+END_SRC
#+name: test_sort.c#test_setup
#+BEGIN_SRC C :exports none
  Card test_cards[5];
  {
    test_cards[0] = card_new(SPADE,ACE);
    test_cards[1] = card_new(HEART,ACE);
    test_cards[2] = card_new(CLUB,2);
    test_cards[3] = card_new(DIAMOND,10);
    test_cards[4] = card_new(SPADE,2);
  }
#+END_SRC

#+name: test_sort.c#expected_setup
#+BEGIN_SRC C :exports none
  Card expected_cards[5];
  {
    expected_cards[4] = card_new(SPADE,ACE);
    expected_cards[3] = card_new(HEART,ACE);
    expected_cards[2] = card_new(DIAMOND,10);
    expected_cards[1] = card_new(SPADE,2);
    expected_cards[0] = card_new(CLUB,2);
  }
#+END_SRC

#+name: test_sort.c
#+BEGIN_SRC c :exports none
void
test_cards_sort(void)
{
  <<test_sort.c#test_setup>>

  <<test_sort.c#expected_setup>>

  Card *cards, *sorted_cards;
  {
    cards = test_cards; // 2015.12.08 fixed
    sorted_cards = cards_sort(cards, 5);
  }

  int i;
  for (i=0; i<5; i++)
    {
      cut_assert(card_compare(expected_cards[i], sorted_cards[i])==0 );
    }
}

#+END_SRC
#+name: card.c#include
#+BEGIN_SRC c :exports none
// src/card.c
# include <stdio.h>
# include <string.h>
# include <stdlib.h>
# include <card.h>
#+END_SRC

#+name: card.c#suit_new
#+BEGIN_SRC c :exports none
enum e_Suit
card_suit_new_from_string(char *suit_str)
{
  if (strcmp("CLUB",suit_str)==0)
    return CLUB;
  if (strcmp("DIAMOND",suit_str)==0)
    return DIAMOND;
  if (strcmp("HEART",suit_str)==0)
    return HEART;
  if (strcmp("SPADE",suit_str)==0)
    return SPADE;
  return 0;
}
#+END_SRC

#+name: card.c#no_new
#+BEGIN_SRC c :exports none
enum e_No
card_no_new_from_string(char *no_str)
{
  int no = atoi(no_str);

  if (no==1)  no = ACE;

  if ( no < TWO && ACE < no )
    {
      fprintf(stderr, "不適な数値 (%s)!\n", no_str);
    };
  return (enum e_No)no;
}
#+END_SRC

#+name: card.c#card_new
#+BEGIN_SRC c :exports none
Card
card_new(enum e_Suit suit, enum e_No no)
{
  Card new;

  new.suit = suit;
  new.no = no;
  return new;
}
#+END_SRC

#+name: card.c#card_suit
#+BEGIN_SRC c :exports none
enum e_Suit
card_suit(Card c)
{
  return c.suit;
}
#+END_SRC

#+name: card.c#card_no
#+BEGIN_SRC c :exports none
enum e_No
card_no(Card c)
{
  return c.no;
}
#+END_SRC

#+name:card.c#card_to_string
#+BEGIN_SRC c :exports none

char card_suit_to_char(enum e_Suit);
char card_no_to_char(enum e_No);
char *
card_to_string(Card c)
{
  char suit = card_suit_to_char(card_suit(c));
  char no = card_no_to_char(card_no(c));
  char *s = (char *) malloc(3);

  s[0] = suit;
  s[1] = no;
  s[2] = '\0';

  return s;
}
#+END_SRC

#+name:card.c#card_suit_to_char
#+BEGIN_SRC c :exports none

static char SuitChars[] =
  {'*', 'C', 'D', 'H', 'S'};
char 
card_suit_to_char(enum e_Suit suit)
{
  return SuitChars[suit];
}
#+END_SRC

#+name:card.c#card_no_to_char
#+BEGIN_SRC c :exports none

static char NoChars[] =
  {'.', '*', '2', '3', '4', '5', '6', '7', '8', '9',
   '0', 'J', 'Q', 'K', 'A'};
char
card_no_to_char(enum e_No no)
{
  return NoChars[no];
}

#+END_SRC
#+name: cards.c#include
#+BEGIN_SRC c :exports none
// src/cards.c
# include <card.h>
#+END_SRC

#+name: cards.c#card_compare
#+BEGIN_SRC c :exports none
int
card_compare(Card a, Card b)
{
  if (card_no(a)>card_no(b))
    return 1;
  if (card_no(a)<card_no(b))
    return -1;
  if (card_suit(a)>card_suit(b))
    return 1;
  if (card_suit(a)<card_suit(b))
    return -1;
  return 0;
}
#+END_SRC

#+name: cards.c#cards_sort
#+BEGIN_SRC c :exports none
Card *                                                                                         
cards_sort(Card *cards, int no_of_cards)
{
  int i;
  Card *pos;

  for(pos=cards, i=0; i<no_of_cards; i++, pos++)
    {
      Card *cur;
      int j;

      for(j=i+1,cur=pos+1; j<no_of_cards; j++, cur++)
        {
//        if (card_compare(*pos,*cur)<=0)  2015.12.08 fixed
          if (card_compare(*pos,*cur)>=0)
            {
              Card temp = *pos;
              *pos = *cur;
              *cur = temp;
            }
	}
    }
  return cards;
}
#+END_SRC


#+BEGIN_SRC sh :exports none
rm -rf babel/simple/cards_sort/Makefile babel/simple/cards_sort/test babel/simple/cards_sort/src
mkdir -p babel/simple/cards_sort/src babel/simple/cards_sort/test

#+END_SRC

#+RESULTS:

#+BEGIN_SRC c :noweb yes :tangle babel/simple/cards_sort/Makefile :exports none
<<Makefile>>
#+END_SRC
#+BEGIN_SRC c :noweb yes :tangle babel/simple/cards_sort/src/Makefile :exports none
<<src/Makefile>>
#+END_SRC
#+BEGIN_SRC c :noweb yes :tangle babel/simple/cards_sort/src/card.c :exports none
<<card.c#include>>
<<card.c#suit_new>>
<<card.c#no_new>>
<<card.c#card_new>>
<<card.c#card_suit>>
<<card.c#card_no>>
#+END_SRC

#+BEGIN_SRC c :noweb yes :tangle babel/simple/cards_sort/test/Makefile :exports none
<<test/Makefile>>
#+END_SRC
#+BEGIN_SRC c :noweb yes :tangle babel/simple/cards_sort/test/test_card.c :exports none
<<test_card.c#include>>
<<test_card.c#suit_new>>
<<test_card.c#no_new>>
<<test_card.c#card_new>>
#+END_SRC

** Doing checks [2/3]
   - [X] document structure check
   - [X] tangle check
   - [ ] shell check

** 複数のカードをソートする機能

   複数のカードを *Card型配列へのポインタ* で表すことにする:

#+BEGIN_SRC c

  Card *cards;

#+END_SRC

   Card * が型で，cards が変数名。

   ソートの機能は，関数で表す。

   名前を cards_sort とする。cards_ は複数のカードを扱う関数の接頭詞と
   した。

   次に，関数 cards_sort の型を決める。cards_sort へ何を与え，
   cards_sort が何を返すかを考える:


   - cards_sort は関数である:
     
     : cards_sort()
   
   - 複数のカードをもらう:

     : cards_sort(Card *)

   - 複数のカードの枚数ももらう:
     
     : cards_sort(Card *, int)

   - 返す値は， (ソートした) 複数のカード:

     : Card *cards_sort(Card *, int)

   ということで，関数の宣言全体は下記となります:

#+BEGIN_SRC c :noweb yes

<<card.h#cards_sort>>

#+END_SRC

** 機能の追加とテストの作成
   
   カードを作る機能のテストは，test/test_sort.c を新たに作成することにします。
   
*** cards_sort のテストを書く
    
    機能の名前を cards_sort とし, cards_sortが満たすテストを書きます。
    
    まずは，試し書きしてみます:
    
    #+BEGIN_SRC c 
// test/test_sort.c

Card *cards, *sorted_cards;

sorted_cards = cards_sort(cards, 5);

    #+END_SRC
    
    関数として書けますね。

    まだテストにはなっていません。まず，テストのためのデータを用意して
    みます:

#+BEGIN_SRC c :noweb yes

<<test_sort.c#test_setup>>

#+END_SRC

    よさそうです。

    テストにするために，期待されるデータを用意し，ソート後のデータと比
    較し，等しいことでテストにすることにします。

    期待されるデータを用意します:

#+BEGIN_SRC c :noweb yes

<<test_sort.c#expected_setup>>

#+END_SRC


    つぎにテストを書きます。テストの基本は，2枚のカードが等しいかです。

    2枚のカードが等しいかを次のように書きたいところです:
    
#+BEGIN_SRC c
    expected_cards[0]==sorted_cards[0]
#+END_SRC    

    Card型の比較は == ではできません。関数で行なうことします:

#+BEGIN_SRC c
    card_compare(expected_cards[0], sorted_cards[0])
#+END_SRC    

    
    二枚のカードの比較を関数 card_compare で書けたので，
    card_compare のインタフェースと機能を決めましょう：

    - card_compare は，2枚のカードを与え，それが等しいか大きいか小さい
      かを0，1，-1で返す関数とします：

    - card_compare は関数:
      
      : card_compare()

    - 二枚のカードをもらって:

      : card_compare(Card, Card)

    - 1,0,-1 の整数値を返す

      : int card_compare(Card, Card)

    card_compare の宣言は次となります:

#+BEGIN_SRC c :noweb yes
<<card.h#card_compare>>
#+END_SRC

    では，表明にしてみましょう:

#+BEGIN_SRC c 
    cut_assert(card_compare(expected_cards[0], sorted_cards[0])==0 );
#+END_SRC

    よさそうですね。

    5枚のカードをテストする表明にして，全体を合わせて，関数にします。

*** テスト全体プログラムの確認

    test/test_sort.cは次のようになります:
    
    #+BEGIN_SRC c :tangle babel/simple/cards_sort/test/test_sort.0.c :noweb yes
<<test_sort.c#include>>
<<card.h#card_compare>>
<<card.h#cards_sort>>
<<test_sort.c>>
    #+END_SRC

#+BEGIN_SRC c :noweb yes :tangle babel/simple/cards_sort/src/card.h-card_new :exports none
<<card.h-card_new>>
#+END_SRC

#+BEGIN_SRC sh :dir babel/simple/cards_sort/src/ :exports none
cp card.h-card_new card.h
#+END_SRC

#+RESULTS:

*** test/Makefile の確認

    test_sort.c を用意したことで，
    test/Makefile の目的は変わりました。Makefile を更新します:

#+BEGIN_SRC c :noweb yes :tangle babel/simple/cards_sort/test/Makefile
<<test/Makefile#test_sort>>
#+END_SRC
    
*** test/test_sort.o の作成
    
    #+BEGIN_SRC sh :exports none :dir babel/simple/cards_sort/test
cp test_sort.0.c test_sort.c
    #+END_SRC
    
    #+RESULTS:
    
    #+BEGIN_SRC sh :results output :dir babel/simple/cards_sort/test :exports both

# ~/progs/card_display/simple/test
make test_sort.o

    #+END_SRC

    #+RESULTS:
    : gcc -c test_sort.c -fPIC -I../src `pkg-config cutter --cflags`

    
    test_sort.o ができれば，ひとまず，成功です。
    
    できない時は，test_sort.c に間違いがあるか，Makefile に間違いがあ
    ります。エラーメッセージからどちらの間違いなのか特定し，修正しましょ
    う。
    
    成功したら，test/test_sort.o の中身を見てみましょう:
    
    #+BEGIN_SRC sh :results output :dir babel/simple/cards_sort/test :exports both
# ~/progs/card_display/simple/test
nm test_sort.o
    #+END_SRC

    #+RESULTS:
    #+begin_example
    000000000000033d s L_.str
    0000000000000360 s L_.str1
    00000000000003a2 s L_.str2
    0000000000000349 s L___PRETTY_FUNCTION__.test_cards_sort
		     U ___stack_chk_fail
		     U ___stack_chk_guard
		     U _card_compare
		     U _card_new
		     U _cards_sort
		     U _cut_assert_helper
		     U _cut_test_context_current_peek
		     U _cut_test_context_finish_user_message_jump
		     U _cut_test_context_get_have_current_result
		     U _cut_test_context_get_jump_buffer
		     U _cut_test_context_in_user_message_jump
		     U _cut_test_context_long_jump
		     U _cut_test_context_pop_backtrace
		     U _cut_test_context_process_current_result
		     U _cut_test_context_push_backtrace
		     U _cut_test_context_set_jump_buffer
		     U _cut_test_context_start_user_message_jump
		     U _setjmp
    0000000000000000 T _test_cards_sort
#+end_example

    cards_sortが未定義で，test_cards_sort が定義されているのがわかるは
    ずです。
    
** cards_sort，card_compare の実装
   
   さて次は，機能 cards_sort, card_compare の実装です。

   お決まりの手順です:
   
   - test/test_sort.c を作成するときに決めたインタフェースをとりだし，
     src/card.h に移す。
   - src/card.hを遵守し，*src/cards.c* に機能を追加実装する。
   - 提供する機能を入れた src/libcard.a を作成する
     
   src/{card.h，libcard.a} で機能を提供する

*** card/card.h の更新
    
    test/test_card.c から cards_sort等に関するインタフェース宣言を，
    src/card.h に移します。
    
    ここまでで，src/card.h は次のようになります:
    
#+BEGIN_SRC c :tangle babel/simple/cards_sort/src/card.h-cards_sort :noweb yes
<<card.h-cards_sort>>
#+END_SRC

#+BEGIN_SRC sh :dir babel/simple/cards_sort/src :exports none
cp card.h-cards_sort card.h
#+END_SRC

#+RESULTS:

    test/test_sort.c からは削除してください。

    #+BEGIN_SRC c :tangle babel/simple/cards_sort/test/test_sort.1.c :noweb yes :exports none
<<test_sort.c#include>>
<<test_sort.c>>
    #+END_SRC

#+BEGIN_SRC sh :dir babel/simple/cards_sort/test :exports none
cp test_sort.1.c test_card.c
#+END_SRC

#+RESULTS:

*** cards_sort の実装 (src/cards.cの作成)
    
    cards_sort関数の使い方は決まっています。

#+BEGIN_SRC c :noweb yes

<<card.h#cards_sort>>

#+END_SRC

    ことでした。ソートのプログラムを書いた経験をもとにします。

    単純ソートは，選択範囲中で，最も小さいものを見付け範囲の先頭に動か
    すことを，範囲をせばめながら行いことで，ソートを行います。

    実装は次のようになるでしょう:
   
#+BEGIN_SRC c :noweb yes
<<cards.c#cards_sort>>
#+END_SRC

*** card_compare の実装

    card_compare の使い方も決まっています:

#+BEGIN_SRC c :noweb yes

<<card.h#card_compare>>

#+END_SRC

    カードの番号の大小，スーツの大小をから，カードの大小を決めます:
    
#+BEGIN_SRC c :noweb yes
<<cards.c#card_compare>>
#+END_SRC

*** cards.c の確認

#+BEGIN_SRC c :noweb yes :tangle babel/simple/cards_sort/src/cards.c
<<card.c#include>>

<<cards.c#card_compare>>

<<cards.c#cards_sort>>

#+END_SRC

*** src/Makefile

    src/Makefileには，src/cards.o を作成する規則が追加になり，
    libcard.a を作る時，cards.o も取り込むように規則を変更します:

#+BEGIN_SRC c :noweb yes :tangle babel/simple/cards_sort/src/Makefile.cards
<<src/Makefile#cards>>
#+END_SRC

#+BEGIN_SRC sh :dir babel/simple/cards_sort/src :exports none
cp Makefile.cards Makefile
#+END_SRC

#+RESULTS:

*** src/cards.o の作成

    src/cards.o を make し, ソースコードにエラーがないか確かめます:

#+BEGIN_SRC sh :results output :dir babel/simple/cards_sort/src :exports both
# ~/progs/card_display/simple/src
make cards.o
#+END_SRC

#+RESULTS:
: gcc cards.c -g -c -fPIC -I. 

    src/cards.o ができれば文法や宣言の食い違いはなくなったことになりま
    す。

*** src/libcard.a の作成

    src/cards.o ができれば，次は， src/libcard.a を make します。

#+BEGIN_SRC sh :results output :dir babel/simple/cards_sort/src :exports both
# ~/progs/card_display/simple/src
make libcard.a
#+END_SRC

#+RESULTS:
: gcc card.c -g -c -fPIC -I. 
: rm -f libcard.a
: ar r libcard.a card.o cards.o

    Makefile が正しければ，これは成功するはずです。

    libcard.a の中身を確かめてみましょう:

#+BEGIN_SRC sh :results output :dir babel/simple/cards_sort/src :exports both
# ~/progs/card_display/simple/src
nm libcard.a
#+END_SRC

#+RESULTS:
#+begin_example

libcard.a(card.o):
000000000000064b s L_.str
0000000000000650 s L_.str1
0000000000000658 s L_.str2
000000000000065e s L_.str3
0000000000000664 s L_.str4
                 U ___stderrp
                 U _atoi
0000000000000130 T _card_new
0000000000000170 T _card_no
00000000000000c0 T _card_no_new_from_string
0000000000000160 T _card_suit
0000000000000000 T _card_suit_new_from_string
                 U _fprintf
                 U _strcmp

libcard.a(cards.o):
0000000000000000 T _card_compare
                 U _card_no
                 U _card_suit
00000000000000d0 T _cards_sort
#+end_example

    src/libcard.a が更新できたので，次はtest_card.so を更新します。    

** テスト

*** test/test_sort.so のビルド

    test/test_sort.so を作り直します。
    
#+BEGIN_SRC sh :results output :dir babel/simple/no_new/test :exports both
# ~/progs/card_display/simple/test/
make clean
make test_card.so
#+END_SRC

#+RESULTS:

    test/test_card.so ができればテストの実行に移ります。

    できない時は，多分，Makefile に間違いがあります。Makefile を修正してください。

*** テストの実行

    テストの作成と機能の実装が終ったので，機能が要求を満たすことを確か
    めるためにテストする:

#+BEGIN_SRC sh :results output :dir babel/simple/card_new/ :exports both
# ~/progs/card_display/simple
cutter -v v test
#+END_SRC

*** テストと再設計

    テストが成功すれば，テストによる開発の1サイクルが完結したことにな
    ります。

    テストが失敗した場合は，test/test_sort.c, src/{card.h, cards.c} を
    修正していくことになります。

    ソースコードを修正した後は，Makefileに間違いがなけれ
    ば，~/progs/card_display/simpleで make すれば，全自動でテストまで
    実行してくれます。テストが成功するまで繰り返してください。

