# Time-stamp: <2015-11-15 17:30:20 m>

* はじめに

  テスト駆動開発の例として，card_display_simple問題のテスト駆動開発してみる。

  その上で，わずかな変更の card_display_multi 問題と，
  card_display_sort 問題を，テスト駆動開発してみる。

  そして，その開発を通して，カードモジュールが出来上がることを実感する。

* ディレクトリ構成

まず、プログラムを作成するためのディレクトリを用意する。ディレクトリは
simple/ とする。

#+BEGIN_SRC sh :exports none
rm -rf babel/simple
mkdir -p babel/simple/suit_new/src babel/simple/suit_new/test
mkdir -p babel/simple/no_new/src babel/simple/no_new/test
mkdir -p babel/simple/card_new/src babel/simple/card_new/test
mkdir -p babel/simple/card_to_string/src babel/simple/card_to_string/test
#+END_SRC

#+RESULTS:

#+BEGIN_SRC sh 
# ~/
mkdir -p ~/progs/CardDisplay/simple
cd ~/progs/CardDisplay/simple
#+END_SRC

#+RESULTS:

続いて、simple/ ディレクトリ以下に，プログラム用ディレクトリ src/，テストプログラム用
ディレクトリ test/ を作成する。

#+begin_src sh :dir ~/progs/CardDisplay/simple
# ~/progs/CardDisplay/simple
mkdir -p src test
#+end_src

#+RESULTS:

つまり、ディレクトリ構成は以下のようになる。

#+BEGIN_EXAMPLE
    simple/ --+- src/  ソースファイル用ディレクトリ
              |
              +- test/ テストプログラム用ディレクトリ
#+END_EXAMPLE

* Makefileを作る

  simple/ ディレクトリに Makefileを作成します。
  目的は二つ，カードのテストをすることと，ディレクトリ配下をきれいにするこ
  とです。

#+begin_src makefile :tangle babel/simple/suit_new/Makefile
# ~/progs/CardDisplay/simple/Makefile
PHONY: clean card_test

card_test:
	(cd src; make)
	(cd test; make)	
	cutter -v v test/
clean:
	(cd src; make clean)
	(cd test; make clean)
	rm -f *.o *.so *~ \#*
#+end_src

  src/Makefileを作ります。まずの目的は，src/ディレクトリをきれいにすることで
  す:
  
#+BEGIN_SRC makefile :tangle babel/simple/suit_new/src/Makefile
# src/Makefile
.PHONY: clean 
  
clean:
	rm -f *.o *.so *~ \#*
#+END_SRC

  test/Makefileを作ります: 同様にまずの目的は，test/ディレクトリをきれ
  いにすることです:

#+BEGIN_SRC makefile :tangle babel/simple/suit_new/test/Makefile
# test/Makefile
.PHONY: clean 

clean:
	rm -f *.o *.so *~ \#*
#+END_SRC

  では，make してみましょう。
  
#+BEGIN_SRC sh :results output :dir babel/simple/suit_new
make
#+END_SRC

  それぞれのディレクトリで make clean して，空のテストをします:
  
  最初のテストは，成功です。開発とテストに必要なディレクトリ，Makefile を
  作成し，空のテストを行いました。

* 開発を機能に分ける

  さて次は，card_display_simpleを，機能に分け，機能をテストしな
  がら開発します。(file:card-display/)

  下記の機能に分けてみます:

  1. スーツを数値にする機能，
  2. トランプ番号を数値にする機能，
  3. トランプ・カード型を表す機能，
  4. スーツと番号からトランプカードを作成する機能
  5. トランプ・カードを文字列で表す機能。


  これらの機能を組み合わせてcard_display_simpleプログラムが開発できま
  す。

  実は，この機能分けが一番重要かもしれません。最初から全ての機能が取り
  出せなくてもいいと思います。必要そうな機能を一つづつためしてもいいで
  す。自分で丁度いいと思うことが大切です。

* 機能のテスト駆動開発 (概論)

  これらの機能をひとつづつ確かめながら開発を進めるのが，テスト駆動開
  発です。具体的な開発を進める前に，おおまかな流れを説明します。

  進め方は:

  - Makefileの作成 :: テストと実装をビルドし，テストを実行するための
		       Makefile を書く。

		       ./Makefile には src/, test/ でビルドするルールを書き，
		       cutter によりテストを実行する規則を書く。

  - test/Makefileの作成 :: テストをビルドするための規則を書く。

       test/Makefile に test_card.c から test_card.so を作成し，
       cutter によるテストの実行するための規則を書く。

  - 機能テストの作成 :: 機能が正しく働くことを確かめるテスト (プログラム) を書く。このこ
    とにより，*機能の使い方*を決める。

    test/test_card.c に上の5つの機能テストを作成していく。

  - テスト(のみ)のビルド :: ビルドし，コンパイル・エラーが取れ，確かめ
       る機能の関数のみが未定義の状態にする。

  - src/Makefile :: 機能の実装をビルドするための規則を書く。

		    src/Makefile に card.c, card.h から libcard.a を
		    作成する規則を書く。

  - インタフェースの決定 :: 確かめる機能の関数を使うために必要最小限
       のインタフェースを決める。

      test/test_card.c から取り出し，src/card.h に書く。

  - 機能の実装 :: インタフェースに従がい，機能を関数として実装する。

		src/card.c を作成する。

  - 機能の提供 :: 実装をビルドし，ライブラリとヘッダファイルで機能を提
                  供する。

		  src/Makefile にルールを書き，
		  src/libcard.aを作成する。

  - テストのビルドと実行 ::

  では，続く節で，5つの機能のテスト駆動開発をおこないます。

* スーツを数値にする機能のテストと実装

  まず最初は，文字列で表されたスーツを，プログラム内部での数値に変換す
  る機能のテストです。

  あわせてテスト等のビルドのためMakefileを作成していきます。
   
** テスト作成

    テストは，test/test_card.c に作成します。

    機能の名前を card_suit_new_from_string とし,
    card_suit_new_from_string が満たすテストを書きます:
     
#+BEGIN_SRC c 
// test/test_card.c
  cut_assert(card_suit_new_from_string("SPADE")==SPADE);
#+END_SRC

    cut_assert は引数の値が真ならばテスト成功，偽ならばテスト失敗
    とする cutter の機能です。失敗のときは，情報を提供してくれます。

    card_suit_new_from_stringを関数の形で書けたので，関数の型を決めま
    す。

    戻り値の型は int，与える引数はスーツを示す文字列なので:

#+BEGIN_SRC c
  int card_suit_new_from_string(char *);
#+END_SRC

    そして，cutterが提供する機能を使うためのインタフェースをインクルー
    ドします:

#+BEGIN_SRC c
# include <cutter.h>
#+END_SRC

    テストに使う定数は，列挙型 ([[https://ja.wikipedia.org/wiki/%E5%88%97%E6%8C%99%E5%9E%8B][列挙型 - Wikipedia]]) で書いてみます:

#+name: suit_new_e_suit
#+BEGIN_SRC c
  enum e_Suit {CLUB=1, DIAMOND, HEART, SPADE};
#+END_SRC
    まだ列挙型を使かったことがないかもしれませんが，便利なので憶えましょ
    う。これは，define で定義する次のコードと似ています:
#+BEGIN_SRC c
  # define SPADE 4
  # define HEART 3
  # define DIAMOND 2
  # define CLUB 1
#+END_SRC

    次に，テストに必要なことを記述します:

    - テスト・フレームワークとして cutter を使うので，必要な宣言をインク
      ルードする:

#+BEGIN_SRC c
  # include <cutter.h>
#+END_SRC

    - テストを関数にする。cutterからの要請で，関数名は test_ で始まる
      名前で，型は，void (void) です:

#+BEGIN_SRC c
  void
  test_card_suit_new_from_string(void)
  {
    cut_assert_true(card_suit_new_from_string("SPADE")==SPADE);
  }
#+END_SRC

    これだけです。

    ここまでで，test/test_card.c の中身は:

#+BEGIN_SRC c :tangle babel/simple/suit_new/test/test_card.c
// test/test_card.c
# include <cutter.h>

enum e_Suit {CLUB=1, DIAMOND, HEART, SPADE};

enum e_Suit card_suit_new_from_string(char *);

void
test_card_suit_new_from_string(void)
{
  cut_set_message("文字列からスーツを作成する。");
  cut_assert_true(card_suit_new_from_string("SPADE")==SPADE);
}
#+END_SRC

** test/Makefileの作成

   test/Makefile は，とりあえず，test_card.c をコンパイルするこ
   とです:

   Makefileに次のように規則を書き加えます:

#+BEGIN_SRC makefile  :tangle babel/simple/suit_new/test/Makefile
# test/Makefile (2)
test_card.o: test_card.c
	gcc -c $^
#+END_SRC

    test_card.c がインクルードしている cutter.h がどこにあるのかは，次
    のコマンドを実行するとわかります:

#+BEGIN_SRC sh :results output code 
# ~/progs/CardDisplay/simple/
pkg-config cutter --cflags
#+END_SRC

#+RESULTS:
#+BEGIN_SRC sh
-I/opt/local/include/cutter 
#+END_SRC
    cutter.hをインクルードするためのコンパイラへの指示が出力されていま
    す。

    これをMakefileに記述します:

#+BEGIN_SRC makefile :tangle babel/simple/suit_new/test/Makefile
# test/Makefile (3) replace
.PHONY: clean 
CFLAGS = `pkg-config cutter --cflags`

test_card.o: test_card.c
	gcc -c $^ $(CFLAGS)

clean:
	rm -f *.o *.so *~ \#*
#+END_SRC

** 最初の make

   test/{test_card.c, Makefile}ができたので，make してみましょう:

#+BEGIN_SRC sh :results output :dir babel/simple/suit_new/
# ~/progs/CardDisplay/simple
make
#+END_SRC

   コンパイルは成功しました。test/test_card.o の中身を見てみましょう:

#+BEGIN_SRC sh :results output :dir babel/simple/suit_new/
nm test/test_card.o
#+END_SRC

#+RESULTS:

   card_suit_from_string, cut_assert が未定義で，
   test_card_suit_new_from_string が定義されているのがわかります。

** cutterによるテスト

   cutter でテストしてみましょう:

#+BEGIN_SRC sh :results output :dir babel/simple/suit_new/
cutter -v v test
#+END_SRC

#+RESULTS:
: 
: Finished in 0.000040 seconds (total: 0.000000 seconds)
: 
: 0 test(s), 0 assertion(s), 0 failure(s), 0 error(s), 0 pending(s), 0 omission(s), 0 notification(s)
: 0% passed

    test(s)が0と表示されているので， test_card.oはテストとして認識され
    ていないことが分かります。

** テストのビルド

    cutter は，test_ で始まる動的ライプラリをテストと認めます。なので動的ライ
    ブラリを作ります。そのために test/Makefileに規則を追加します:

#+BEGIN_SRC makefile
CFLAGS = -fPIC `pkg-config cutter --cflags` 
LDFLAGS = `pkg-config --libs cutter`

test_card.so: test_card.o
	gcc -o $@ --shared $^ $(LDFLAGS)
#+END_SRC

    gcc に対するオプション -fPIC とか --shared は動的ライブラリを作る
    ためのものです。
    
    ここまでで test/Makefile 全体は下記のようになります:
    
#+BEGIN_SRC makefile :tangle babel/simple/suit_new/test/Makefile
# test/Makefile (3) replace
.PHONY: clean
CFLAGS = -fPIC `pkg-config cutter --cflags` 
LDFLAGS = `pkg-config --libs cutter`

test_card.so: test_card.o	
gcc -o $@ --shared $^ $(LDFLAGS)

test_card.o: test_card.c
	gcc -c $^ $(CFLAGS)

clean:
	rm -f *.o *.so *~ \#*
#+END_SRC

    .soは動的ライブラリを示す拡張子で，gccへのオプション --shared が動
    的ライブラリの作成を意味しています。

    変数LDFLAGSに，ローダへの指示を格納します。pkg-configは，システム
    に組み込まれたパッケージの設定を見るためのコマンドで，--libs は，
    ライプラリとして使う場合のローダへの指示を出力してくれます:

#+BEGIN_SRC sh :results output
pkg-config --libs cutter
#+END_SRC

#+RESULTS:
: -lcutter 

    ``で括ることで Makefil 中で，コマンドの実行結果を表わし，
    変数LDFLAGSには，cutterライブラリをリンクするため指示
    を格納することができます。

    では，makeしてテストをビルドしてみましょう:

#+BEGIN_SRC sh :results output :dir babel/simple/suit_new/
(cd test; make test_card.so)
#+END_SRC

#+RESULTS:

    このmakeも失敗しますが，前進しています。
    cutterが提供する関数への参照は全て解決され，
    まだ未実装の card_suit_new_from_string のみ未解決となっていること
    を理解してください。

** card_suit_new_from_string の実装

   さて次は，機能 card_suit_new_from_string の実装です。
   以下のように実装しましょう:
   - test/test_card.c を作成するときに決めたインタフェースをとりだし，
     src/card.hを作成する。
   - test/test_card.c の対応部分は # include <card.h> とする。
     - test/Makefile も変更する
   - src/card.hを遵守し，src/card.c を作成する。
   - 提供する機能を入れた src/libcard.a を作成する，Makefileを作成す
     る

   *src/{card.h，libcard.a} で機能を提供します*


*** src/card.h の作成 =card/card.h=

    test/test_card.c から card_suit_new_from_string に関する宣言を取り出し， 
    src/card.h にします。

#+BEGIN_SRC c :tangle babel/simple/suit_new/src/card.h
// src/card.h (1)
enum e_Suit {CLUB=1,DIAMOND,HEART,SPADE};

enum e_Suit card_suit_new_from_string(char *);
#+END_SRC

*** test/test_card.cの変更

    インタフェースの定義を，src/card.h に移し，定義の責任を src/ に移
    します。test/ は，責任者の定義に従がうという意味で，ヘッダファイル
    をインクルードします:

#+BEGIN_SRC c
// test/test_card.c
# include <card.h>

#+END_SRC    

    <card.h> は， コンパイラのインクルード・パス上の card.h という名前
    のファイルを意味します。今 test/test_card.c にとって，<card.h> は
    ../src/card.h を意味します。ですが，次のように書いてはいけません:

#+BEGIN_SRC c
# include "../src/card.h"

#+END_SRC    

    test/test_card.c は，下記のようになります:

#+BEGIN_SRC c :tangleg babel/simple/suit_new/test/test_card.c
// test/test_card.c (2) replace
# include <cutter.h>
# include <card.h>

void
test_card_suit_new_from_string(void)
{
  cut_assert(card_suit_new_from_string("SPADE")==SPADE);
  cut_assert(card_suit_new_from_string("HEART")==HEART);
  cut_assert(card_suit_new_from_string("DIAMOND")==DIAMOND);
  cut_assert(card_suit_new_from_string("CLUB")==CLUB);
}
#+END_SRC

*** test/Makefileの変更

    src/card.hがインクルードできるようにインクルードパスをコンパイラに
    指示します。具体的には，CFLAGSを以下のように書き換えます:

#+BEGIN_SRC make
CFLAGS = -I../src `pkg-config cutter --cflags`
#+END_SRC    

    変更後，makeして，以前と同じ状態であることを確かめておきましょう。

*** src/card.c の作成

#+BEGIN_SRC c :tangle babel/simple/suit_new/src/card.c
// src/card.c (1) new
# include <string.h>
# include <card.h>

enum e_Suit
card_suit_new_from_string(char *suit_str)
{
  if (strcmp("club",suit_str)==0)
    return CLUB;
  if (strcmp("diamond",suit_str)==0)
    return CLUB;
  if (strcmp("heart",suit_str)==0)
    return CLUB;
  if (strcmp("spade",suit_str)==0)
    return SPADE;
  return 0;
}
#+END_SRC

*** src/Makefile

    src/card.c をコンパイルし，src/libcard.a を作成する規則を追加しま
    しょう:

#+BEGIN_SRC makefile :tangle babel/simple/suit_new/src/Makefile
# src/Makefile (2) replace
.PHONY: clean
CFLAGS = -g -c -fPIC -I. 
LDFLAGS = -lc

libcard.a: card.o
	rm -f $@
	ar r $@ $^

card.o: card.c card.h
	gcc $^ $(CFLAGS)

clean: 
	rm -f *.o *.so *~ 
#+END_SRC

  ビルドしてみましょう:

#+BEGIN_SRC sh :results output :dir babel/simple/suit_new/src
# =~/progs/CardDisplay/simple/src=
# ~/progs/card_display/simple/src
make clean; make libcard.a
#+END_SRC

#+RESULTS:
: rm -f *.o *.so *~ 
: gcc card.c card.h -g -c -fPIC -I. 
: rm -f libcard.a
: ar r libcard.a card.o

    これは，成功します。libcard.a の中身を確かめてみましょう:

#+BEGIN_SRC sh :results output :dir babel/simple/suit_new/src
# ~/progs/CardDisplay/simple/src
nm libcard.a
#+END_SRC

#+RESULTS:
: 
: card.o:
:                  U _GLOBAL_OFFSET_TABLE_
: 0000000000000000 T card_suit_new_from_string
:                  U strcmp

*** テスト test/test_card.so のビルド

    src/libcard.a ができたので，次はtest/test_card.so に libcard.a を取り
    込むようにmakeの規則を書き換えます:

#+BEGIN_SRC makefile
LDFLAGS = -L../src/ -lcard `pkg-config cutter --libs`
#+END_SRC

    test/Makefileは下記のようになります:

#+BEGIN_SRC makefile :tangle babel/simple/suit_new/test/Makefile
# test/Makefile (3) replace
.PHONY: clean
CFLAGS = -fPIC -I../src `pkg-config cutter --cflags`
LDFLAGS = -L../src/ -lcard `pkg-config cutter --libs`

test_card.so: test_card.o
	gcc -o $@ --shared $^ $(LDFLAGS)

test_card.o: test_card.c
	gcc -c $^ $(CFLAGS)

clean:
	rm -f *.o *.so *~ \#* 

#+END_SRC

#+RESULTS:

#+BEGIN_SRC sh :results output :dir babel/simple/suit_new/test
# ~/progs/card_display/simple/test/
make clean; make test_card.so
#+END_SRC

#+RESULTS:
: rm -f *.o *.so *~ \#* 
: gcc -c test_card.c -fPIC -I../src `pkg-config cutter --cflags`
: gcc -o test_card.so --shared test_card.o -L../src/ -lcard `pkg-config cutter --libs`

** テスト
   テストと実装が終わり，テストをビルドするためのMakefileは完成している。

   これからは，機能が要求を満たすことを確かめるためにテストし，テスト
   が失敗した場合は，test/test_card.c, src/{card.h, card.c} を修正
   していくことになる。

#+BEGIN_SRC sh :results output :dir babel/simple/suit_new/
# ~/progs/card_display/simple
make
#+END_SRC

#+RESULTS:

** テストと再設計

   - 要求が間違っている場合
     - src/card.h の変更，それに伴ない
       - test/test_card.c, src/card.c の変更
     
   - 設計が間違っている場合
     - src/card.h の変更，それに伴ない
       - test/test_card.c, src/card.c の変更

   - 実装が間違っている場合 
     - src/card.c のみの変更

* トランプ番号を数値に

#+BEGIN_SRC sh :exports none 
mkdir -p babel/no_new/src babel/no_new/test
cp -Rp babel/suit_new/src/card.h babel/no_new/src/card.h
cp -Rp babel/suit_new/src/card.c babel/no_new/src/card.c
cp -Rp babel/suit_new/src/Makefile babel/no_new/src/Makefile
cp -Rp babel/suit_new/test/test_card.c babel/no_new/test/test_card.c
cp -Rp babel/suit_new/test/Makefile babel/no_new/test/Makefile
#+END_SRC

#+RESULTS:

  次は，文字列で表された番号を，プログラム内部での数値に変換す
  る機能のテストです。
   
** 機能とテストの追加

    番号のテストは，test/test_card.c に追加作成することにします。

    機能の名前を card_no_new_from_string とし,
    card_no_new_from_string を呼び出してみます：

#+BEGIN_SRC c
// test/test_card.c

  card_no_new_from_string("13")==KING;

#+END_SRC

    よさそうです。card_no_new_from_stringを関数の形で書けたので，テス
    トを書きます:

#+BEGIN_SRC c 
// test/test_card.c

  cut_set_message("番号から数値への変換のテスト");
  cut_assert(card_no_new_from_string("1")==ACE);
  cut_assert(card_no_new_from_string("13")==KING);
  cut_assert(card_no_new_from_string("12")==QUEEN);
  cut_assert(card_no_new_from_string("11")==JACK);
  cut_assert(card_no_new_from_string("10")==10);

#+END_SRC

    card_no_new_from_string 関数の型を決めます。

    戻り値の型は enum e_No，与える引数は番号を示す文字列なので:

#+BEGIN_SRC c
// test/test_card.c

  enum e_No card_no_new_from_string(char *);

#+END_SRC

    テストに使う定数は，列挙型で書いてみます:

#+BEGIN_SRC c
// test/test_card.c

  enum e_No {JACK=11, QUEEN, KING, ACE};

#+END_SRC

    テストを関数にします。

#+BEGIN_SRC c
// test/test_card.c

void
test_card_suit_no_from_string(void)
{
  cut_assert(card_no_new_from_string("1")==ACE);
  cut_assert(card_no_new_from_string("13")==KING);
  cut_assert(card_no_new_from_string("12")==QUEEN);
  cut_assert(card_no_new_from_string("11")==JACK);
  cut_assert(card_no_new_from_string("10")==10);
}
#+END_SRC

    ここまでで，test/test_card.c の中身は:

#+BEGIN_SRC c :tangle babel/simple/no_new/test/test_card.c.0
// test/test_card.c
# include <cutter.h>
# incldue <card.h>

enum e_Suit card_suit_new_from_string(char *);

enum e_No {JACK=11, QUEEN, KING, ACE};
enum e_No card_no_new_from_string(char *);

void
test_card_suit_new_from_string(void)
{
  cut_set_message("スーツから数値への変換のテスト");
  cut_assert_true(card_suit_new_from_string("SPADE")==SPADE);
}

void
test_card_no_new_from_string(void)
{
  cut_set_message("番号から数値への変換のテスト");
  cut_assert(card_no_new_from_string("1")==ACE);
  cut_assert(card_no_new_from_string("13")==KING);
  cut_assert(card_no_new_from_string("12")==QUEEN);
  cut_assert(card_no_new_from_string("11")==JACK);
  cut_assert(card_no_new_from_string("10")==10);
}
#+END_SRC

#+BEGIN_SRC sh :dir babel/simple/no_new/ :exports none
# 先生だけのコード
(cp test/test_card.c.0 test/test_card.c)
#+END_SRC

#+RESULTS:

** test/Makefileの更新

   test/Makefile の目的は変わっていませんので，更新の必要はありません。

** make

   してみましょう:

#+BEGIN_SRC sh :results output :dir babel/simple/suit_new/
# ~/progs/CardDisplay/simple
make
#+END_SRC

   test_card.so ができれば成功です。

   test/test_card.o の中身を見てみましょう:

#+BEGIN_SRC sh :results output :dir babel/simple/suit_new/
nm test/test_card.o
#+END_SRC

   card_no_from_stringが未定義で，
   test_card_no_new_from_string が定義されているのがわかります。
   
** テストのビルド

   ここまで，自動的にできているはずです。

#+BEGIN_SRC sh :results output :dir babel/simple/suit_new/
(cd test; make test_card.so)
#+END_SRC

** card_no_new_from_string の実装

   さて次は，機能 card_suit_new_from_string の実装です。
   以下のように実装しましょう:

   - test/test_card.c を作成するときに決めたインタフェースをとりだし，
     src/card.hに追加する。
  
   - test/test_card.c の対応部分は # include <card.h> に含まれることに
     なる。
  
   - src/card.hを遵守し，src/card.c に機能(関数)を追加する。

   - 提供する機能を入れた src/libcard.a を作成する，Makefileを作成す
     る

   *src/{card.h，libcard.a} で機能を提供します*

*** src/card.h の更新

#+BEGIN_SRC c :tangle babel/simple/no_new/src/card.h.0
// src/card.h

enum e_Suit {CLUB=1,DIAMOND,HEART,SPADE};
int card_suit_new_from_string(char *);

enum e_No {TWO=2,THREE,FOUR,FIVE,SIX,SEVEN,EIGHT,NINE,TEN,JACK,QUEEN,KING,ACE};
int card_no_new_from_string(char *);
#+END_SRC

*** test/test_card.cの変更

    インタフェースの定義を，src/card.h に移し，定義の責任を src/ に移
    します。

#+BEGIN_SRC c
// test/test_
# include <card.h>

#+END_SRC    

    test/test_card.c は，下記のようになります:
#+BEGIN_SRC c :tangle babel/simple/no_new/test/test_card.c.1
// test/test_card.c.1
# include <cutter.h>
# include <card.h>

void
test_card_suit_new_from_string(void)
{
  cut_assert_true(card_suit_new_from_string("SPADE")==SPADE);
  cut_assert_true(card_suit_new_from_string("HEART")==HEART);
  cut_assert_true(card_suit_new_from_string("DIAMOND")==DIAMOND);
  cut_assert_true(card_suit_new_from_string("CLUB")==CLUB);
}

void
test_card_no_new_from_string(void)
{
  cut_set_message("番号から数値への変換のテスト");
  cut_assert(card_no_new_from_string("1")==ACE);
  cut_assert(card_no_new_from_string("13")==KING);
  cut_assert(card_no_new_from_string("12")==QUEEN);
  cut_assert(card_no_new_from_string("11")==JACK);
  cut_assert(card_no_new_from_string("10")==10);
}

#+END_SRC

#+BEGIN_SRC sh :results output :dir babel/simple/no_new/ :exports none
# 先生だけのコード
(cp test/test_card.c.1 test/test_card.c)
#+END_SRC

#+RESULTS:

*** COMMENT src/card.c の作成

#+BEGIN_SRC c :tangle babel/simple/no_new/src/card.c.0
// src/card.c
# include <string.h>
# include <card.h>

Suit
card_suit_new_from_string(char *suit_str)
{
  if (strcmp("club",suit_str)==0)
    return CLUB;
  if (strcmp("diamond",suit_str)==0)
    return CLUB;
  if (strcmp("heart",suit_str)==0)
    return CLUB;
  if (strcmp("spade",suit_str)==0)
    return SPADE;
  return 0;
}

enum e_No
card_no_new_from_string(char *no_str)
{
  int no = atoi(no_str);

  if (no==1)  no = ACE;

  if ( no < TWO && ACE < no )
    {
      fprintf(stderr, "不適な数値 (%s)!\n", no_str);
    };
  return no;
}

#+END_SRC

#+BEGIN_SRC sh :results output :dir babel/simple/no_new/
# 先生だけのコード
(cp src/card.c.0 src/card.c)
#+END_SRC

#+RESULTS:

*** src/Makefile
    Makefileに変更はありません。ビルドしてみましょう:

#+BEGIN_SRC sh :results output :dir babel/simple/no_new/src
# ~/progs/CardDisplay/simple/src
make clean; make libcard.a
#+END_SRC

    これは，成功します。libcard.a の中身を確かめてみましょう:

#+BEGIN_SRC sh :results output :dir babel/simple/no_new/src
# ~/progs/CardDisplay/simple/src
nm libcard.a
#+END_SRC

*** テスト test/test_card.so のビルド

    src/libcard.a が更新できたので，次は test/test_card.so を更新します。

#+BEGIN_SRC sh :results output :dir babel/simple/suit_new/test
# ~/progs/card_display/simple/test/
make clean; make test_card.so
#+END_SRC

    

** テスト
   テストと実装が終わり，テストをビルドするためのMakefileは完成している。

   これからは，機能が要求を満たすことを確かめるためにテストし，テスト
   が失敗した場合は，test/test_card.c, src/{card.h, card.c} を修正
   していくことになる。

#+BEGIN_SRC sh :results output :dir babel/simple/no_new/
# ~/progs/CardDisplay/simple
make
#+END_SRC

#+RESULTS:

** テストと再設計

   この節でおこなったこと:

   - 新たな機能の要求 card_no_new_from_string があり，
   - test/test_card.c に新らしいテスト関数を作成し，
   - src/card.h に新たな機能のインターフェイス宣言を付け加え，
   - src/card.c にその機能の実装を付け加えた
     
* トランプ・カードを作成
#+BEGIN_SRC sh :dir babel/simple
mkdir card_new
cp -Rp no_new/* card_new/
#+END_SRC
  
** 機能とテストの追加

    番号のテストは，test/test_card.c に追加作成することにします。

    機能の名前を card_new とし,
    card_newが満たすテストを書きます:

#+BEGIN_SRC c
Card sa = card_new(SPADE,ACE);
#+END_SRC
     
    これだけではテストにならないので，スーツと番号を取り出す機能を合わ
    せて，追加します。

#+BEGIN_SRC c
 enum e_Suit card_suit(Card);
 enum e_No card_no(Card);
#+END_SRC

    これにより，テストが書けます:

#+BEGIN_SRC 
Card sa = card_new(SPADE,ACE);
cut_assert( (card_suit(sa)==SPADE) && (card_no(sa)==ACE) );
#+END_SRC

    スペードのACEを作り，つくられたカードのスーツと番号が正しいか，確
    かめています。

#+BEGIN_SRC c :tangle babel/simple/card_new/test/test_card.c

void
test_card_new(void)
{
  cut_set_message("スーツと番号からカードを作成");
  {
    Card sa = card_new(SPADE,ACE);
    cut_assert( (card_suit(sa)==SPADE) && (card_no(sa)==ACE) );
  }
}
#+END_SRC

    card_new を関数の形で書けたので，関数の型を決めます。

    戻り値の型は Card，与える引数はスーツと番号の内部表現なので:

#+name: card_new_decl_func
#+BEGIN_SRC c 
enum e_Suit card_suit(Card);
enum e_No card_no(Card);
int card_new(enum e_Suit, enum e_No);
#+END_SRC

    test/test_card.c に付加える中身は:

#+BEGIN_SRC c 

typedef struct {
  enum e_Suit suit;
  enum e_No no;
} Card;

enum e_Suit card_suit(Card);
enum e_No card_no(Card);
Card card_new(enum e_Suit, enum e_No);

void
test_card_new(void)
{
  cut_set_message("スーツと番号からカードを作成");
  {
    Card sa = card_new(SPADE,ACE);
    cut_assert( (card_suit(sa)==SPADE) && (card_no(sa)==ACE) );
  }
}

#+END_SRC

** test/Makefileの更新

   test/Makefile の目的は変わっていませんので，更新の必要はありません。

** make

   してみましょう:

#+BEGIN_SRC sh :results output :dir babel/simple/card_new/
# ~/progs/CardDisplay/simple
make
#+END_SRC

   コンパイルは成功しました。test/test_card.o の中身を見てみましょう:

#+BEGIN_SRC sh :results output :dir babel/simple/card_new/
nm test/test_card.o
#+END_SRC

   card_newが未定義で，
   test_card_new が定義されているのがわかります。
   
** テストのビルド

   ここまで，自動的にできているはずです。

#+BEGIN_SRC sh :results output :dir babel/simple/suit_new/
(cd test; make test_card.so)
#+END_SRC

** card_new の実装

   さて次は，機能 card_new の実装です。
   手順は，card_no_new_from_string を実装したときと同様です:
   
   - test/test_card.c を作成するときに決めたインタフェースをとりだし，
     src/card.h に移す。
   - src/card.hを遵守し，src/card.c に機能を追加実装する。
   - 提供する機能を入れた src/libcard.a を作成する
   
   src/{card.h，libcard.a} で機能を提供する

*** card/card.h の更新

#+BEGIN_SRC c :tangle babel/simple/card_new/src/card.h
// src/card.h.0
enum e_Suit {CLUB=1,DIAMOND,HEART,SPADE};
e_Suit card_suit_new_from_string(char *);

enum e_No {TWO=2, THREE, FOUR, FIVE, SIX, SEVEN,
	   EIGHT, NINE, TEN, JACK, QUEEN, KING, ACE};

enum e_No card_no_new_from_string(char *);

typedef struct {
  enum e_Suit suit;
  enum e_No no;
} Card;

Card card_new(enum e_Suit, enum e_No);
enum e_Suit card_suit(Card);
enum e_No card_no(Card);

#+END_SRC

*** test/test_card.cの変更

    test/test_card.c は，下記のようになります:

#+BEGIN_SRC c :tangle babel/simple/card_new/test/test_card.c.1


#+END_SRC


*** src/card.c の作成

#+BEGIN_SRC c :tangle babel/simple/suit_new/src/card.c.0
// src/card.c.0

Card
card_new(enum e_Suit suit, enum e_No no)
{
  Card new;

  new.suit = suit;
  new.no = no;
  return no;
}
enum e_Suit
card_suit(Card c)
{
  return c.suit;
}

enum e_No
card_no(Card c)
{
  return c.no;
}
#+END_SRC

*** src/Makefile
    Makefileに変更はありません。ビルドしてみましょう:

#+BEGIN_SRC sh :results output :dir babel/simple/card_new/src
# ~/progs/CardDisplay/simple/src
make clean; make libcard.a
#+END_SRC

    これは，成功します。libcard.a の中身を確かめてみましょう:

#+BEGIN_SRC sh :results output :dir babel/simple/card_new/src
# ~/progs/CardDisplay/simple/src
nm libcard.a
#+END_SRC

*** テスト test/test_card.so のビルド

    src/libcard.a が更新できたので，次はtest_card.so を更新します。

#+BEGIN_SRC sh :results output :dir babel/simple/no_new/test
# ~/progs/CardDisplay/simple/test/
make clean; make test_card.so
#+END_SRC


** テスト
   テストの作成と実装が終わり，テストをビルドするためのMakefileは完成している。

   これからは，機能が要求を満たすことを確かめるためにテストし，テスト
   が失敗した場合は，test/test_card.c, src/{card.h, card.c} を修正
   していくことになる。

#+BEGIN_SRC sh :results output :dir babel/simple/no_new/
# ~/progs/CardDisplay/simple
make
#+END_SRC

#+RESULTS:

** テストと再設計

* トランプ・カードを文字列に

  自分でやってみましょう。


* card_display_simple 問題の解の作成
  
  - ~/progs/CardDisplay/simple/ に，

  - 作成した src/libcard.a を利用し，

  - card_display_simple.c を作成し，

  - Makefile を書き換えて, card_display_simple をビルドできるように，
    してください。


* card_display_multi

  Card cards[5]; を使ってみる。

* card_display_sort 

  typedef Card *[] Cards; を機能として組み込む


  
    

    



  
