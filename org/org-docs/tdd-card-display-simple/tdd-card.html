<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<title>tdd-card</title>
<!-- 2015-12-01 火 11:29 -->
<meta  http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta  name="generator" content="Org-mode" />
<meta  name="author" content="m" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center; }
  .todo   { font-family: monospace; color: red; }
  .done   { color: green; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  pre.src-sh:before    { content: 'sh'; }
  pre.src-bash:before  { content: 'sh'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-R:before     { content: 'R'; }
  pre.src-perl:before  { content: 'Perl'; }
  pre.src-java:before  { content: 'Java'; }
  pre.src-sql:before   { content: 'SQL'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.right  { text-align: center;  }
  th.left   { text-align: center;   }
  th.center { text-align: center; }
  td.right  { text-align: right;  }
  td.left   { text-align: left;   }
  td.center { text-align: center; }
  dt { font-weight: bold; }
  .footpara:nth-child(2) { display: inline; }
  .footpara { display: block; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  /*]]>*/-->
</style>
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2013 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="content">
<h1 class="title">tdd-card</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">1. はじめに</a></li>
<li><a href="#sec-2">2. ディレクトリ構成</a></li>
<li><a href="#sec-3">3. Makefileを作る</a></li>
<li><a href="#sec-4">4. 開発を機能に分ける</a></li>
<li><a href="#sec-5">5. 機能のテスト駆動開発 (概論)</a></li>
<li><a href="#sec-6">6. スーツを数値にする機能のテストと実装</a>
<ul>
<li><a href="#sec-6-1">6.1. テスト作成</a></li>
<li><a href="#sec-6-2">6.2. test/Makefileの作成</a></li>
<li><a href="#sec-6-3">6.3. 最初の make</a></li>
<li><a href="#sec-6-4">6.4. cutterによるテスト</a></li>
<li><a href="#sec-6-5">6.5. テストのビルド</a></li>
<li><a href="#sec-6-6">6.6. card<sub>suit</sub><sub>new</sub><sub>from</sub><sub>string</sub> の実装</a>
<ul>
<li><a href="#sec-6-6-1">6.6.1. src/card.h の作成 <code>card/card.h</code></a></li>
<li><a href="#sec-6-6-2">6.6.2. test/test<sub>card</sub>.cの変更</a></li>
<li><a href="#sec-6-6-3">6.6.3. test/Makefileの変更</a></li>
<li><a href="#sec-6-6-4">6.6.4. src/card.c の作成</a></li>
<li><a href="#sec-6-6-5">6.6.5. src/Makefile</a></li>
<li><a href="#sec-6-6-6">6.6.6. テスト test/test<sub>card</sub>.so のビルド</a></li>
</ul>
</li>
<li><a href="#sec-6-7">6.7. テスト</a></li>
<li><a href="#sec-6-8">6.8. テストと再設計</a></li>
</ul>
</li>
<li><a href="#sec-7">7. トランプ番号を数値に</a>
<ul>
<li><a href="#sec-7-1">7.1. トランプ番号を数値に</a>
<ul>
<li><a href="#sec-7-1-1">7.1.1. 機能とテストの追加</a></li>
<li><a href="#sec-7-1-2">7.1.2. card<sub>no</sub><sub>new</sub><sub>from</sub><sub>string</sub> の実装</a></li>
<li><a href="#sec-7-1-3">7.1.3. テスト</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#sec-8">8. トランプ・カードを作成</a>
<ul>
<li><a href="#sec-8-1">8.1. トランプ・カードを作成</a>
<ul>
<li><a href="#sec-8-1-1">8.1.1. 機能の追加とテストの作成</a></li>
<li><a href="#sec-8-1-2">8.1.2. card<sub>new</sub> の実装</a></li>
<li><a href="#sec-8-1-3">8.1.3. テスト</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#sec-9">9. トランプ・カードを文字列に</a>
<ul>
<li><a href="#sec-9-1">9.1. 設計</a>
<ul>
<li><a href="#sec-9-1-1">9.1.1. 機能の名前と構造</a></li>
<li><a href="#sec-9-1-2">9.1.2. 関数の引数と戻り値の型 (APIの設計)</a></li>
</ul>
</li>
<li><a href="#sec-9-2">9.2. テストによる開発</a></li>
</ul>
</li>
<li><a href="#sec-10">10. card<sub>display</sub><sub>simple</sub> 問題の解の作成</a></li>
<li><a href="#sec-11">11. card<sub>display</sub><sub>multi</sub></a></li>
<li><a href="#sec-12">12. card<sub>display</sub><sub>sort</sub></a></li>
</ul>
</div>
</div>

<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1"><span class="section-number-2">1</span> はじめに</h2>
<div class="outline-text-2" id="text-1">
<p>
テスト駆動開発の例として，card<sub>display</sub><sub>simple問題を</sub>
テスト駆動開発してましょう。
</p>

<p>
その上で，わずかな変更を加えることで，card<sub>display</sub><sub>multi</sub> 問題と，
card<sub>display</sub><sub>sort</sub> 問題を，テスト駆動開発してましょう。
</p>

<p>
そして，その開発を通して，カードモジュールが出来上がることを実感して
みましょう。
</p>
</div>
</div>

<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2"><span class="section-number-2">2</span> ディレクトリ構成</h2>
<div class="outline-text-2" id="text-2">
<p>
まず、プログラムを作成するためのディレクトリを用意する。ディレクトリは
simple/ とする。
</p>

<div class="org-src-container">

<pre class="src src-sh"># ~/
mkdir -p ~/progs/card_display/simple
cd ~/progs/card_display/simple
pwd
</pre>
</div>

<p>
続いて、simple/ ディレクトリ以下に，プログラム用ディレクトリ src/，テストプログラム用
ディレクトリ test/ を作成する。
</p>

<div class="org-src-container">

<pre class="src src-sh"># ~/progs/card_display/simple
mkdir -p src test
</pre>
</div>

<p>
つまり、ディレクトリ構成は以下のようになる。
</p>

<pre class="example">
simple/ --+- src/  ソースファイル用ディレクトリ
          |
          +- test/ テストプログラム用ディレクトリ
</pre>
</div>
</div>

<div id="outline-container-sec-3" class="outline-2">
<h2 id="sec-3"><span class="section-number-2">3</span> Makefileを作る</h2>
<div class="outline-text-2" id="text-3">
<p>
simple/ ディレクトリに Makefileを作成します。
目的は二つ，カードのテストをすることと，ディレクトリ配下をきれいにするこ
とです。
</p>

<div class="org-src-container">

<pre class="src src-makefile"># ~/progs/card_display/simple/Makefile
.PHONY: clean card_test

card_test:
	(cd src; make)
	(cd test; make) 
	cutter -v v test/

clean:
	(cd src; make clean)
	(cd test; make clean)
	rm -f *.o *.so *~ \#* .gch
</pre>
</div>

<p>
src/Makefileを作ります。まずの目的は，src/ディレクトリをきれいにすることで
す:
</p>

<div class="org-src-container">

<pre class="src src-makefile"># src/Makefile
.PHONY: clean 

clean:
	rm -f *.o *.so *~ \#* *.gch
</pre>
</div>

<p>
test/Makefileを作ります: 同様にまずの目的は，test/ディレクトリをきれ
いにすることです:
</p>

<div class="org-src-container">

<pre class="src src-makefile"># test/Makefile
.PHONY: clean 

clean:
	rm -f *.o *.so *~ \#* *.gch
</pre>
</div>

<p>
では，Makefile が正しく書けているか確かめるために make してみましょう。
</p>

<div class="org-src-container">

<pre class="src src-sh"># ~/progs/card_display/simple/
make
</pre>
</div>

<p>
それぞれのディレクトリで make clean して，空のテストをします:
</p>

<p>
最初のテストは，成功です。開発とテストに必要なディレクトリ，Makefile を
作成し，空のテストを行いました。
</p>
</div>
</div>

<div id="outline-container-sec-4" class="outline-2">
<h2 id="sec-4"><span class="section-number-2">4</span> 開発を機能に分ける</h2>
<div class="outline-text-2" id="text-4">
<p>
さて次は，card<sub>display</sub><sub>simpleを，機能に分け，機能をテストしな</sub>
がら開発します。(<a href="card-display/">card-display/</a>)
</p>

<p>
下記の機能に分けてみます:
</p>

<ol class="org-ol">
<li>スーツを数値にする機能，
</li>
<li>トランプ番号を数値にする機能，
</li>
<li>トランプ・カード型を表す機能，
</li>
<li>スーツと番号からトランプカードを作成する機能
</li>
<li>トランプ・カードを文字列で表す機能。
</li>
</ol>


<p>
これらの機能を組み合わせてcard<sub>display</sub><sub>simpleプログラムが開発できま</sub>
す。
</p>

<p>
実は，この機能分けが一番重要かもしれません。最初から全ての機能が取り
出せなくてもいいと思います。必要そうな機能を一つづつためしてもいいで
す。自分で丁度いいと思うことが大切です。
</p>
</div>
</div>

<div id="outline-container-sec-5" class="outline-2">
<h2 id="sec-5"><span class="section-number-2">5</span> 機能のテスト駆動開発 (概論)</h2>
<div class="outline-text-2" id="text-5">
<p>
これらの機能をひとつづつ確かめながら開発を進めるのが，テスト駆動開
発です。具体的な開発を進める前に，おおまかな流れを説明します。
</p>

<p>
進め方は:
</p>

<dl class="org-dl">
<dt> Makefileの作成 </dt><dd>テストと実装をビルドし，テストを実行するための
Makefile を書く。

<p>
./Makefile には src/, test/ でビルドするルールを書き，
cutter によりテストを実行する規則を書く。
</p>
</dd>

<dt> test/Makefileの作成 </dt><dd>テストをビルドするための規則を書く。

<p>
test/Makefile に test<sub>card</sub>.c から test<sub>card</sub>.so を作成し，
cutter によるテストの実行するための規則を書く。
</p>
</dd>

<dt> 機能テストの作成 </dt><dd>機能が正しく働くことを確かめるテスト (プログラム) を書く。このこ
とにより，*機能の使い方*を決める。

<p>
test/test<sub>card</sub>.c に上の5つの機能テストを作成していく。
</p>
</dd>

<dt> テスト(のみ)のビルド </dt><dd>ビルドし，コンパイル・エラーが取れ，確かめ
る機能の関数のみが未定義の状態にする。
</dd>

<dt> src/Makefile </dt><dd>機能の実装をビルドするための規則を書く。

<p>
src/Makefile に card.c, card.h から libcard.a を
作成する規則を書く。
</p>
</dd>

<dt> インタフェースの決定 </dt><dd>確かめる機能の関数を使うために必要最小限
のインタフェースを決める。

<p>
test/test<sub>card</sub>.c から取り出し，src/card.h に書く。
</p>
</dd>

<dt> 機能の実装 </dt><dd>インタフェースに従がい，機能を関数として実装する。

<p>
src/card.c を作成する。
</p>
</dd>

<dt> 機能の提供 </dt><dd>実装をビルドし，ライブラリとヘッダファイルで機能を提
供する。

<p>
src/Makefile にルールを書き，
src/libcard.aを作成する。
</p>
</dd>

<dt> テストのビルドと実行 </dt><dd></dd>
</dl>

<p>
では，続く節で，5つの機能のテスト駆動開発をおこないます。
</p>
</div>
</div>

<div id="outline-container-sec-6" class="outline-2">
<h2 id="sec-6"><span class="section-number-2">6</span> スーツを数値にする機能のテストと実装</h2>
<div class="outline-text-2" id="text-6">
<p>
まず最初は，文字列で表されたスーツを，プログラム内部での数値に変換す
る機能のテストです。
</p>

<p>
あわせてテスト等のビルドのためMakefileを作成していきます。
</p>
</div>

<div id="outline-container-sec-6-1" class="outline-3">
<h3 id="sec-6-1"><span class="section-number-3">6.1</span> テスト作成</h3>
<div class="outline-text-3" id="text-6-1">
<p>
テストは，test/test<sub>card</sub>.c に作成します。
</p>

<p>
機能の名前を card<sub>suit</sub><sub>new</sub><sub>from</sub><sub>string</sub> とし,
card<sub>suit</sub><sub>new</sub><sub>from</sub><sub>string</sub> のAPIを決めるため，
card<sub>suit</sub><sub>new</sub><sub>from</sub><sub>string</sub> が満たすテストを書きます:
</p>

<div class="org-src-container">

<pre class="src src-c">// test/test_card.c
  cut_assert(card_suit_new_from_string("SPADE")==SPADE);
</pre>
</div>

<p>
cut<sub>assert</sub> は引数の値が真ならばテスト成功，偽ならばテスト失敗
とする cutter の機能です。失敗のときは，情報を提供してくれます。
</p>

<p>
card<sub>suit</sub><sub>new</sub><sub>from</sub><sub>stringを関数の形で書けたので，関数の型を決めま</sub>
す。
</p>

<p>
戻り値の型は int，与える引数はスーツを示す文字列なので:
</p>

<div class="org-src-container">

<pre class="src src-c">int card_suit_new_from_string(char *);
</pre>
</div>

<p>
そして，cutterが提供する機能を使うためのインタフェースをインクルー
ドします:
</p>

<div class="org-src-container">

<pre class="src src-c"># include &lt;cutter.h&gt;
</pre>
</div>

<p>
テストに使う定数は，列挙型 (<a href="https://ja.wikipedia.org/wiki/%E5%88%97%E6%8C%99%E5%9E%8B">列挙型 - Wikipedia</a>) で書いてみます:
</p>

<div class="org-src-container">

<pre class="src src-c" id="suit_new_e_suit">enum e_Suit {CLUB=1, DIAMOND, HEART, SPADE};
</pre>
</div>
<p>
まだ列挙型を使かったことがないかもしれませんが，便利なので憶えましょ
う。これは，define で定義する次のコードと似ています:
</p>
<div class="org-src-container">

<pre class="src src-c"># define SPADE 4
# define HEART 3
# define DIAMOND 2
# define CLUB 1
</pre>
</div>

<p>
次に，テストに必要なことを記述します:
</p>

<ul class="org-ul">
<li>テスト・フレームワークとして cutter を使うので，必要な宣言をインク
ルードする:
</li>
</ul>

<div class="org-src-container">

<pre class="src src-c">// test/test_card.c
# include &lt;cutter.h&gt;
</pre>
</div>

<ul class="org-ul">
<li>テストを関数にする。cutterからの要請で，関数名は test_ で始まる
名前で，型は，void (void) です:
</li>
</ul>

<div class="org-src-container">

<pre class="src src-c">// test/test_card.c
void
test_card_suit_new_from_string(void)
{
  cut_set_message("文字列からスーツを作成する。");
  cut_assert_true(card_suit_new_from_string("SPADE")==SPADE);
}
</pre>
</div>

<p>
これだけです。
</p>

<p>
ここまでで，test/test<sub>card</sub>.c の中身は:
</p>

<div class="org-src-container">

<pre class="src src-c">// test/test_card.c
# include &lt;cutter.h&gt;

enum e_Suit {CLUB=1, DIAMOND, HEART, SPADE};

enum e_Suit card_suit_new_from_string(char *);

void
test_card_suit_new_from_string(void)
{
  cut_set_message("文字列からスーツを作成する。");
  cut_assert_true(card_suit_new_from_string("SPADE")==SPADE);
}
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-6-2" class="outline-3">
<h3 id="sec-6-2"><span class="section-number-3">6.2</span> test/Makefileの作成</h3>
<div class="outline-text-3" id="text-6-2">
<p>
test/Makefile は，とりあえず，test<sub>card</sub>.c をコンパイルするこ
とです:
</p>

<p>
Makefileに次のように規則を書き加えます:
</p>

<div class="org-src-container">

<pre class="src src-makefile"># test/Makefile
test_card.o: test_card.c
	gcc -c $&lt;
</pre>
</div>

<p>
test<sub>card</sub>.c がインクルードしている cutter.h がどこにあるのかは，次
のコマンドを実行するとわかります:
</p>

<div class="org-src-container">

<pre class="src src-sh"># ~/progs/CardDisplay/simple/
pkg-config cutter --cflags
</pre>
</div>

<pre class="example">
-I/usr/include/cutter  
</pre>


<p>
cutter.hをインクルードするためのコンパイラへの指示が出力されていま
す。
</p>

<p>
これをMakefileに記述します:
</p>

<div class="org-src-container">

<pre class="src src-makefile"># test/Makefile
.PHONY: clean 
CFLAGS = -fPIC `pkg-config cutter --cflags`

test_card.o: test_card.c
	gcc -c $&lt; $(CFLAGS)

clean:
	rm -f *.o *.so *~ \#* *.gch
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-6-3" class="outline-3">
<h3 id="sec-6-3"><span class="section-number-3">6.3</span> 最初の make</h3>
<div class="outline-text-3" id="text-6-3">
<p>
test/{test<sub>card</sub>.c, Makefile}ができたので，make してみましょう:
</p>

<div class="org-src-container">

<pre class="src src-sh"># ~/progs/card_display/simple/test
make clean
make test_card.o
</pre>
</div>

<pre class="example">
rm -f *.o *.so *~ \#* *.gch
gcc -c test_card.c -fPIC -I../src `pkg-config cutter --cflags`
</pre>

<p>
コンパイルが成功し，test/test<sub>card</sub>.o ができていれば，
test/test<sub>card</sub>.o の中身を見てみましょう:
</p>

<div class="org-src-container">

<pre class="src src-sh"># ~/progs/card_display/simple/test
nm test_card.o
</pre>
</div>

<pre class="example">
                 U _GLOBAL_OFFSET_TABLE_
0000000000000200 r __PRETTY_FUNCTION__.3239
                 U _setjmp
                 U card_suit_new_from_string
                 U cut_assert_helper
                 U cut_test_context_current_peek
                 U cut_test_context_finish_user_message_jump
                 U cut_test_context_get_have_current_result
                 U cut_test_context_get_jump_buffer
                 U cut_test_context_in_user_message_jump
                 U cut_test_context_long_jump
                 U cut_test_context_pop_backtrace
                 U cut_test_context_process_current_result
                 U cut_test_context_push_backtrace
                 U cut_test_context_set_jump_buffer
                 U cut_test_context_set_user_message
                 U cut_test_context_start_user_message_jump
0000000000000000 T test_card_suit_new_from_string
</pre>

<p>
card<sub>suit</sub><sub>from</sub><sub>string</sub>, cut<sub>assert</sub> が未定義で，
test<sub>card</sub><sub>suit</sub><sub>new</sub><sub>from</sub><sub>string</sub> が定義されているのがわかります。
</p>
</div>
</div>

<div id="outline-container-sec-6-4" class="outline-3">
<h3 id="sec-6-4"><span class="section-number-3">6.4</span> cutterによるテスト</h3>
<div class="outline-text-3" id="text-6-4">
<p>
cutter でテストしてみましょう:
</p>

<div class="org-src-container">

<pre class="src src-sh">cutter -v v test
</pre>
</div>

<pre class="example">
Finished in 0.000062 seconds (total: 0.000000 seconds)

0 test(s), 0 assertion(s), 0 failure(s), 0 error(s), 0 pending(s), 0 omission(s), 0 notification(s)
0% passed
</pre>

<p>
test(s)が0と表示されているので， test<sub>card</sub>.oはテストとして認識され
ていないことが分かります。
</p>
</div>
</div>

<div id="outline-container-sec-6-5" class="outline-3">
<h3 id="sec-6-5"><span class="section-number-3">6.5</span> テストのビルド</h3>
<div class="outline-text-3" id="text-6-5">
<p>
cutter は，test_ で始まる動的ライブラリをテストと認めます。なので動的ライ
ブラリを作ります。そのために test/Makefileに規則を追加します:
</p>

<div class="org-src-container">

<pre class="src src-Makefile"># test/Makefile

CFLAGS = -fPIC `pkg-config cutter --cflags` 
LDFLAGS = `pkg-config --libs cutter`

test_card.so: test_card.o
	gcc -o $@ --shared $^ $(LDFLAGS)
</pre>
</div>

<p>
gcc に対するオプション -fPIC とか &#x2013;shared は動的ライブラリを作る
ためのものです。
</p>

<p>
ここまでで test/Makefile 全体は下記のようになります:
</p>

<div class="org-src-container">

<pre class="src src-makefile"># test/Makefile (2)
.PHONY: clean
CFLAGS = -fPIC `pkg-config cutter --cflags` 
LDFLAGS = `pkg-config --libs cutter`

test_card.so: test_card.o       
	gcc -o $@ --shared $^ $(LDFLAGS)

test_card.o: test_card.c
	gcc -c $&lt; $(CFLAGS)

clean:
	rm -f *.o *.so *~ \#* *.gch
</pre>
</div>

<p>
.soは動的ライブラリを示す拡張子で，gccへのオプション &#x2013;shared が動
的ライブラリの作成を意味しています。
</p>

<p>
変数LDFLAGSに，ローダへの指示を格納します。pkg-configは，システム
に組み込まれたパッケージの設定を見るためのコマンドで，&#x2013;libs は，
ライブラリとして使う場合のローダへの指示を出力してくれます:
</p>

<div class="org-src-container">

<pre class="src src-sh">pkg-config --libs cutter
</pre>
</div>

<p>
シェルコマンド中では，コマンドを``で括ることで，そのコマンドの実行
結果をその場所に埋め込むことを意味します。
</p>

<p>
変数LDFLAGS中の `pkg-config &#x2013;libs cutter`は，gcc コマンド 
中で参照されることで，cutterライブラリをリンクするため指示を埋め込
むことができます。
</p>

<p>
では，makeしてテストをビルドしてみましょう:
</p>

<p>
card<sub>suit</sub><sub>new</sub><sub>from</sub><sub>string関数がまだ実装されていないため，みつから</sub>
ない旨のエラーが出て，test<sub>card</sub>.so を作るための make は失敗します。
が，前進しています。cutterが提供する関数への参照は全て解決され，ま
だ未実装の card<sub>suit</sub><sub>new</sub><sub>from</sub><sub>string</sub> のみ未解決となっていることを
理解してください。
</p>
</div>
</div>

<div id="outline-container-sec-6-6" class="outline-3">
<h3 id="sec-6-6"><span class="section-number-3">6.6</span> card<sub>suit</sub><sub>new</sub><sub>from</sub><sub>string</sub> の実装</h3>
<div class="outline-text-3" id="text-6-6">
<p>
さて次は，機能 card<sub>suit</sub><sub>new</sub><sub>from</sub><sub>string</sub> の実装です。
以下のように実装しましょう:
</p>
<ul class="org-ul">
<li>test/test<sub>card</sub>.c を作成するときに決めたインタフェースをとりだし，
src/card.hを作成する。
</li>
<li>test/test<sub>card</sub>.c の対応部分は # include &lt;card.h&gt; とする。
<ul class="org-ul">
<li>test/Makefile も変更する
</li>
</ul>
</li>
<li>src/card.hを遵守し，src/card.c を作成する。
</li>
<li>提供する機能を入れた src/libcard.a を作成する，Makefileを作成す
る
</li>
</ul>

<p>
<b>src/{card.h，libcard.a} で機能を提供します</b>
</p>
</div>

<div id="outline-container-sec-6-6-1" class="outline-4">
<h4 id="sec-6-6-1"><span class="section-number-4">6.6.1</span> src/card.h の作成 <code>card/card.h</code></h4>
<div class="outline-text-4" id="text-6-6-1">
<p>
test/test<sub>card</sub>.c から card<sub>suit</sub><sub>new</sub><sub>from</sub><sub>string</sub> に関する宣言を取り出し， 
src/card.h にします。
</p>

<div class="org-src-container">

<pre class="src src-c">// src/card.h
enum e_Suit {CLUB=1,DIAMOND,HEART,SPADE};

enum e_Suit card_suit_new_from_string(char *);
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-6-6-2" class="outline-4">
<h4 id="sec-6-6-2"><span class="section-number-4">6.6.2</span> test/test<sub>card</sub>.cの変更</h4>
<div class="outline-text-4" id="text-6-6-2">
<p>
インタフェースの定義を，src/card.h に移し，定義の責任を src/ に移
します。test/ は，責任者の定義に従うという意味で，ヘッダファイル
をインクルードします:
</p>

<div class="org-src-container">

<pre class="src src-c">// test/test_card.c
# include &lt;card.h&gt;
</pre>
</div>

<p>
&lt;card.h&gt; は， コンパイラのインクルード・パス上の card.h という名前
のファイルを意味します。今 test/test<sub>card</sub>.c にとって，&lt;card.h&gt; は
../src/card.h を意味します。ですが，次のように書いてはいけません:
</p>

<div class="org-src-container">

<pre class="src src-c"># include "../src/card.h"
</pre>
</div>

<p>
test/test<sub>card</sub>.c は，下記のようになります:
</p>

<div class="org-src-container">

<pre class="src src-c">// test/test_card.c
# include &lt;cutter.h&gt;
# include &lt;card.h&gt;

void
test_card_suit_new_from_string(void)
{
  cut_set_message("文字列からスーツを作成する。");
  cut_assert(card_suit_new_from_string("SPADE")==SPADE);
  cut_assert(card_suit_new_from_string("HEART")==HEART);
  cut_assert(card_suit_new_from_string("DIAMOND")==DIAMOND);
  cut_assert(card_suit_new_from_string("CLUB")==CLUB);
}
</pre>
</div>

<p>
ここで，説明を簡略化するため，HEART, DIAMOND, CLUB のテストも追加してしま
いましたが，本来はひとつテストが通ってから，増やしていくべきです。
</p>
</div>
</div>

<div id="outline-container-sec-6-6-3" class="outline-4">
<h4 id="sec-6-6-3"><span class="section-number-4">6.6.3</span> test/Makefileの変更</h4>
<div class="outline-text-4" id="text-6-6-3">
<p>
src/card.hがインクルードできるようにインクルードパスをコンパイラに
指示します。具体的には，CFLAGSを以下のように書き換えます:
</p>

<div class="org-src-container">

<pre class="src src-make">CFLAGS = -fPIC -I../src `pkg-config cutter --cflags`
</pre>
</div>

<p>
変更後，makeして，以前と同じ状態であることを確かめておきましょう。
</p>
</div>
</div>

<div id="outline-container-sec-6-6-4" class="outline-4">
<h4 id="sec-6-6-4"><span class="section-number-4">6.6.4</span> src/card.c の作成</h4>
<div class="outline-text-4" id="text-6-6-4">
<p>
src/card.h に書かれている API を守って，card<sub>suit</sub><sub>new</sub><sub>from</sub><sub>string</sub>
関数を実装します。
</p>

<p>
取り敢えず，与えられた文字列 suit<sub>str</sub> と，スーツ文字列を比較して判
定することにします。
</p>

<div class="org-src-container">

<pre class="src src-c">// src/card.c
# include &lt;string.h&gt;
# include &lt;card.h&gt;

enum e_Suit
card_suit_new_from_string(char *suit_str)
{
  if (strcmp("CLUB", suit_str)==0)
    return CLUB;
  if (strcmp("DIAMOND", suit_str)==0)
    return DIAMOND;
  if (strcmp("HEART", suit_str)==0)
    return HEART;
  if (strcmp("SPADE", suit_str)==0)
    return SPADE;
  return 0;
}
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-6-6-5" class="outline-4">
<h4 id="sec-6-6-5"><span class="section-number-4">6.6.5</span> src/Makefile</h4>
<div class="outline-text-4" id="text-6-6-5">
<p>
src/card.c をコンパイルし，src/libcard.a を作成する規則を追加しま
しょう:
</p>

<div class="org-src-container">

<pre class="src src-makefile"># src/Makefile 
.PHONY: clean
CFLAGS = -g -c -fPIC -I. 
LDFLAGS = -lc

libcard.a: card.o
	rm -f $@
	ar r $@ $^

card.o: card.c card.h
	gcc $&lt; $(CFLAGS)

clean: 
	rm -f *.o *.so *~ \#* *.gch
</pre>
</div>

<p>
ビルドしてみましょう:
</p>

<div class="org-src-container">

<pre class="src src-sh"># ~/progs/card_display/simple/src
make clean
make libcard.a
</pre>
</div>

<pre class="example">
rm -f *.o *.so *~ \#* *.gch
gcc card.c -g -c -fPIC -I. 
rm -f libcard.a
ar r libcard.a card.o
</pre>

<p>
src/card.h と src/card.c に文法上のエラーや宣言上の食い違いがなけれ
あば，card.o ができているはずです。
</p>

<p>
card.o ができて，Makefile に間違いがなければ libcard.a もできている
はずです。
</p>

<p>
libcard.a の中身を確かめて，card<sub>suit</sub><sub>new</sub><sub>from</sub><sub>string</sub> 関数が入ってい
るか，確かめてみましょう:
</p>

<div class="org-src-container">

<pre class="src src-sh"># ~/progs/card_display/simple/src
nm libcard.a
</pre>
</div>

<pre class="example">
card.o:
                 U _GLOBAL_OFFSET_TABLE_
0000000000000000 T card_suit_new_from_string
                 U strcmp
</pre>
</div>
</div>

<div id="outline-container-sec-6-6-6" class="outline-4">
<h4 id="sec-6-6-6"><span class="section-number-4">6.6.6</span> テスト test/test<sub>card</sub>.so のビルド</h4>
<div class="outline-text-4" id="text-6-6-6">
<p>
src/libcard.a ができたので，次は test/test<sub>card</sub>.so に libcard.a を取り
込むようにmakeの規則を書き換えます:
</p>

<div class="org-src-container">

<pre class="src src-makefile">LDFLAGS = -L../src/ -lcard `pkg-config cutter --libs`
</pre>
</div>

<p>
test/Makefileは下記のようになります:
</p>

<div class="org-src-container">

<pre class="src src-makefile"># test/Makefile (3) 
.PHONY: clean
CFLAGS = -fPIC -I../src `pkg-config cutter --cflags`
LDFLAGS = -L../src/ -lcard `pkg-config cutter --libs`

test_card.so: test_card.o
	gcc -o $@ --shared $^ $(LDFLAGS)

test_card.o: test_card.c
	gcc -c $&lt; $(CFLAGS)

clean:
	rm -f *.o *.so *~ \#* *.gch
</pre>
</div>

<p>
make し，src/libcard.a を取り込んだ test/test<sub>card</sub>.so を作成します:
</p>

<div class="org-src-container">

<pre class="src src-sh"># ~/progs/card_display/simple/test/
make clean
make test_card.so
</pre>
</div>

<p>
make の結果中の下記ライン出力中に，
</p>
<pre class="example">
gcc -o test_card.so --shared test_card.o -L../src/ -lcard `pkg-config cutter --libs`
</pre>

<p>
-L../src/ -lcard `pkg-config cutter &#x2013;libs`　が含まれていれば，
test/test<sub>card</sub>.so はできあがるはずです。
</p>
</div>
</div>
</div>

<div id="outline-container-sec-6-7" class="outline-3">
<h3 id="sec-6-7"><span class="section-number-3">6.7</span> テスト</h3>
<div class="outline-text-3" id="text-6-7">
<p>
テストと実装が終わり，テストをビルドするためのMakefileは完成してい
ます。テストするために simple/ で make してみましょう:
</p>

<div class="org-src-container">

<pre class="src src-sh"># ~/progs/card_display/simple
make
</pre>
</div>

<pre class="example">
(cd src; make)
make[1]: ディレクトリ `/home/staff/suzuki/COMM/Lects/prog/site/org-docs/tdd-card-display-simple/babel/simple/suit_new/src' に入ります
make[1]: `libcard.a' は更新済みです
make[1]: ディレクトリ `/home/staff/suzuki/COMM/Lects/prog/site/org-docs/tdd-card-display-simple/babel/simple/suit_new/src' から出ます
(cd test; make)	
make[1]: ディレクトリ `/home/staff/suzuki/COMM/Lects/prog/site/org-docs/tdd-card-display-simple/babel/simple/suit_new/test' に入ります
make[1]: `test_card.so' は更新済みです
make[1]: ディレクトリ `/home/staff/suzuki/COMM/Lects/prog/site/org-docs/tdd-card-display-simple/babel/simple/suit_new/test' から出ます
cutter -v v test/
test_card:
  test_card_suit_new_from_string:			.: (0.000066)

Finished in 0.000464 seconds (total: 0.000066 seconds)

1 test(s), 4 assertion(s), 0 failure(s), 0 error(s), 0 pending(s), 0 omission(s), 0 notification(s)
100% passed
</pre>

<p>
これからは，機能が要求を満たすことを確かめるためにテストし，テスト
が失敗した場合は，test/test<sub>card</sub>.c, src/{card.h, card.c} を修正
していくことになります。
</p>
</div>
</div>

<div id="outline-container-sec-6-8" class="outline-3">
<h3 id="sec-6-8"><span class="section-number-3">6.8</span> テストと再設計</h3>
<div class="outline-text-3" id="text-6-8">
<p>
テストが通らなかった時，下記の場合が考えられます：
</p>
<ul class="org-ul">
<li>要求自体が間違っていた
</li>
<li>要求に対する設計が間違っていた
</li>
<li>要求・設計に対する実装が間違っていた
</li>
</ul>

<p>
それぞれどの箇所を見直すか考えてみましょう:
</p>

<ul class="org-ul">
<li>要求が間違っている場合 (テストの作り直し)
<ul class="org-ul">
<li>test/test<sub>card</sub>.c の変更
</li>
<li>src/card.h の変更，それに伴ない
<ul class="org-ul">
<li>test/test<sub>card</sub>.c, src/card.c の変更
</li>
</ul>
</li>
</ul>
</li>

<li>設計が間違っている場合 (インタフェースの見直し)
<ul class="org-ul">
<li>src/card.h の変更，それに伴ない
<ul class="org-ul">
<li>test/test<sub>card</sub>.c, src/card.c の変更
</li>
</ul>
</li>
</ul>
</li>

<li>実装が間違っている場合 (実装のみの見直し)
<ul class="org-ul">
<li>src/card.c のみの変更
</li>
</ul>
</li>
</ul>

<p>
適切に対処しましょう。
</p>
</div>
</div>
</div>

<div id="outline-container-sec-7" class="outline-2">
<h2 id="sec-7"><span class="section-number-2">7</span> トランプ番号を数値に</h2>
<div class="outline-text-2" id="text-7">
</div><div id="outline-container-sec-7-1" class="outline-3">
<h3 id="sec-7-1"><span class="section-number-3">7.1</span> トランプ番号を数値に</h3>
<div class="outline-text-3" id="text-7-1">
<p>
次は，文字列で表された番号を，プログラム内部での数値に変換す
る機能のテストです。
</p>
</div>

<div id="outline-container-sec-7-1-1" class="outline-4">
<h4 id="sec-7-1-1"><span class="section-number-4">7.1.1</span> 機能とテストの追加</h4>
<div class="outline-text-4" id="text-7-1-1">
<p>
番号のテストは，test/test<sub>card</sub>.c に追加作成することにします。
</p>

<p>
機能の名前を card<sub>no</sub><sub>new</sub><sub>from</sub><sub>string</sub> とし,
card<sub>no</sub><sub>new</sub><sub>from</sub><sub>string</sub> を呼び出してみます：
</p>

<div class="org-src-container">

<pre class="src src-c">// test/test_card.c

  card_no_new_from_string("13")==KING;
</pre>
</div>

<p>
よさそうです。card<sub>no</sub><sub>new</sub><sub>from</sub><sub>stringを関数の形で書けたので，テス</sub>
トを書きます:
</p>

<div class="org-src-container">

<pre class="src src-c">// test/test_card.c

  cut_set_message("番号から数値への変換のテスト");
  cut_assert(card_no_new_from_string("1")==ACE);
  cut_assert(card_no_new_from_string("13")==KING);
  cut_assert(card_no_new_from_string("12")==QUEEN);
  cut_assert(card_no_new_from_string("11")==JACK);
  cut_assert(card_no_new_from_string("10")==10);
</pre>
</div>

<p>
card<sub>no</sub><sub>new</sub><sub>from</sub><sub>string</sub> 関数の型を決めます。
</p>

<p>
戻り値の型は enum e<sub>No，与える引数は番号を示す文字列なので</sub>:
</p>

<div class="org-src-container">

<pre class="src src-c">// test/test_card.c

  enum e_No card_no_new_from_string(char *);
</pre>
</div>

<p>
テストに使う定数は，列挙型で書いてみます:
</p>

<div class="org-src-container">

<pre class="src src-c">// test/test_card.c

  enum e_No {JACK=11, QUEEN, KING, ACE};
</pre>
</div>

<p>
テストを関数にします。
</p>

<div class="org-src-container">

<pre class="src src-c">// test/test_card.c

void
test_card_suit_no_from_string(void)
{
  cut_set_message("番号から数値への変換のテスト");
  cut_assert(card_no_new_from_string("1")==ACE);
  cut_assert(card_no_new_from_string("13")==KING);
  cut_assert(card_no_new_from_string("12")==QUEEN);
  cut_assert(card_no_new_from_string("11")==JACK);
  cut_assert(card_no_new_from_string("10")==10);
}
</pre>
</div>

<p>
ここまでで，test/test<sub>card</sub>.c の中身は:
</p>

<div class="org-src-container">

<pre class="src src-c">// test/test_card.c
# include &lt;cutter.h&gt;
# include &lt;card.h&gt;

enum e_No {JACK=11, QUEEN, KING, ACE};
enum e_No card_no_new_from_string(char *);

void
test_card_suit_new_from_string(void)
{
  cut_set_message("スーツから数値への変換のテスト");
  cut_assert_true(card_suit_new_from_string("SPADE")==SPADE);
  cut_assert(card_suit_new_from_string("HEART")==HEART);
  cut_assert(card_suit_new_from_string("DIAMOND")==DIAMOND);
  cut_assert(card_suit_new_from_string("CLUB")==CLUB);
}

void
test_card_no_new_from_string(void)
{
  cut_set_message("番号から数値への変換のテスト");
  cut_assert(card_no_new_from_string("1")==ACE);
  cut_assert(card_no_new_from_string("13")==KING);
  cut_assert(card_no_new_from_string("12")==QUEEN);
  cut_assert(card_no_new_from_string("11")==JACK);
  cut_assert(card_no_new_from_string("10")==10);
}
</pre>
</div>
</div>

<ol class="org-ol"><li><a id="sec-7-1-1-1" name="sec-7-1-1-1"></a>test/Makefileの更新<br  /><div class="outline-text-5" id="text-7-1-1-1">
<p>
test/Makefile の目的は変わっていませんので，更新の必要はありません。
</p>
</div>
</li>

<li><a id="sec-7-1-1-2" name="sec-7-1-1-2"></a>test/test<sub>card</sub>.o の更新<br  /><div class="outline-text-5" id="text-7-1-1-2">
<p>
test/ で makeしてみましょう。
</p>

<p>
まずは，test/test<sub>card</sub>.o の作成です:
</p>

<div class="org-src-container">

<pre class="src src-sh"># ~/progs/card_display/simple/test
make test_card.o
</pre>
</div>

<pre class="example">
gcc -c test_card.c -fPIC -I../src `pkg-config cutter --cflags`
</pre>

<p>
test<sub>card</sub>.o ができれば，ひとまず，成功です。
</p>

<p>
できない時は，test<sub>card</sub>.c に間違いがあるか，Makefile に間違いがあり
ます。エラーメッセージからどちらの間違いなのか特定し，修正しましょ
う。
</p>

<p>
成功したら，test/test<sub>card</sub>.o の中身を見て確認しましょう:
</p>

<div class="org-src-container">

<pre class="src src-sh"># ~/progs/card_display/simple/test
nm test_card.o
</pre>
</div>

<pre class="example">
                 U _GLOBAL_OFFSET_TABLE_
0000000000000200 r __PRETTY_FUNCTION__.3239
                 U _setjmp
                 U card_suit_new_from_string
                 U cut_assert_helper
                 U cut_test_context_current_peek
                 U cut_test_context_finish_user_message_jump
                 U cut_test_context_get_have_current_result
                 U cut_test_context_get_jump_buffer
                 U cut_test_context_in_user_message_jump
                 U cut_test_context_long_jump
                 U cut_test_context_pop_backtrace
                 U cut_test_context_process_current_result
                 U cut_test_context_push_backtrace
                 U cut_test_context_set_jump_buffer
                 U cut_test_context_set_user_message
                 U cut_test_context_start_user_message_jump
0000000000000000 T test_card_suit_new_from_string
</pre>

<p>
card<sub>no</sub><sub>from</sub><sub>stringが未定義で，</sub>
test<sub>card</sub><sub>no</sub><sub>new</sub><sub>from</sub><sub>string</sub> が定義されているのがわかります。
</p>
</div>
</li>

<li><a id="sec-7-1-1-3" name="sec-7-1-1-3"></a>テスト (test/test<sub>card</sub>.so) のビルド<br  /><div class="outline-text-5" id="text-7-1-1-3">
<p>
つづいて，test/test<sub>card</sub>.so を作りましょう:
</p>

<div class="org-src-container">

<pre class="src src-sh"># ~/progs/card_display/simple/test
make test_card.so
</pre>
</div>

<pre class="example">
gcc -o test_card.so --shared test_card.o -L../src/ -lcard `pkg-config cutter --libs`
</pre>
</div>
</li></ol>
</div>


<div id="outline-container-sec-7-1-2" class="outline-4">
<h4 id="sec-7-1-2"><span class="section-number-4">7.1.2</span> card<sub>no</sub><sub>new</sub><sub>from</sub><sub>string</sub> の実装</h4>
<div class="outline-text-4" id="text-7-1-2">
<p>
さて次は，機能 card<sub>no</sub><sub>new</sub><sub>from</sub><sub>string</sub> の実装です。
以下のように実装しましょう:
</p>

<ul class="org-ul">
<li>test/test<sub>card</sub>.c を作成するときに決めたインタフェースをとりだし，
src/card.hに追加する。
</li>

<li>test/test<sub>card</sub>.c の対応部分は # include &lt;card.h&gt; に含まれることに
なる。
</li>

<li>src/card.hを遵守し，src/card.c に機能(関数)を追加する。
</li>

<li>提供する機能を入れた src/libcard.a を作成する，Makefileを作成す
る
</li>
</ul>

<p>
<b>src/{card.h，libcard.a} で機能を提供します</b>
</p>
</div>

<ol class="org-ol"><li><a id="sec-7-1-2-1" name="sec-7-1-2-1"></a>src/card.h の更新<br  /><div class="outline-text-5" id="text-7-1-2-1">
<p>
test/test<sub>card</sub>.c で宣言した card<sub>no</sub><sub>new</sub><sub>from</sub><sub>string</sub> に関する
インタフェースの定義を，src/card.h に移し，定義の責任を src/ に移
します。
</p>

<p>
enum e<sub>No</sub> の値も TWO~ACEまでにします.
</p>

<div class="org-src-container">

<pre class="src src-c">// src/card.h (追加)

enum e_Suit {CLUB=1,DIAMOND,HEART,SPADE};
enum e_Suit card_suit_new_from_string(char *);

enum e_No { TWO=2, THREE, FOUR, FIVE,
	    SIX, SEVEN, EIGHT, NINE, TEN,
	    JACK, QUEEN, KING, ACE};

enum e_No card_no_new_from_string(char *);
</pre>
</div>
</div>
</li>

<li><a id="sec-7-1-2-2" name="sec-7-1-2-2"></a>test/test<sub>card</sub>.cの変更<br  /><div class="outline-text-5" id="text-7-1-2-2">
<p>
test/test<sub>card</sub>.c から card<sub>no</sub><sub>new</sub><sub>from</sub><sub>string</sub> に関する宣言を消しま
す。
</p>

<div class="org-src-container">

<pre class="src src-c">// test/test_card.c.1
# include &lt;cutter.h&gt;
# include &lt;card.h&gt;

void
test_card_suit_new_from_string(void)
{
  cut_set_message("文字列からスーツを作成する。");
  cut_assert_true(card_suit_new_from_string("SPADE")==SPADE);
  cut_assert_true(card_suit_new_from_string("HEART")==HEART);
  cut_assert_true(card_suit_new_from_string("DIAMOND")==DIAMOND);
  cut_assert_true(card_suit_new_from_string("CLUB")==CLUB);
}

void
test_card_no_new_from_string(void)
{
  cut_set_message("番号から数値への変換のテスト");
  cut_assert(card_no_new_from_string("1")==ACE);
  cut_assert(card_no_new_from_string("13")==KING);
  cut_assert(card_no_new_from_string("12")==QUEEN);
  cut_assert(card_no_new_from_string("11")==JACK);
  cut_assert(card_no_new_from_string("10")==10);
}
</pre>
</div>
</div>
</li>

<li><a id="sec-7-1-2-3" name="sec-7-1-2-3"></a>card<sub>no</sub><sub>new</sub><sub>from</sub><sub>string</sub> の実装 (src/card.c の更新)<br  /><div class="outline-text-5" id="text-7-1-2-3">
<p>
番号を表す文字列から，内部番号にする関数 card<sub>no</sub><sub>new</sub><sub>from</sub><sub>string</sub>
を実装します.
</p>

<ul class="org-ul">
<li>src/card.h 中の，下記インタフェースの宣言
</li>
</ul>

<div class="org-src-container">

<pre class="src src-C">// src/card.h
enum e_No card_no_new_from_string(char *);
</pre>
</div>

<p>
から入口と出口コードを書きます.
</p>

<p>
引数に名前をつけ， 戻り値の型を指定し，戻り値をリターンするコード
を書きます:
</p>

<div class="org-src-container">

<pre class="src src-c">enum e_No
card_no_new_from_string(char *no_str)
{
  int no;

  return (enum e_No) no;
}
</pre>
</div>

<p>
番号を表す文字列から数値を計算するコードは，例えば，つぎのように
なります。
</p>

<ul class="org-ul">
<li>整数値文字列を整数にするためのライブラリ関数 int atoi(char *) を使
います:
</li>
</ul>

<div class="org-src-container">

<pre class="src src-c">int no = atoi(no_str);
</pre>
</div>

<ul class="org-ul">
<li>1~13 の数値を，2~14 の数値に変換し，おかしな値がないかチェックし
ます
</li>
</ul>

<div class="org-src-container">

<pre class="src src-c">if (no==1)  no = ACE;

if ( no &lt; TWO &amp;&amp; ACE &lt; no )
  {
    fprintf(stderr, "不適な数値 (%s)!\n", no_str);
  };
</pre>
</div>

<p>
全体を合わせて:
</p>

<div class="org-src-container">

<pre class="src src-c">// src/card.c
# include &lt;stdio.h&gt;
# include &lt;string.h&gt;
# include &lt;card.h&gt;

enum e_Suit
card_suit_new_from_string(char *suit_str)
{
  if (strcmp("CLUB",suit_str)==0)
    return CLUB;
  if (strcmp("DIAMOND",suit_str)==0)
    return DIAMOND;
  if (strcmp("HEART",suit_str)==0)
    return HEART;
  if (strcmp("SPADE",suit_str)==0)
    return SPADE;
  return 0;
}

enum e_No
card_no_new_from_string(char *no_str)
{
  int no = atoi(no_str);

  if (no==1)  no = ACE;

  if ( no &lt; TWO &amp;&amp; ACE &lt; no )
    {
      fprintf(stderr, "不適な数値 (%s)!\n", no_str);
    };
  return (enum e_No) no;
}
</pre>
</div>

<div class="org-src-container">

<pre class="src src-sh"># 先生だけのコード
(cp src/card.c.0 src/card.c)
</pre>
</div>
</div>
</li>

<li><a id="sec-7-1-2-4" name="sec-7-1-2-4"></a>src/Makefile<br  /><div class="outline-text-5" id="text-7-1-2-4">
<p>
src/card.h と src/card.c から src/card.o を作成し，src/card.o から
src/libcard.a を作成するルールに変更はありません。
</p>

<p>
なので，Makefileにルール変更はありません。
</p>


<div class="org-src-container">

<pre class="src src-sh"># ~/progs/card_display/simple/src
make card.o
</pre>
</div>

<pre class="example">
gcc card.c -g -c -fPIC -I. 
</pre>

<p>
実装コードに間違いがなければ， src/card.o ができて成功します。
</p>

<p>
src/card.o ができない場合，src/card.c に間違いあるか，Makefile に
間違いがあります。エラー箇所を特定し，エラーを取り除いてください。
</p>

<p>
src/card.o ができれば， src/libcard.a を作成します:
</p>

<div class="org-src-container">

<pre class="src src-sh"># ~/progs/CardDisplay/simple/src
make libcard.a
</pre>
</div>

<p>
Makefileが正しければ，これは成功します。libcard.a の中身を確かめてみましょう:
</p>

<div class="org-src-container">

<pre class="src src-sh"># ~/progs/CardDisplay/simple/src
nm libcard.a
</pre>
</div>

<pre class="example">
card.o:
                 U _GLOBAL_OFFSET_TABLE_
                 U atoi
000000000000008b T card_no_new_from_string
0000000000000000 T card_suit_new_from_string
                 U fprintf
                 U stderr
                 U strcmp
</pre>


<p>
T card<sub>no</sub><sub>new</sub><sub>from</sub><sub>string，</sub> T card<sub>suit</sub><sub>new</sub><sub>from</sub><sub>string</sub> で関数が定
義されているのがわかります。
</p>
</div>
</li>

<li><a id="sec-7-1-2-5" name="sec-7-1-2-5"></a>テスト test/test<sub>card</sub>.so の再ビルド<br  /><div class="outline-text-5" id="text-7-1-2-5">
<p>
src/libcard.a が更新できたので，次は libcard.a をリンクし直して，
test/test<sub>card</sub>.so を更新します。
</p>

<div class="org-src-container">

<pre class="src src-sh"># ~/progs/card_display/simple/test/
make clean
make test_card.so
</pre>
</div>

<p>
rm -f <b>.o *.so *~ \#</b> *.gch
gcc -c test<sub>card</sub>.c -fPIC -I../src `pkg-config cutter &#x2013;cflags`
gcc -o test<sub>card</sub>.so &#x2013;shared test<sub>card</sub>.o -L../src/ -lcard `pkg-config cutter &#x2013;libs`
</p>
</div>
</li></ol>
</div>


<div id="outline-container-sec-7-1-3" class="outline-4">
<h4 id="sec-7-1-3"><span class="section-number-4">7.1.3</span> テスト</h4>
<div class="outline-text-4" id="text-7-1-3">
<p>
機能の実装が終り，テストもビルドできました。
</p>

<p>
これからは，機能が要求を満たすことを確かめるためにテストし，テスト
が失敗した場合は，test/test<sub>card</sub>.c, src/{card.h, card.c} を修正
していくことになります。
</p>

<div class="org-src-container">

<pre class="src src-sh"># ~/progs/card_display/simple
make
</pre>
</div>

<pre class="example">
(cd src; make)
make[1]: ディレクトリ `/home/staff/suzuki/COMM/Lects/prog/site/org-docs/tdd-card-display-simple/babel/simple/no_new/src' に入ります
make[1]: `libcard.a' は更新済みです
make[1]: ディレクトリ `/home/staff/suzuki/COMM/Lects/prog/site/org-docs/tdd-card-display-simple/babel/simple/no_new/src' から出ます
(cd test; make)	
make[1]: ディレクトリ `/home/staff/suzuki/COMM/Lects/prog/site/org-docs/tdd-card-display-simple/babel/simple/no_new/test' に入ります
make[1]: `test_card.so' は更新済みです
make[1]: ディレクトリ `/home/staff/suzuki/COMM/Lects/prog/site/org-docs/tdd-card-display-simple/babel/simple/no_new/test' から出ます
cutter -v v test/
test_card:
  test_card_no_new_from_string:				.: (0.000075)
  test_card_suit_new_from_string:			.: (0.000038)

Finished in 0.000531 seconds (total: 0.000113 seconds)

2 test(s), 9 assertion(s), 0 failure(s), 0 error(s), 0 pending(s), 0 omission(s), 0 notification(s)
100% passed
</pre>

<p>
となればテスト成功です。
</p>

<p>
失敗した場合，失敗した関数を特定し，原因がテスト側
(test/test<sub>card</sub>.c) なのか， 実装側 (src/card.c) なのか，
インタフェース (src/card.h) なのか，特定してし，
失敗の原因を取り 除いてください。
</p>
</div>


<ol class="org-ol"><li><a id="sec-7-1-3-1" name="sec-7-1-3-1"></a>テストと再設計<br  /><div class="outline-text-5" id="text-7-1-3-1">
<p>
この節でおこなったこと:
</p>

<ul class="org-ul">
<li>新たな機能の要求 card<sub>no</sub><sub>new</sub><sub>from</sub><sub>string</sub> があり，
</li>
<li>test/test<sub>card</sub>.c に新らしいテスト関数を作成し，
</li>
<li>src/card.h に新たな機能のインターフェイス宣言を付け加え，
</li>
<li>src/card.c にその機能の実装を付け加えた
</li>
</ul>
</div>
</li></ol>
</div>
</div>
</div>

<div id="outline-container-sec-8" class="outline-2">
<h2 id="sec-8"><span class="section-number-2">8</span> トランプ・カードを作成</h2>
<div class="outline-text-2" id="text-8">
</div><div id="outline-container-sec-8-1" class="outline-3">
<h3 id="sec-8-1"><span class="section-number-3">8.1</span> トランプ・カードを作成</h3>
<div class="outline-text-3" id="text-8-1">
</div><div id="outline-container-sec-8-1-1" class="outline-4">
<h4 id="sec-8-1-1"><span class="section-number-4">8.1.1</span> 機能の追加とテストの作成</h4>
<div class="outline-text-4" id="text-8-1-1">
<p>
カードを作る機能のテストは，test/test<sub>card</sub>.c に追加作成します。
</p>

<p>
設計については，<a href="http://wiki.cis.iwate-u.ac.jp/~suzuki/lects/prog/org-docs/card-display/#outline-container-sec-2">card<sub>display</sub><sub>simple問題への解法</sub></a> も参考にしてくださ
い。
</p>
</div>

<ol class="org-ol"><li><a id="sec-8-1-1-1" name="sec-8-1-1-1"></a>card<sub>new</sub> のテストを書く<br  /><div class="outline-text-5" id="text-8-1-1-1">
<p>
機能の名前を card<sub>new</sub> とし, card<sub>newが満たすテストを書きます</sub>:
</p>

<div class="org-src-container">

<pre class="src src-c">Card sa = card_new(SPADE, ACE);
</pre>
</div>

<p>
次のような事が分かります:
</p>
<ul class="org-ul">
<li>Card型が必要である，
</li>
<li>スーツと番号を与え，
</li>
<li>Card型の値が返る。
</li>
</ul>

<p>
これだけではテストにならないので，スーツと番号を取り出す機能を合わ
せて，追加します。
</p>

<div class="org-src-container">

<pre class="src src-c">enum e_Suit card_suit(Card);
enum e_No card_no(Card);
</pre>
</div>

<p>
これにより，テストが書けます:
</p>

<pre class="example">
Card sa = card_new(SPADE, ACE);
cut_assert( card_suit(sa)==SPADE );
cut_assert( card_no(sa)==ACE );
</pre>

<p>
スペードのACEを作り，つくられたカードのスーツと番号が正しいか，確
かめています。
</p>

<p>
Card型が定義できれば，これでよさそうです。
</p>

<div class="org-src-container">

<pre class="src src-c">void
test_card_new(void)
{
  cut_set_message("スーツと番号からカードを作成");
  {
    Card sa = card_new(SPADE,ACE);
    cut_assert( card_suit(sa)==SPADE );
    cut_assert( card_no(sa)==ACE );
  }
}
</pre>
</div>
</div>
</li>

<li><a id="sec-8-1-1-2" name="sec-8-1-1-2"></a>card<sub>new</sub>, card<sub>suit</sub>, card<sub>no</sub> のインタフェースを決める<br  /><div class="outline-text-5" id="text-8-1-1-2">
<p>
card<sub>new</sub> を関数の形で書けたので，関数の型を決めます。
</p>

<p>
戻り値の型は Card，与える引数はスーツと番号の内部表現なので:
</p>

<div class="org-src-container">

<pre class="src src-c">enum e_Suit card_suit(Card);
enum e_No card_no(Card);
Card card_new(enum e_Suit, enum e_No);
</pre>
</div>
</div>
</li>

<li><a id="sec-8-1-1-3" name="sec-8-1-1-3"></a>Card型を定義する<br  /><div class="outline-text-5" id="text-8-1-1-3">
<p>
Card 型を定義しましょう。Card型は次の情報を持ちます:
</p>

<ul class="org-ul">
<li>スーツを表す enum e<sub>Suit</sub> 型の数値
</li>
<li>番号を表す enum e<sub>No</sub> 型の数値
</li>
</ul>

<p>
これを構造体で表します:
</p>

<div class="org-src-container">

<pre class="src src-c">struct _Card {
  enum e_Suit suit;
  enum e_No no;
};
</pre>
</div>

<p>
ですね。
</p>

<p>
これを型にします。
</p>

<div class="org-src-container">

<pre class="src src-c">typdef struct _Card Card;
</pre>
</div>

<p>
struct _Card 型を Card 型として定義し，Card が
構造体であることを意識せずに使うことができます。
</p>
</div>
</li>

<li><a id="sec-8-1-1-4" name="sec-8-1-1-4"></a>テスト全体プログラムの確認<br  /><div class="outline-text-5" id="text-8-1-1-4">
<p>
test/test<sub>card</sub>.cは次のようになります:
</p>

<div class="org-src-container">

<pre class="src src-c">// test/test_card.c
# include &lt;cutter.h&gt;
# include &lt;card.h&gt;

void
test_card_suit_new_from_string(void)
{
  cut_set_message("文字列からスーツを作成する。");
  cut_assert_true(card_suit_new_from_string("SPADE")==SPADE);
  cut_assert_true(card_suit_new_from_string("HEART")==HEART);
  cut_assert_true(card_suit_new_from_string("DIAMOND")==DIAMOND);
  cut_assert_true(card_suit_new_from_string("CLUB")==CLUB);
}

void
test_card_no_new_from_string(void)
{
  cut_set_message("番号から数値への変換のテスト");
  cut_assert(card_no_new_from_string("1")==ACE);
  cut_assert(card_no_new_from_string("13")==KING);
  cut_assert(card_no_new_from_string("12")==QUEEN);
  cut_assert(card_no_new_from_string("11")==JACK);
  cut_assert(card_no_new_from_string("10")==10);
}

struct _Card {
  enum e_Suit suit;
  enum e_No no;
};

typedef struct _Card Card;

enum e_Suit card_suit(Card);
enum e_No card_no(Card);
Card card_new(enum e_Suit, enum e_No);

void
test_card_new(void)
{
   cut_set_message("スーツと番号からカードを作成");
  {
    Card sa = card_new(SPADE,ACE);
    cut_assert(card_suit(sa)==SPADE);
    cut_assert(card_no(sa)==ACE);
  }
}
</pre>
</div>

<div class="org-src-container">

<pre class="src src-c">// src/card.h
# include &lt;string.h&gt;

enum e_Suit {CLUB=1,DIAMOND,HEART,SPADE};
enum e_Suit card_suit_new_from_string(char *);

enum e_No { TWO=2, THREE, FOUR, FIVE,
	    SIX, SEVEN, EIGHT, NINE, TEN,
	    JACK, QUEEN, KING, ACE};
enum e_No card_no_new_from_string(char *);
</pre>
</div>
</div>
</li>

<li><a id="sec-8-1-1-5" name="sec-8-1-1-5"></a>test/Makefile の確認<br  /><div class="outline-text-5" id="text-8-1-1-5">
<p>
test/Makefile の目的は変わっていませんので，Makefile の更新の必要はありません。
</p>

<div class="org-src-container">

<pre class="src src-c"># test/Makefile
.PHONY: clean
CFLAGS = -fPIC -I../src `pkg-config cutter --cflags`
LDFLAGS = -L../src/ -lcard `pkg-config cutter --libs`

test_card.so: test_card.o
	gcc -o $@ --shared $^ $(LDFLAGS)

test_card.o: test_card.c
	gcc -c $&lt; $(CFLAGS)

clean:
	rm -f *.o *.so *~ \#* *.gch
</pre>
</div>

<p>
test/test<sub>card</sub>.c には card<sub>new</sub> に関するテスト関数が加わっています。
card<sub>new</sub> はまだ未実装ですが，test/test<sub>card</sub>.o は作成できます。
</p>
</div>
</li>

<li><a id="sec-8-1-1-6" name="sec-8-1-1-6"></a>test/test<sub>card</sub>.o の作成<br  /><div class="outline-text-5" id="text-8-1-1-6">
<div class="org-src-container">

<pre class="src src-sh"># ~/progs/card_display/simple/test
make test_card.o
</pre>
</div>

<pre class="example">
gcc -c test_card.c -fPIC -I../src `pkg-config cutter --cflags`
</pre>

<p>
test<sub>card</sub>.o ができれば，ひとまず，成功です。
</p>

<p>
できない時は，test<sub>card</sub>.c に間違いがあるか，Makefile に間違いがあ
ります。エラーメッセージからどちらの間違いなのか特定し，修正しましょ
う。
</p>

<p>
成功したら，test/test<sub>card</sub>.o の中身を見てみましょう:
</p>

<div class="org-src-container">

<pre class="src src-sh"># ~/progs/card_display/simple/test
nm test_card.o
</pre>
</div>

<pre class="example">
		 U _GLOBAL_OFFSET_TABLE_
00000000000004c0 r __PRETTY_FUNCTION__.3255
00000000000004e0 r __PRETTY_FUNCTION__.3271
00000000000004fd r __PRETTY_FUNCTION__.3302
		 U _setjmp
		 U card_new
		 U card_no
		 U card_no_new_from_string
		 U card_suit
		 U card_suit_new_from_string
		 U cut_assert_helper
		 U cut_assert_true_helper
		 U cut_test_context_current_peek
		 U cut_test_context_finish_user_message_jump
		 U cut_test_context_get_have_current_result
		 U cut_test_context_get_jump_buffer
		 U cut_test_context_in_user_message_jump
		 U cut_test_context_long_jump
		 U cut_test_context_pop_backtrace
		 U cut_test_context_process_current_result
		 U cut_test_context_push_backtrace
		 U cut_test_context_set_jump_buffer
		 U cut_test_context_set_user_message
		 U cut_test_context_start_user_message_jump
0000000000000a1b T test_card_new
0000000000000482 T test_card_no_new_from_string
0000000000000000 T test_card_suit_new_from_string
</pre>


<p>
card<sub>newが未定義で，</sub>
test<sub>card</sub><sub>new</sub> が定義されているのがわかります。
</p>
</div>
</li></ol>
</div>

<div id="outline-container-sec-8-1-2" class="outline-4">
<h4 id="sec-8-1-2"><span class="section-number-4">8.1.2</span> card<sub>new</sub> の実装</h4>
<div class="outline-text-4" id="text-8-1-2">
<p>
さて次は，機能 card<sub>new</sub> の実装です。
手順は，card<sub>no</sub><sub>new</sub><sub>from</sub><sub>string</sub> を実装したときと同様です:
</p>

<ul class="org-ul">
<li>test/test<sub>card</sub>.c を作成するときに決めたインタフェースをとりだし，
src/card.h に移す。
</li>
<li>src/card.hを遵守し，src/card.c に機能を追加実装する。
</li>
<li>提供する機能を入れた src/libcard.a を作成する
</li>
</ul>

<p>
src/{card.h，libcard.a} で機能を提供する
</p>
</div>

<ol class="org-ol"><li><a id="sec-8-1-2-1" name="sec-8-1-2-1"></a>card/card.h の更新<br  /><div class="outline-text-5" id="text-8-1-2-1">
<p>
test/test<sub>card</sub>.c から card<sub>new等に関するインタフェース宣言を，</sub>
src/card.h に移します。
</p>

<p>
ここまでで，src/card.h は次のようになります:
</p>

<div class="org-src-container">

<pre class="src src-c">// src/card.h
# include &lt;string.h&gt;

enum e_Suit {CLUB=1,DIAMOND,HEART,SPADE};
enum e_Suit card_suit_new_from_string(char *);

enum e_No { TWO=2, THREE, FOUR, FIVE,
	    SIX, SEVEN, EIGHT, NINE, TEN,
	    JACK, QUEEN, KING, ACE};
enum e_No card_no_new_from_string(char *);

struct _Card {
  enum e_Suit suit;
  enum e_No no;
};

typedef struct _Card Card;

enum e_Suit card_suit(Card);
enum e_No card_no(Card);
Card card_new(enum e_Suit, enum e_No);
</pre>
</div>
<p>
test/test<sub>card</sub>.c は次のようになります：
</p>

<div class="org-src-container">

<pre class="src src-c">// test/test_card.c
# include &lt;cutter.h&gt;
# include &lt;card.h&gt;

void
test_card_suit_new_from_string(void)
{
  cut_set_message("文字列からスーツを作成する。");
  cut_assert_true(card_suit_new_from_string("SPADE")==SPADE);
  cut_assert_true(card_suit_new_from_string("HEART")==HEART);
  cut_assert_true(card_suit_new_from_string("DIAMOND")==DIAMOND);
  cut_assert_true(card_suit_new_from_string("CLUB")==CLUB);
}

void
test_card_no_new_from_string(void)
{
  cut_set_message("番号から数値への変換のテスト");
  cut_assert(card_no_new_from_string("1")==ACE);
  cut_assert(card_no_new_from_string("13")==KING);
  cut_assert(card_no_new_from_string("12")==QUEEN);
  cut_assert(card_no_new_from_string("11")==JACK);
  cut_assert(card_no_new_from_string("10")==10);
}

void
test_card_new(void)
{
   cut_set_message("スーツと番号からカードを作成");
  {
    Card sa = card_new(SPADE,ACE);
    cut_assert(card_suit(sa)==SPADE);
    cut_assert(card_no(sa)==ACE);
  }
}
</pre>
</div>
</div>
</li>

<li><a id="sec-8-1-2-2" name="sec-8-1-2-2"></a>card<sub>new</sub> の実装 (src/card.cの更新)<br  /><div class="outline-text-5" id="text-8-1-2-2">
<p>
card<sub>new関数への要求は</sub>
</p>
<ul class="org-ul">
<li>スーツの内部表現と数字の内部表現から，
</li>
<li>カードを表すデータを作る
</li>
</ul>

<p>
ことでしたから，実装は次のようになるでしょう:
</p>

<div class="org-src-container">

<pre class="src src-c">Card
card_new(enum e_Suit suit, enum e_No no)
{
  Card new;

  new.suit = suit;
  new.no = no;
  return new;
}
</pre>
</div>
</div>
</li>

<li><a id="sec-8-1-2-3" name="sec-8-1-2-3"></a>card<sub>suit</sub> の実装 (src/card.cの更新)<br  /><div class="outline-text-5" id="text-8-1-2-3">
<p>
要求は：
</p>
<ul class="org-ul">
<li>カードデータからそのスーツが分かること
</li>
</ul>

<p>
でしたから，
</p>

<div class="org-src-container">

<pre class="src src-c">enum e_Suit
card_suit(Card c)
{
  return c.suit;
}
</pre>
</div>
</div>
</li>

<li><a id="sec-8-1-2-4" name="sec-8-1-2-4"></a>card<sub>no</sub> の実装 (src/card.cの更新)<br  /><div class="outline-text-5" id="text-8-1-2-4">
<p>
要求は：
</p>
<ul class="org-ul">
<li>カードデータからその数字が分かること
</li>
</ul>

<p>
でしたから，
</p>
<div class="org-src-container">

<pre class="src src-c">enum e_No
card_no(Card c)
{
  return c.no;
}
</pre>
</div>
</div>
</li>

<li><a id="sec-8-1-2-5" name="sec-8-1-2-5"></a>src/card.c 全体<br  /><div class="outline-text-5" id="text-8-1-2-5">
<p>
ここまでの，src/card.c を示しておきます:
</p>

<div class="org-src-container">

<pre class="src src-c">// src/card.c
# include &lt;stdio.h&gt;
# include &lt;string.h&gt;
# include &lt;stdlib.h&gt;
# include &lt;card.h&gt;

enum e_Suit
card_suit_new_from_string(char *suit_str)
{
  if (strcmp("CLUB",suit_str)==0)
    return CLUB;
  if (strcmp("DIAMOND",suit_str)==0)
    return DIAMOND;
  if (strcmp("HEART",suit_str)==0)
    return HEART;
  if (strcmp("SPADE",suit_str)==0)
    return SPADE;
  return 0;
}

enum e_No
card_no_new_from_string(char *no_str)
{
  int no = atoi(no_str);

  if (no==1)  no = ACE;

  if ( no &lt; TWO &amp;&amp; ACE &lt; no )
    {
      fprintf(stderr, "不適な数値 (%s)!\n", no_str);
    };
  return (enum e_No)no;
}

Card
card_new(enum e_Suit suit, enum e_No no)
{
  Card new;

  new.suit = suit;
  new.no = no;
  return new;
}

enum e_Suit
card_suit(Card c)
{
  return c.suit;
}

enum e_No
card_no(Card c)
{
  return c.no;
}
</pre>
</div>
</div>
</li>

<li><a id="sec-8-1-2-6" name="sec-8-1-2-6"></a>src/Makefile<br  /><div class="outline-text-5" id="text-8-1-2-6">
<p>
src/Makefileに変更はありません。
</p>
<div class="org-src-container">

<pre class="src src-c"># src/Makefile 
.PHONY: clean
CFLAGS = -g -c -fPIC -I. 
LDFLAGS = -lc

libcard.a: card.o
	rm -f $@
	ar r $@ $^

card.o: card.c card.h
	gcc $&lt; $(CFLAGS)

clean: 
	rm -f *.o *.so *~ \#* *.gch
</pre>
</div>
</div>
</li>

<li><a id="sec-8-1-2-7" name="sec-8-1-2-7"></a>src/card.o の作成<br  /><div class="outline-text-5" id="text-8-1-2-7">
<p>
src/card.o を make し, ソースコードにエラーがないか確かめます:
</p>

<div class="org-src-container">

<pre class="src src-sh"># ~/progs/card_display/simple/src
make card.o
</pre>
</div>

<pre class="example">
gcc card.c -g -c -fPIC -I. 
</pre>

<p>
src/card.o ができれば文法や宣言の食い違いはなくなったことになりま
す。
</p>
</div>
</li>

<li><a id="sec-8-1-2-8" name="sec-8-1-2-8"></a>src/libcard.a の作成<br  /><div class="outline-text-5" id="text-8-1-2-8">
<p>
src/card.o ができれば，次は， src/libcard.a を make します。
</p>

<div class="org-src-container">

<pre class="src src-sh"># ~/progs/card_display/simple/src
make libcard.a
</pre>
</div>

<pre class="example">
rm -f libcard.a
ar r libcard.a card.o
</pre>

<p>
Makefile が正しければ，これは成功するはずです。
</p>

<p>
libcard.a の中身を確かめてみましょう:
</p>

<div class="org-src-container">

<pre class="src src-sh"># ~/progs/card_display/simple/src
nm libcard.a
</pre>
</div>

<pre class="example">
card.o:
                 U _GLOBAL_OFFSET_TABLE_
                 U atoi
00000000000000e6 T card_new
000000000000010f T card_no
000000000000008b T card_no_new_from_string
0000000000000102 T card_suit
0000000000000000 T card_suit_new_from_string
                 U fprintf
                 U stderr
                 U strcmp
</pre>

<p>
src/libcard.a が更新できたので，次はtest<sub>card</sub>.so を更新します。    
</p>
</div>
</li></ol>
</div>

<div id="outline-container-sec-8-1-3" class="outline-4">
<h4 id="sec-8-1-3"><span class="section-number-4">8.1.3</span> テスト</h4>
<div class="outline-text-4" id="text-8-1-3">
</div><ol class="org-ol"><li><a id="sec-8-1-3-1" name="sec-8-1-3-1"></a>test/test<sub>card</sub>.so のビルド<br  /><div class="outline-text-5" id="text-8-1-3-1">
<p>
src/libcard.a が更新されているので，test/test<sub>card</sub>.so を作り直しま
す。
</p>

<div class="org-src-container">

<pre class="src src-sh"># ~/progs/card_display/simple/test/
make clean
make test_card.so
</pre>
</div>

<pre class="example">
rm -f *.o *.so *~ \#* *.gch
gcc -c test_card.c -fPIC -I../src `pkg-config cutter --cflags`
gcc -o test_card.so --shared test_card.o -L../src/ -lcard `pkg-config cutter --libs`
</pre>

<p>
test/test<sub>card</sub>.so ができればテストの実行に移ります。
</p>

<p>
できない時は，多分，Makefile に間違いがあります。Makefile を修正してください。
</p>
</div>
</li>

<li><a id="sec-8-1-3-2" name="sec-8-1-3-2"></a>テストの実行<br  /><div class="outline-text-5" id="text-8-1-3-2">
<p>
テストの作成と機能の実装が終ったので，機能が要求を満たすことを確か
めるためにテストする:
</p>

<div class="org-src-container">

<pre class="src src-sh"># ~/progs/card_display/simple
cutter -v v test
</pre>
</div>

<pre class="example">
test_card:
  test_card_no_new_from_string:                         .: (0.000136)
  test_card_suit_new_from_string:                       .: (0.000079)
  test_card_new:                                        .: (0.000044)

Finished in 0.001173 seconds (total: 0.000259 seconds)

3 test(s), 11 assertion(s), 0 failure(s), 0 error(s), 0 pending(s), 0 omission(s), 0 notification(s)
100% passed
</pre>
</div>
</li>

<li><a id="sec-8-1-3-3" name="sec-8-1-3-3"></a>テストと再設計<br  /><div class="outline-text-5" id="text-8-1-3-3">
<p>
テストが成功すれば，テストによる開発の1サイクルが完結したことにな
ります。
</p>

<p>
テストが失敗した場合は，test/test<sub>card</sub>.c, src/{card.h, card.c} を
修正していくことになります。
</p>

<p>
ソースコードを修正した後は，Makefileに間違いがなけれ
ば，~/progs/card<sub>display</sub>/simpleで make すれば，全自動でテストまで
実行してくれます。テストが成功するまで繰り返してください。
</p>
</div>
</li></ol>
</div>
</div>
</div>

<div id="outline-container-sec-9" class="outline-2">
<h2 id="sec-9"><span class="section-number-2">9</span> トランプ・カードを文字列に</h2>
<div class="outline-text-2" id="text-9">
<p>
自分でやってみましょう。
</p>
</div>

<div id="outline-container-sec-9-1" class="outline-3">
<h3 id="sec-9-1"><span class="section-number-3">9.1</span> 設計</h3>
<div class="outline-text-3" id="text-9-1">
<p>
要求は，カードの内部表現を文字列にすること
</p>

<ul class="org-ul">
<li>2文字からなるの文字列とする
</li>
<li>スーツは 'S', 'H', 'D', 'C',  1文字
</li>
<li>数は 'A','K','Q','J','0','9','8','7','6','5','4','3','2'，1文字
</li>
</ul>

<p>
処理
</p>
<ul class="org-ul">
<li>スーツや番号を添字に配列を参照するのも一つの方法
</li>
</ul>
</div>

<div id="outline-container-sec-9-1-1" class="outline-4">
<h4 id="sec-9-1-1"><span class="section-number-4">9.1.1</span> 機能の名前と構造</h4>
<div class="outline-text-4" id="text-9-1-1">
<p>
card<sub>to</sub><sub>string</sub> カードを文字列にする機能
</p>
<ul class="org-ul">
<li>card<sub>suit</sub><sub>to</sub><sub>string</sub>  スーツを1文字にする機能
</li>
<li>card<sub>no</sub><sub>to</sub><sub>string</sub> 番号を1文字にする機能
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-9-1-2" class="outline-4">
<h4 id="sec-9-1-2"><span class="section-number-4">9.1.2</span> 関数の引数と戻り値の型 (APIの設計)</h4>
<div class="outline-text-4" id="text-9-1-2">
<ul class="org-ul">
<li>char *card<sub>to</sub><sub>string</sub>(Card);
<ul class="org-ul">
<li>char *card<sub>suit</sub><sub>to</sub><sub>string</sub>(int suit);
</li>
<li>char *card<sub>no</sub><sub>to</sub><sub>string</sub>(int no);
</li>
</ul>
</li>
</ul>
</div>
</div>
</div>

<div id="outline-container-sec-9-2" class="outline-3">
<h3 id="sec-9-2"><span class="section-number-3">9.2</span> テストによる開発</h3>
<div class="outline-text-3" id="text-9-2">
<p>
card<sub>no</sub><sub>new</sub><sub>from</sub><sub>string</sub> や card<sub>new</sub> の開発をまねして，
テストによる開発を行って下さい。
</p>

<p>
開発の過程を，ドキュメントとしてまとめ，レポート提出
してください。
</p>
</div>
</div>
</div>

<div id="outline-container-sec-10" class="outline-2">
<h2 id="sec-10"><span class="section-number-2">10</span> card<sub>display</sub><sub>simple</sub> 問題の解の作成</h2>
<div class="outline-text-2" id="text-10">
<ul class="org-ul">
<li>~/progs/CardDisplay/simple/ に，
</li>

<li>作成した src/libcard.a を利用し，
</li>

<li>card<sub>display</sub><sub>simple</sub>.c を作成し，
</li>

<li>Makefile を書き換えて, card<sub>display</sub><sub>simple</sub> をビルドできるように，
してください。
</li>
</ul>
</div>
</div>


<div id="outline-container-sec-11" class="outline-2">
<h2 id="sec-11"><span class="section-number-2">11</span> card<sub>display</sub><sub>multi</sub></h2>
<div class="outline-text-2" id="text-11">
<p>
Card cards<sup><a id="fnr.1" name="fnr.1" class="footref" href="#fn.1">1</a></sup>; を使ってみる。
</p>
</div>
</div>

<div id="outline-container-sec-12" class="outline-2">
<h2 id="sec-12"><span class="section-number-2">12</span> card<sub>display</sub><sub>sort</sub></h2>
<div class="outline-text-2" id="text-12">
<p>
typedef Card *[] Cards; を機能として組み込む
</p>
</div>
</div>
<div id="footnotes">
<h2 class="footnotes">Footnotes: </h2>
<div id="text-footnotes">

<div class="footdef"><sup><a id="fn.1" name="fn.1" class="footnum" href="#fnr.1">1</a></sup> <p>DEFINITION NOT FOUND.</p></div>


</div>
</div></div>
<div id="postamble" class="status">
<p class="author">Author: m</p>
<p class="date">Created: 2015-12-01 火 11:29</p>
<p class="creator"><a href="http://www.gnu.org/software/emacs/">Emacs</a> 24.5.1 (<a href="http://orgmode.org">Org</a> mode 8.2.10)</p>
<p class="validation"><a href="http://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
